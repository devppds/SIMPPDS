globalThis.monorepoPackagePath = ""; import process from './process-polyfill.mjs'; import { requiredServerFiles, buildId, routesManifest, prerenderManifest, appPathRoutesManifest, pagesManifest, middlewareManifest, functionsConfigManifest } from './manifests.mjs'; import { Buffer } from 'node:buffer'; import { createRequire as topLevelCreateRequire } from 'module'; const require = topLevelCreateRequire(import.meta.url || "file:///"); import bannerUrl from 'url'; const __dirname = bannerUrl.fileURLToPath(new URL('.', import.meta.url || "file:///")); globalThis.openNextDebug = false; globalThis.openNextVersion = "3.9.7";
var R6e = Object.create; var NP = Object.defineProperty; var A6e = Object.getOwnPropertyDescriptor; var T6e = Object.getOwnPropertyNames; var w6e = Object.getPrototypeOf, b6e = Object.prototype.hasOwnProperty; var ai = (e => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, { get: (t, r) => (typeof require < "u" ? require : t)[r] }) : e)(function (e) { if (typeof require < "u") return require.apply(this, arguments); throw Error('Dynamic require of "' + e + '" is not supported') }); var s = (e, t) => () => (e && (t = e(e = 0)), t); var Ip = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Qe = (e, t) => { for (var r in t) NP(e, r, { get: t[r], enumerable: !0 }) }, I6e = (e, t, r, o) => { if (t && typeof t == "object" || typeof t == "function") for (let n of T6e(t)) !b6e.call(e, n) && n !== r && NP(e, n, { get: () => t[n], enumerable: !(o = A6e(t, n)) || o.enumerable }); return e }; var E4 = (e, t, r) => (r = e != null ? R6e(w6e(e)) : {}, I6e(t || !e || !e.__esModule ? NP(r, "default", { value: e, enumerable: !0 }) : r, e)); function Jd(e) { try { return "__openNextInternal" in e } catch { return !1 } } var y4 = s(() => { }); function be(...e) { globalThis.openNextDebug && console.log(...e) } function Bx(...e) { console.warn(...e) } function Qt(...e) { if (e.some(t => P6e(t))) return be(...e); if (e.some(t => Jd(t))) { let t = e.find(r => Jd(r)); return t.logLevel < O6e() ? void 0 : t.logLevel === 0 ? console.log(...e.map(r => Jd(r) ? `${r.name}: ${r.message}` : r)) : t.logLevel === 1 ? Bx(...e.map(r => Jd(r) ? `${r.name}: ${r.message}` : r)) : console.error(...e) } console.error(...e) } function O6e() { switch ((process.env.OPEN_NEXT_ERROR_LOG_LEVEL ?? "1").toLowerCase()) { case "debug": case "0": return 0; case "error": case "2": return 2; default: return 1 } } var v6e, P6e, vp, vr = s(() => { y4(); v6e = [{ clientName: "S3Client", commandName: "GetObjectCommand", errorName: "NoSuchKey" }], P6e = e => v6e.some(t => t.clientName === e?.clientName && t.commandName === e?.commandName && (t.errorName === e?.error?.name || t.errorName === e?.error?.Code)); vp = { trace: () => { }, debug: () => { }, info: be, warn: Bx, error: Qt } }); function S4() { let e = process.env; e.NODE_ENV = process.env.NODE_ENV ?? "production" } function _4() { return Math.random().toString(36).slice(2, 8) } function BP(e, t) { return e.reduce((o, n, i) => { let a = Math.floor(i / t); return o[a] = [...o[a] ?? [], n], o }, new Array) } function Lx(e) { if (typeof e != "string") return e; let t = Number.parseInt(e); return Number.isNaN(t) ? void 0 : t } var Zd = s(() => { }); function $x(e) { return e ? typeof e == "string" ? e.split(/(?<!Expires=\w+),/i).map(t => t.trim()) : e : [] } function Fx(e) { let t = {}; for (let [r, o] of e) r in t ? Array.isArray(t[r]) ? t[r].push(o) : t[r] = [t[r], o] : t[r] = o; return t } var Mx, D6e, ef = s(() => { vr(); Mx = e => { let t = {}; if (!e) return t; for (let [r, o] of Object.entries(e)) { if (o === void 0) continue; let n = r.toLowerCase(); if (n === "location" && Array.isArray(o)) { o.length === 1 || o[0] === o[1] ? t[n] = o[0] : (Bx("Multiple different values for Location header found. Using the last one"), t[n] = o[o.length - 1]); continue } t[n] = D6e(o) } return t }, D6e = e => typeof e == "string" ? e : Array.isArray(e) ? e.join(",") : String(e) }); function Pp(e) { if (!e) return !1; let t = e.split(";")[0]; return F6e.has(t) } var F6e, Gx = s(() => { F6e = new Set(["application/octet-stream", "application/epub+zip", "application/msword", "application/pdf", "application/rtf", "application/vnd.amazon.ebook", "application/vnd.ms-excel", "application/vnd.ms-powerpoint", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "font/otf", "font/woff", "font/woff2", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/tiff", "image/vnd.microsoft.icon", "image/webp", "audio/3gpp", "audio/aac", "audio/basic", "audio/flac", "audio/mpeg", "audio/ogg", "audio/wavaudio/webm", "audio/x-aiff", "audio/x-midi", "audio/x-wav", "video/3gpp", "video/mp2t", "video/mpeg", "video/ogg", "video/quicktime", "video/webm", "video/x-msvideo", "application/java-archive", "application/vnd.apple.installer+xml", "application/x-7z-compressed", "application/x-apple-diskimage", "application/x-bzip", "application/x-bzip2", "application/x-gzip", "application/x-java-archive", "application/x-rar-compressed", "application/x-tar", "application/x-zip", "application/zip", "application/x-protobuf"]) }); function Kx(e) { return Fx(e.entries()) } var zP = s(() => { ef() }); var Eq = Ip(Ss => { "use strict"; Object.defineProperty(Ss, "__esModule", { value: !0 }); Ss.parseCookie = gq; Ss.parse = gq; Ss.stringifyCookie = U8e; Ss.stringifySetCookie = Xx; Ss.serialize = Xx; Ss.parseSetCookie = H8e; Ss.stringifySetCookie = Xx; Ss.serialize = Xx; var fq = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, hq = /^[\u0021-\u003A\u003C-\u007E]*$/, B8e = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, L8e = /^[\u0020-\u003A\u003D-\u007E]*$/, M8e = /^-?\d+$/, $8e = Object.prototype.toString, F8e = (() => { let e = function () { }; return e.prototype = Object.create(null), e })(); function gq(e, t) { let r = new F8e, o = e.length; if (o < 2) return r; let n = t?.decode || xq, i = 0; do { let a = JP(e, i, o); if (a === -1) break; let c = XP(e, i, o); if (a > c) { i = e.lastIndexOf(";", a - 1) + 1; continue } let p = Xi(e, i, a); r[p] === void 0 && (r[p] = n(Xi(e, a + 1, c))), i = c + 1 } while (i < o); return r } function U8e(e, t) { let r = t?.encode || encodeURIComponent, o = []; for (let n of Object.keys(e)) { let i = e[n]; if (i === void 0) continue; if (!fq.test(n)) throw new TypeError(`cookie name is invalid: ${n}`); let a = r(i); if (!hq.test(a)) throw new TypeError(`cookie val is invalid: ${i}`); o.push(`${n}=${a}`) } return o.join("; ") } function Xx(e, t, r) { let o = typeof e == "object" ? e : { ...r, name: e, value: String(t) }, i = (typeof t == "object" ? t : r)?.encode || encodeURIComponent; if (!fq.test(o.name)) throw new TypeError(`argument name is invalid: ${o.name}`); let a = o.value ? i(o.value) : ""; if (!hq.test(a)) throw new TypeError(`argument val is invalid: ${o.value}`); let c = o.name + "=" + a; if (o.maxAge !== void 0) { if (!Number.isInteger(o.maxAge)) throw new TypeError(`option maxAge is invalid: ${o.maxAge}`); c += "; Max-Age=" + o.maxAge } if (o.domain) { if (!B8e.test(o.domain)) throw new TypeError(`option domain is invalid: ${o.domain}`); c += "; Domain=" + o.domain } if (o.path) { if (!L8e.test(o.path)) throw new TypeError(`option path is invalid: ${o.path}`); c += "; Path=" + o.path } if (o.expires) { if (!G8e(o.expires) || !Number.isFinite(o.expires.valueOf())) throw new TypeError(`option expires is invalid: ${o.expires}`); c += "; Expires=" + o.expires.toUTCString() } if (o.httpOnly && (c += "; HttpOnly"), o.secure && (c += "; Secure"), o.partitioned && (c += "; Partitioned"), o.priority) switch (typeof o.priority == "string" ? o.priority.toLowerCase() : void 0) { case "low": c += "; Priority=Low"; break; case "medium": c += "; Priority=Medium"; break; case "high": c += "; Priority=High"; break; default: throw new TypeError(`option priority is invalid: ${o.priority}`) }if (o.sameSite) switch (typeof o.sameSite == "string" ? o.sameSite.toLowerCase() : o.sameSite) { case !0: case "strict": c += "; SameSite=Strict"; break; case "lax": c += "; SameSite=Lax"; break; case "none": c += "; SameSite=None"; break; default: throw new TypeError(`option sameSite is invalid: ${o.sameSite}`) }return c } function H8e(e, t) { let r = t?.decode || xq, o = e.length, n = XP(e, 0, o), i = JP(e, 0, n), a = i === -1 ? { name: "", value: r(Xi(e, 0, n)) } : { name: Xi(e, 0, i), value: r(Xi(e, i + 1, n)) }, c = n + 1; for (; c < o;) { let p = XP(e, c, o), u = JP(e, c, p), l = u === -1 ? Xi(e, c, p) : Xi(e, c, u), m = u === -1 ? void 0 : Xi(e, u + 1, p); switch (l.toLowerCase()) { case "httponly": a.httpOnly = !0; break; case "secure": a.secure = !0; break; case "partitioned": a.partitioned = !0; break; case "domain": a.domain = m; break; case "path": a.path = m; break; case "max-age": m && M8e.test(m) && (a.maxAge = Number(m)); break; case "expires": if (!m) break; let f = new Date(m); Number.isFinite(f.valueOf()) && (a.expires = f); break; case "priority": if (!m) break; let h = m.toLowerCase(); (h === "low" || h === "medium" || h === "high") && (a.priority = h); break; case "samesite": if (!m) break; let E = m.toLowerCase(); (E === "lax" || E === "strict" || E === "none") && (a.sameSite = E); break }c = p + 1 } return a } function XP(e, t, r) { let o = e.indexOf(";", t); return o === -1 ? r : o } function JP(e, t, r) { let o = e.indexOf("=", t); return o < r ? o : -1 } function Xi(e, t, r) { let o = t, n = r; do { let i = e.charCodeAt(o); if (i !== 32 && i !== 9) break } while (++o < n); for (; n > o;) { let i = e.charCodeAt(n - 1); if (i !== 32 && i !== 9) break; n-- } return e.slice(o, n) } function xq(e) { if (e.indexOf("%") === -1) return e; try { return decodeURIComponent(e) } catch { return e } } function G8e(e) { return $8e.call(e) === "[object Date]" } }); var Sq = {}; Qe(Sq, { default: () => z8e }); import { Buffer as j8e } from "node:buffer"; var yq, q8e, V8e, z8e, _q = s(() => { yq = E4(Eq(), 1); ef(); zP(); q8e = new Set([101, 103, 204, 205, 304]), V8e = { convertFrom: async e => { let t = new URL(e.url), r = t.searchParams, o = Kx(r), n = {}; e.headers.forEach((m, f) => { n[f] = m }); let i = t.pathname, a = e.method, p = a !== "GET" && a !== "HEAD" ? j8e.from(await e.arrayBuffer()) : void 0, u = e.headers.get("cookie"), l = u ? yq.default.parse(u) : {}; return { type: "core", method: a, rawPath: i, url: e.url, body: p, headers: n, remoteAddress: e.headers.get("x-forwarded-for") ?? "::1", query: o, cookies: l } }, convertTo: async e => { if ("internalEvent" in e) { let o = new Request(e.internalEvent.url, { body: e.internalEvent.body, method: e.internalEvent.method, headers: { ...e.internalEvent.headers, "x-forwarded-host": e.internalEvent.headers.host } }); if (globalThis.__dangerous_ON_edge_converter_returns_request === !0) return o; let n = (e.isISR || e.internalEvent.rawPath.startsWith("/_next/image")) && process.env.DISABLE_CACHE !== "true" ? { cacheEverything: !0 } : {}; return fetch(o, { cf: n }) } let t = new Headers; for (let [o, n] of Object.entries(e.headers)) { if (o === "set-cookie" && typeof n == "string") { let i = $x(n); for (let a of i) t.append(o, a); continue } if (Array.isArray(n)) for (let i of n) t.append(o, i); else t.set(o, n) } let r = q8e.has(e.statusCode) ? null : e.body; return new Response(r, { status: e.statusCode, headers: t }) }, name: "edge" }, z8e = V8e }); var Rq = {}; Qe(Rq, { default: () => Q8e }); import { Writable as Cq } from "node:stream"; var W8e, K8e, Q8e, Aq = s(() => { W8e = new Set([101, 204, 205, 304]), K8e = async (e, t) => async (r, o, n, i) => { globalThis.process = process; for (let [m, f] of Object.entries(o)) typeof f == "string" && (process.env[m] = f); let a = await t.convertFrom(r), c = new URL(r.url), { promise: p, resolve: u } = Promise.withResolvers(), l = { writeHeaders(m) { let { statusCode: f, cookies: h, headers: E } = m, S = new Headers(E); for (let L of h) S.append("Set-Cookie", L); if (c.hostname === "localhost" && S.set("Content-Encoding", "identity"), W8e.has(f)) { let L = new Response(null, { status: f, headers: S }); return u(L), new Cq({ write(N, j, re) { re() } }) } let y, C = new ReadableStream({ start(L) { y = L } }), b = new Response(C, { status: f, headers: S }); return u(b), new Cq({ write(L, N, j) { try { y.enqueue(L) } catch (re) { return j(re) } j() }, final(L) { y.close(), L() }, destroy(L, N) { if (L) y.error(L); else try { y.close() } catch { } N(L) } }) }, abortSignal: i, retainChunks: !1 }; return n.waitUntil(e(a, { streamCreator: l, waitUntil: n.waitUntil.bind(n) })), p }, Q8e = { wrapper: K8e, name: "cloudflare-node", supportStreaming: !0 } }); var Tq = s(() => { }); var wq, bq = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(wq || (wq = {})) }); var Iq, vq = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Iq || (Iq = {})) }); var Pq = s(() => { }); var Oq = s(() => { }); var Dq = s(() => { }); var kq = s(() => { }); var Nq = s(() => { bq(); vq(); Pq(); Oq(); Dq(); kq() }); var Bq = s(() => { }); var Lq = s(() => { }); var Mq = s(() => { }); var $q = s(() => { }); var Fq = s(() => { }); var Uq = s(() => { }); var Hq = s(() => { }); var Gq = s(() => { Fq(); Uq(); Hq() }); var jq = s(() => { }); var qq = s(() => { }); var Vq, zq = s(() => { (function (e) { e.HTTP = "http", e.HTTPS = "https" })(Vq || (Vq = {})) }); var Wq = s(() => { }); var Kq = s(() => { }); var Qq = s(() => { }); var Yq = s(() => { }); var Xq = s(() => { }); var Jq = s(() => { Wq(); Kq(); Qq(); Yq(); Xq() }); var Zq = s(() => { }); var eV = s(() => { }); var tV = s(() => { }); var rV = s(() => { eV(); tV() }); var oV = s(() => { }); var nV, sV = s(() => { (function (e) { e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER" })(nV || (nV = {})) }); var iV = s(() => { }); var aV = s(() => { }); var cV = s(() => { }); var pV = s(() => { }); var uV = s(() => { }); var mV = s(() => { aV(); cV(); pV(); uV() }); var lV = s(() => { }); var ZP, dV = s(() => { ZP = "__smithy_context" }); var fV = s(() => { }); var hV, gV = s(() => { (function (e) { e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services" })(hV || (hV = {})) }); var xV = s(() => { }); var EV = s(() => { }); var yV = s(() => { }); var SV = s(() => { }); var _V = s(() => { }); var CV = s(() => { }); var RV = s(() => { }); var AV = s(() => { }); var TV = s(() => { }); var wV = s(() => { }); var bV = s(() => { }); var IV = s(() => { }); var vV = s(() => { }); var PV = s(() => { }); var OV, DV = s(() => { (function (e) { e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0" })(OV || (OV = {})) }); var kV = s(() => { }); var NV = s(() => { }); var BV = s(() => { }); var LV = s(() => { }); var MV = s(() => { }); var $V = s(() => { }); var FV = s(() => { }); var UV = s(() => { Tq(); Nq(); Bq(); Lq(); Mq(); $q(); Gq(); jq(); qq(); zq(); Jq(); Zq(); rV(); oV(); sV(); iV(); mV(); lV(); dV(); fV(); gV(); xV(); EV(); yV(); SV(); _V(); CV(); RV(); AV(); TV(); wV(); bV(); IV(); vV(); PV(); DV(); kV(); NV(); BV(); LV(); MV(); $V(); FV() }); var je, HV = s(() => { UV(); je = e => e[ZP] || (e[ZP] = {}) }); var le, GV = s(() => { le = e => { if (typeof e == "function") return e; let t = Promise.resolve(e); return () => t } }); var gt = s(() => { HV(); GV() }); function ff(e) { return Y8e.includes(e) } var Jx, Y8e, Zx = s(() => { Jx = "preferred", Y8e = ["disabled", "preferred", "required"] }); var jV, qV = s(() => { gt(); Zx(); jV = e => { let { accountIdEndpointMode: t } = e, r = le(t ?? Jx); return Object.assign(e, { accountIdEndpointMode: async () => { let o = await r(); if (!ff(o)) throw new Error(`Invalid value for accountIdEndpointMode: ${o}. Valid values are: "required", "preferred", "disabled".`); return o } }) } }); var VV, zV, X8e, J8e, WV, KV = s(() => { Zx(); VV = "Invalid AccountIdEndpointMode value", zV = e => { throw new Error(e) }, X8e = "AWS_ACCOUNT_ID_ENDPOINT_MODE", J8e = "account_id_endpoint_mode", WV = { environmentVariableSelector: e => { let t = e[X8e]; return t && !ff(t) && zV(VV), t }, configFileSelector: e => { let t = e[J8e]; return t && !ff(t) && zV(VV), t }, default: Jx } }); var eO = s(() => { qV(); Zx(); KV() }); var QV, tO, YV, XV, JV = s(() => { QV = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"], tO = "endpoint_discovery_enabled", YV = e => ["false", "0"].indexOf(e) >= 0, XV = { environmentVariableSelector: e => { for (let t = 0; t < QV.length; t++) { let r = QV[t]; if (r in e) { let o = e[r]; if (o === "") throw Error(`Environment variable ${r} can't be empty of undefined, got "${o}"`); return !YV(o) } } }, configFileSelector: e => { if (tO in e) { let t = e[tO]; if (t === void 0) throw Error(`Shared config entry ${tO} can't be undefined, got "${t}"`); return !YV(t) } }, default: void 0 } }); var ZV = s(() => { }); var ez = s(() => { }); var rz = Ip((Oqt, tz) => { function mi(e) { Object.defineProperty(this, "_next", { writable: !1, enumerable: !1, value: e }), this.done = !1 } mi.prototype.next = function () { if (this.done) return { done: !0 }; var e = this._next(); return e.done && (this.done = !0), e }; typeof Symbol < "u" && (mi.prototype[Symbol.iterator] = function () { return this }); mi.of = function () { var e = arguments, t = e.length, r = 0; return new mi(function () { return r >= t ? { done: !0 } : { done: !1, value: e[r++] } }) }; mi.empty = function () { var e = new mi(null); return e.done = !0, e }; mi.is = function (e) { return e instanceof mi ? !0 : typeof e == "object" && e !== null && typeof e.next == "function" }; tz.exports = mi }); var rO = Ip((Dqt, iz) => { var oz = typeof ArrayBuffer < "u", nz = typeof Symbol < "u"; function sz(e, t) { var r, o, n, i, a; if (!e) throw new Error("obliterator/forEach: invalid iterable."); if (typeof t != "function") throw new Error("obliterator/forEach: expecting a callback."); if (Array.isArray(e) || oz && ArrayBuffer.isView(e) || typeof e == "string" || e.toString() === "[object Arguments]") { for (n = 0, i = e.length; n < i; n++)t(e[n], n); return } if (typeof e.forEach == "function") { e.forEach(t); return } if (nz && Symbol.iterator in e && typeof e.next != "function" && (e = e[Symbol.iterator]()), typeof e.next == "function") { for (r = e, n = 0; a = r.next(), a.done !== !0;)t(a.value, n), n++; return } for (o in e) e.hasOwnProperty(o) && t(e[o], o) } sz.forEachWithNullKeys = function (e, t) { var r, o, n, i, a; if (!e) throw new Error("obliterator/forEachWithNullKeys: invalid iterable."); if (typeof t != "function") throw new Error("obliterator/forEachWithNullKeys: expecting a callback."); if (Array.isArray(e) || oz && ArrayBuffer.isView(e) || typeof e == "string" || e.toString() === "[object Arguments]") { for (n = 0, i = e.length; n < i; n++)t(e[n], null); return } if (e instanceof Set) { e.forEach(function (c) { t(c, null) }); return } if (typeof e.forEach == "function") { e.forEach(t); return } if (nz && Symbol.iterator in e && typeof e.next != "function" && (e = e[Symbol.iterator]()), typeof e.next == "function") { for (r = e, n = 0; a = r.next(), a.done !== !0;)t(a.value, null), n++; return } for (o in e) e.hasOwnProperty(o) && t(e[o], o) }; iz.exports = sz }); var oO = Ip(_s => { var Z8e = Math.pow(2, 8) - 1, eKe = Math.pow(2, 16) - 1, tKe = Math.pow(2, 32) - 1, rKe = Math.pow(2, 7) - 1, oKe = Math.pow(2, 15) - 1, nKe = Math.pow(2, 31) - 1; _s.getPointerArray = function (e) { var t = e - 1; return t <= Z8e ? Uint8Array : t <= eKe ? Uint16Array : t <= tKe ? Uint32Array : Float64Array }; _s.getSignedPointerArray = function (e) { var t = e - 1; return t <= rKe ? Int8Array : t <= oKe ? Int16Array : t <= nKe ? Int32Array : Float64Array }; _s.getNumberType = function (e) { return e === (e | 0) ? Math.sign(e) === -1 ? e <= 127 && e >= -128 ? Int8Array : e <= 32767 && e >= -32768 ? Int16Array : Int32Array : e <= 255 ? Uint8Array : e <= 65535 ? Uint16Array : Uint32Array : Float64Array }; var sKe = { Uint8Array: 1, Int8Array: 2, Uint16Array: 3, Int16Array: 4, Uint32Array: 5, Int32Array: 6, Float32Array: 7, Float64Array: 8 }; _s.getMinimalRepresentation = function (e, t) { var r = null, o = 0, n, i, a, c, p; for (c = 0, p = e.length; c < p; c++)a = t ? t(e[c]) : e[c], i = _s.getNumberType(a), n = sKe[i.name], n > o && (o = n, r = i); return r }; _s.isTypedArray = function (e) { return typeof ArrayBuffer < "u" && ArrayBuffer.isView(e) }; _s.concat = function () { var e = 0, t, r, o; for (t = 0, o = arguments.length; t < o; t++)e += arguments[t].length; var n = new arguments[0].constructor(e); for (t = 0, r = 0; t < o; t++)n.set(arguments[t], r), r += arguments[t].length; return n }; _s.indices = function (e) { for (var t = _s.getPointerArray(e), r = new t(e), o = 0; o < e; o++)r[o] = o; return r } }); var pz = Ip(hf => { var az = rO(), cz = oO(); function iKe(e) { return Array.isArray(e) || cz.isTypedArray(e) } function nO(e) { if (typeof e.length == "number") return e.length; if (typeof e.size == "number") return e.size } function aKe(e) { var t = nO(e), r = typeof t == "number" ? new Array(t) : [], o = 0; return az(e, function (n) { r[o++] = n }), r } function cKe(e) { var t = nO(e), r = typeof t == "number" ? cz.getPointerArray(t) : Array, o = typeof t == "number" ? new Array(t) : [], n = typeof t == "number" ? new r(t) : [], i = 0; return az(e, function (a) { o[i] = a, n[i] = i++ }), [o, n] } hf.isArrayLike = iKe; hf.guessLength = nO; hf.toArray = aKe; hf.toArrayWithIndices = cKe }); var mz = Ip((Bqt, uz) => { var sO = rz(), pKe = rO(), uKe = oO(), mKe = pz(); function Sr(e, t, r) { if (arguments.length < 2 && (r = e, e = null, t = null), this.capacity = r, typeof this.capacity != "number" || this.capacity <= 0) throw new Error("mnemonist/lru-cache: capacity should be positive number."); var o = uKe.getPointerArray(r); this.forward = new o(r), this.backward = new o(r), this.K = typeof e == "function" ? new e(r) : new Array(r), this.V = typeof t == "function" ? new t(r) : new Array(r), this.size = 0, this.head = 0, this.tail = 0, this.items = {} } Sr.prototype.clear = function () { this.size = 0, this.head = 0, this.tail = 0, this.items = {} }; Sr.prototype.splayOnTop = function (e) { var t = this.head; if (this.head === e) return this; var r = this.backward[e], o = this.forward[e]; return this.tail === e ? this.tail = r : this.backward[o] = r, this.forward[r] = o, this.backward[t] = e, this.head = e, this.forward[e] = t, this }; Sr.prototype.set = function (e, t) { var r = this.items[e]; if (typeof r < "u") { this.splayOnTop(r), this.V[r] = t; return } this.size < this.capacity ? r = this.size++ : (r = this.tail, this.tail = this.backward[r], delete this.items[this.K[r]]), this.items[e] = r, this.K[r] = e, this.V[r] = t, this.forward[r] = this.head, this.backward[this.head] = r, this.head = r }; Sr.prototype.setpop = function (e, t) { var r = null, o = null, n = this.items[e]; return typeof n < "u" ? (this.splayOnTop(n), r = this.V[n], this.V[n] = t, { evicted: !1, key: e, value: r }) : (this.size < this.capacity ? n = this.size++ : (n = this.tail, this.tail = this.backward[n], r = this.V[n], o = this.K[n], delete this.items[this.K[n]]), this.items[e] = n, this.K[n] = e, this.V[n] = t, this.forward[n] = this.head, this.backward[this.head] = n, this.head = n, o ? { evicted: !0, key: o, value: r } : null) }; Sr.prototype.has = function (e) { return e in this.items }; Sr.prototype.get = function (e) { var t = this.items[e]; if (!(typeof t > "u")) return this.splayOnTop(t), this.V[t] }; Sr.prototype.peek = function (e) { var t = this.items[e]; if (!(typeof t > "u")) return this.V[t] }; Sr.prototype.forEach = function (e, t) { t = arguments.length > 1 ? t : this; for (var r = 0, o = this.size, n = this.head, i = this.K, a = this.V, c = this.forward; r < o;)e.call(t, a[n], i[n], this), n = c[n], r++ }; Sr.prototype.keys = function () { var e = 0, t = this.size, r = this.head, o = this.K, n = this.forward; return new sO(function () { if (e >= t) return { done: !0 }; var i = o[r]; return e++, e < t && (r = n[r]), { done: !1, value: i } }) }; Sr.prototype.values = function () { var e = 0, t = this.size, r = this.head, o = this.V, n = this.forward; return new sO(function () { if (e >= t) return { done: !0 }; var i = o[r]; return e++, e < t && (r = n[r]), { done: !1, value: i } }) }; Sr.prototype.entries = function () { var e = 0, t = this.size, r = this.head, o = this.K, n = this.V, i = this.forward; return new sO(function () { if (e >= t) return { done: !0 }; var a = o[r], c = n[r]; return e++, e < t && (r = i[r]), { done: !1, value: [a, c] } }) }; typeof Symbol < "u" && (Sr.prototype[Symbol.iterator] = Sr.prototype.entries); Sr.prototype.inspect = function () { for (var e = new Map, t = this.entries(), r; r = t.next(), !r.done;)e.set(r.value[0], r.value[1]); return Object.defineProperty(e, "constructor", { value: Sr, enumerable: !1 }), e }; typeof Symbol < "u" && (Sr.prototype[Symbol.for("nodejs.util.inspect.custom")] = Sr.prototype.inspect); Sr.from = function (e, t, r, o) { if (arguments.length < 2) { if (o = mKe.guessLength(e), typeof o != "number") throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.") } else arguments.length === 2 && (o = t, t = null, r = null); var n = new Sr(t, r, o); return pKe(e, function (i, a) { n.set(a, i) }), n }; uz.exports = Sr }); var lz, eE, dz = s(() => { lz = E4(mz()), eE = class { cache; constructor(t) { this.cache = new lz.default(t) } getEndpoint(t) { let r = this.get(t); if (!r || r.length === 0) return; let o = r.map(n => n.Address); return o[Math.floor(Math.random() * o.length)] } get(t) { if (!this.has(t)) return; let r = this.cache.get(t); if (!r) return; let o = Date.now(), n = r.filter(i => o < i.Expires); if (n.length === 0) { this.delete(t); return } return n } set(t, r) { let o = Date.now(); this.cache.set(t, r.map(({ Address: n, CachePeriodInMinutes: i }) => ({ Address: n, Expires: o + i * 60 * 1e3 }))) } delete(t) { this.cache.set(t, []) } has(t) { if (!this.cache.has(t)) return !1; let r = this.cache.peek(t); return r ? r.length > 0 : !1 } clear() { this.cache.clear() } } }); var fz = s(() => { ez(); dz() }); var hz, gz = s(() => { fz(); hz = (e, { endpointDiscoveryCommandCtor: t }) => { let { endpointCacheSize: r, endpointDiscoveryEnabled: o, endpointDiscoveryEnabledProvider: n } = e; return Object.assign(e, { endpointDiscoveryCommandCtor: t, endpointCache: new eE(r ?? 1e3), endpointDiscoveryEnabled: o !== void 0 ? () => Promise.resolve(o) : n, isClientEndpointDiscoveryEnabled: o !== void 0 }) } }); var iO = s(() => { JV(); ZV(); gz() }); var tE, rE, xz = s(() => { tE = e => ({ setHttpHandler(t) { e.httpHandler = t }, httpHandler() { return e.httpHandler }, updateHttpClientConfig(t, r) { e.httpHandler?.updateHttpClientConfig(t, r) }, httpHandlerConfigs() { return e.httpHandler.httpHandlerConfigs() } }), rE = e => ({ httpHandler: e.httpHandler() }) }); var Ez = s(() => { xz() }); var yz = s(() => { }); var Sz, _z = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Sz || (Sz = {})) }); var Cz, Rz = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Cz || (Cz = {})) }); var Az = s(() => { }); var Tz = s(() => { }); var wz = s(() => { }); var bz = s(() => { }); var Iz = s(() => { _z(); Rz(); Az(); Tz(); wz(); bz() }); var vz = s(() => { }); var Pz = s(() => { }); var Oz = s(() => { }); var Dz = s(() => { }); var kz = s(() => { }); var Nz = s(() => { }); var Bz = s(() => { }); var Lz = s(() => { kz(); Nz(); Bz() }); var Mz = s(() => { }); var $z = s(() => { }); var Fz, Uz = s(() => { (function (e) { e.HTTP = "http", e.HTTPS = "https" })(Fz || (Fz = {})) }); var Hz = s(() => { }); var Gz = s(() => { }); var jz = s(() => { }); var qz = s(() => { }); var Vz = s(() => { }); var zz = s(() => { Hz(); Gz(); jz(); qz(); Vz() }); var Wz = s(() => { }); var Bp, Kz = s(() => { (function (e) { e.MD5 = "md5", e.CRC32 = "crc32", e.CRC32C = "crc32c", e.SHA1 = "sha1", e.SHA256 = "sha256" })(Bp || (Bp = {})) }); var Qz = s(() => { }); var Yz = s(() => { }); var Xz = s(() => { Qz(); Yz(); Kz() }); var Jz = s(() => { }); var Zz, eW = s(() => { (function (e) { e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER" })(Zz || (Zz = {})) }); var tW = s(() => { }); var rW = s(() => { }); var oW = s(() => { }); var nW = s(() => { }); var sW = s(() => { }); var iW = s(() => { rW(); oW(); nW(); sW() }); var aW = s(() => { }); var cW, pW = s(() => { cW = "__smithy_context" }); var uW = s(() => { }); var li, mW = s(() => { (function (e) { e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services" })(li || (li = {})) }); var lW = s(() => { }); var dW = s(() => { }); var fW = s(() => { }); var hW = s(() => { }); var gW = s(() => { }); var xW = s(() => { }); var EW = s(() => { }); var yW = s(() => { }); var SW = s(() => { }); var _W = s(() => { }); var CW = s(() => { }); var RW = s(() => { }); var AW = s(() => { }); var TW = s(() => { }); var wW, bW = s(() => { (function (e) { e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0" })(wW || (wW = {})) }); var IW = s(() => { }); var vW = s(() => { }); var PW = s(() => { }); var OW = s(() => { }); var DW = s(() => { }); var kW = s(() => { }); var NW = s(() => { }); var Lp = s(() => { yz(); Iz(); vz(); Pz(); Oz(); Dz(); Lz(); Mz(); $z(); Uz(); zz(); Wz(); Xz(); Jz(); eW(); tW(); iW(); aW(); pW(); uW(); mW(); lW(); dW(); fW(); hW(); gW(); xW(); EW(); yW(); SW(); _W(); CW(); RW(); AW(); TW(); bW(); IW(); vW(); PW(); OW(); DW(); kW(); NW() }); var BW = s(() => { }); var LW = s(() => { }); var MW = s(() => { }); function lKe(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var dn, $W = s(() => { dn = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = lKe(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var Mp, FW = s(() => { Mp = class { statusCode; reason; headers; body; constructor(t) { this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body } static isInstance(t) { if (!t) return !1; let r = t; return typeof r.statusCode == "number" && typeof r.headers == "object" } } }); var UW = s(() => { }); var HW = s(() => { }); var di = s(() => { Ez(); BW(); LW(); MW(); $W(); FW(); UW(); HW() }); var dKe, fKe, oE, aO = s(() => { di(); dKe = e => t => async r => { if (!dn.isInstance(r.request)) return t(r); let { request: o } = r, { handlerProtocol: n = "" } = e.requestHandler.metadata || {}; if (n.indexOf("h2") >= 0 && !o.headers[":authority"]) delete o.headers.host, o.headers[":authority"] = o.hostname + (o.port ? ":" + o.port : ""); else if (!o.headers.host) { let i = o.hostname; o.port != null && (i += `:${o.port}`), o.headers.host = i } return t(r) }, fKe = { name: "hostHeaderMiddleware", step: "build", priority: "low", tags: ["HOST"], override: !0 }, oE = e => ({ applyToStack: t => { t.add(dKe(e), fKe) } }) }); var hKe, gKe, nE, GW = s(() => { hKe = () => (e, t) => async r => { try { let o = await e(r), { clientName: n, commandName: i, logger: a, dynamoDbDocumentClientOptions: c = {} } = t, { overrideInputFilterSensitiveLog: p, overrideOutputFilterSensitiveLog: u } = c, l = p ?? t.inputFilterSensitiveLog, m = u ?? t.outputFilterSensitiveLog, { $metadata: f, ...h } = o.output; return a?.info?.({ clientName: n, commandName: i, input: l(r.input), output: m(h), metadata: f }), o } catch (o) { let { clientName: n, commandName: i, logger: a, dynamoDbDocumentClientOptions: c = {} } = t, { overrideInputFilterSensitiveLog: p } = c, u = p ?? t.inputFilterSensitiveLog; throw a?.error?.({ clientName: n, commandName: i, input: u(r.input), error: o, metadata: o.$metadata }), o } }, gKe = { name: "loggerMiddleware", tags: ["LOGGER"], step: "initialize", override: !0 }, nE = e => ({ applyToStack: t => { t.add(hKe(), gKe) } }) }); var cO = s(() => { GW() }); var jW, qW = s(() => { jW = { step: "build", tags: ["RECURSION_DETECTION"], name: "recursionDetectionMiddleware", override: !0, priority: "low" } }); var gf, pO, sE, uO, mO, Cs, xf = s(() => { gf = { REQUEST_ID: Symbol.for("_AWS_LAMBDA_REQUEST_ID"), X_RAY_TRACE_ID: Symbol.for("_AWS_LAMBDA_X_RAY_TRACE_ID"), TENANT_ID: Symbol.for("_AWS_LAMBDA_TENANT_ID") }, pO = ["true", "1"].includes(process.env?.AWS_LAMBDA_NODEJS_NO_GLOBAL_AWSLAMBDA ?? ""); pO || (globalThis.awslambda = globalThis.awslambda || {}); sE = class { static PROTECTED_KEYS = gf; isProtectedKey(t) { return Object.values(gf).includes(t) } getRequestId() { return this.get(gf.REQUEST_ID) ?? "-" } getXRayTraceId() { return this.get(gf.X_RAY_TRACE_ID) } getTenantId() { return this.get(gf.TENANT_ID) } }, uO = class extends sE { currentContext; getContext() { return this.currentContext } hasContext() { return this.currentContext !== void 0 } get(t) { return this.currentContext?.[t] } set(t, r) { if (this.isProtectedKey(t)) throw new Error(`Cannot modify protected Lambda context field: ${String(t)}`); this.currentContext = this.currentContext || {}, this.currentContext[t] = r } run(t, r) { return this.currentContext = t, r() } }, mO = class e extends sE { als; static async create() { let t = new e, r = await import("node:async_hooks"); return t.als = new r.AsyncLocalStorage, t } getContext() { return this.als.getStore() } hasContext() { return this.als.getStore() !== void 0 } get(t) { return this.als.getStore()?.[t] } set(t, r) { if (this.isProtectedKey(t)) throw new Error(`Cannot modify protected Lambda context field: ${String(t)}`); let o = this.als.getStore(); if (!o) throw new Error("No context available"); o[t] = r } run(t, r) { return this.als.run(t, r) } }; (function (e) { let t = null; async function r() { return t || (t = (async () => { let n = "AWS_LAMBDA_MAX_CONCURRENCY" in process.env ? await mO.create() : new uO; return !pO && globalThis.awslambda?.InvokeStore ? globalThis.awslambda.InvokeStore : (!pO && globalThis.awslambda && (globalThis.awslambda.InvokeStore = n), n) })()), t } e.getInstanceAsync = r, e._testing = process.env.AWS_LAMBDA_BENCHMARK_MODE === "1" ? { reset: () => { t = null, globalThis.awslambda?.InvokeStore && delete globalThis.awslambda.InvokeStore, globalThis.awslambda = {} } } : void 0 })(Cs || (Cs = {})) }); var lO, xKe, EKe, VW, dO = s(() => { xf(); di(); lO = "X-Amzn-Trace-Id", xKe = "AWS_LAMBDA_FUNCTION_NAME", EKe = "_X_AMZN_TRACE_ID", VW = () => e => async t => { let { request: r } = t; if (!dn.isInstance(r)) return e(t); let o = Object.keys(r.headers ?? {}).find(l => l.toLowerCase() === lO.toLowerCase()) ?? lO; if (r.headers.hasOwnProperty(o)) return e(t); let n = process.env[xKe], i = process.env[EKe], p = (await Cs.getInstanceAsync())?.getXRayTraceId() ?? i, u = l => typeof l == "string" && l.length > 0; return u(n) && u(p) && (r.headers[lO] = p), e({ ...t, request: r }) } }); var iE, zW = s(() => { qW(); dO(); iE = e => ({ applyToStack: t => { t.add(VW(), jW) } }) }); var fO = s(() => { zW(); dO() }); var WW = s(() => { }); var KW, QW = s(() => { KW = (e, t) => { if (!t || t.length === 0) return e; let r = []; for (let o of t) for (let n of e) n.schemeId.split("#")[1] === o && r.push(n); for (let o of e) r.find(({ schemeId: n }) => n === o.schemeId) || r.push(o); return r } }); function yKe(e) { let t = new Map; for (let r of e) t.set(r.schemeId, r); return t } var YW, hO = s(() => {
  gt(); QW(); YW = (e, t) => (r, o) => async n => {
    let i = e.httpAuthSchemeProvider(await t.httpAuthSchemeParametersProvider(e, o, n.input)), a = e.authSchemePreference ? await e.authSchemePreference() : [], c = KW(i, a), p = yKe(e.httpAuthSchemes), u = je(o), l = []; for (let m of c) { let f = p.get(m.schemeId); if (!f) { l.push(`HttpAuthScheme \`${m.schemeId}\` was not enabled for this service.`); continue } let h = f.identityProvider(await t.identityProviderConfigProvider(e)); if (!h) { l.push(`HttpAuthScheme \`${m.schemeId}\` did not have an IdentityProvider configured.`); continue } let { identityProperties: E = {}, signingProperties: S = {} } = m.propertiesExtractor?.(e, o) || {}; m.identityProperties = Object.assign(m.identityProperties || {}, E), m.signingProperties = Object.assign(m.signingProperties || {}, S), u.selectedHttpAuthScheme = { httpAuthOption: m, identity: await h(m.identityProperties), signer: f.signer }; break } if (!u.selectedHttpAuthScheme) throw new Error(l.join(`
`)); return r(n)
  }
}); var SKe, Mr, XW = s(() => { hO(); SKe = { step: "serialize", tags: ["HTTP_AUTH_SCHEME"], name: "httpAuthSchemeMiddleware", override: !0, relation: "before", toMiddleware: "endpointV2Middleware" }, Mr = (e, { httpAuthSchemeParametersProvider: t, identityProviderConfigProvider: r }) => ({ applyToStack: o => { o.addRelativeTo(YW(e, { httpAuthSchemeParametersProvider: t, identityProviderConfigProvider: r }), SKe) } }) }); var JW = s(() => { }); var ZW = s(() => { JW() }); var e6 = s(() => { }); var t6 = s(() => { }); var r6 = s(() => { }); function _Ke(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var Rs, o6 = s(() => { Rs = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = _Ke(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var $p, n6 = s(() => { $p = class { statusCode; reason; headers; body; constructor(t) { this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body } static isInstance(t) { if (!t) return !1; let r = t; return typeof r.statusCode == "number" && typeof r.headers == "object" } } }); var s6 = s(() => { }); var i6 = s(() => { }); var Fp = s(() => { ZW(); e6(); t6(); r6(); o6(); n6(); s6(); i6() }); var a6 = s(() => { }); var c6 = s(() => { }); var p6, u6 = s(() => { p6 = { name: "serializerMiddleware", step: "serialize", tags: ["SERIALIZER"], override: !0 } }); var m6 = s(() => { a6(); u6(); c6() }); var TWt, l6 = s(() => { m6(); TWt = { step: "serialize", tags: ["HTTP_AUTH_SCHEME"], name: "httpAuthSchemeMiddleware", override: !0, relation: "before", toMiddleware: p6.name } }); var d6 = s(() => { hO(); XW(); l6() }); var CKe, RKe, f6, gO = s(() => { Fp(); gt(); CKe = e => t => { throw t }, RKe = (e, t) => { }, f6 = e => (t, r) => async o => { if (!Rs.isInstance(o.request)) return t(o); let i = je(r).selectedHttpAuthScheme; if (!i) throw new Error("No HttpAuthScheme was selected: unable to sign request"); let { httpAuthOption: { signingProperties: a = {} }, identity: c, signer: p } = i, u = await t({ ...o, request: await p.sign(o.request, c, a) }).catch((p.errorHandler || CKe)(a)); return (p.successHandler || RKe)(u.response, a), u } }); var xO, $r, h6 = s(() => { gO(); xO = { step: "finalizeRequest", tags: ["HTTP_SIGNING"], name: "httpSigningMiddleware", aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"], override: !0, relation: "after", toMiddleware: "retryMiddleware" }, $r = e => ({ applyToStack: t => { t.addRelativeTo(f6(e), xO) } }) }); var g6 = s(() => { gO(); h6() }); var yo, x6 = s(() => { yo = e => { if (typeof e == "function") return e; let t = Promise.resolve(e); return () => t } }); function qe(e, t, r, o, n) { return async function* (a, c, ...p) { let u = c, l = a.startingToken ?? u[r], m = !0, f; for (; m;) { if (u[r] = l, n && (u[n] = u[n] ?? a.pageSize), a.client instanceof e) f = await AKe(t, a.client, c, a.withCommand, ...p); else throw new Error(`Invalid client, expected instance of ${e.name}`); yield f; let h = l; l = TKe(f, o), m = !!(l && (!a.stopOnSameToken || l !== h)) } return void 0 } } var AKe, TKe, E6 = s(() => { AKe = async (e, t, r, o = i => i, ...n) => { let i = new e(r); return i = o(i) ?? i, await t.send(i, ...n) }; TKe = (e, t) => { let r = e, o = t.split("."); for (let n of o) { if (!r || typeof r != "object") return; r = r[n] } return r } }); var Le, cr = s(() => { Le = e => typeof ArrayBuffer == "function" && e instanceof ArrayBuffer || Object.prototype.toString.call(e) === "[object ArrayBuffer]" }); import { Buffer as EO } from "buffer"; var Up, aE, Hp = s(() => { cr(); Up = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return EO.from(e, t, r) }, aE = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? EO.from(e, t) : EO.from(e) } }); var wKe, lc, y6 = s(() => { Hp(); wKe = /^[A-Za-z0-9+/]*={0,2}$/, lc = e => { if (e.length * 3 % 4 !== 0) throw new TypeError("Incorrect padding on base64 string."); if (!wKe.exec(e)) throw new TypeError("Invalid base64 string."); let t = aE(e, "base64"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength) } }); var Ji, S6 = s(() => { Hp(); Ji = e => { let t = aE(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var _6 = s(() => { }); var As, C6 = s(() => { Hp(); As = e => { if (typeof e == "string") return e; if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number") throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."); return Up(e.buffer, e.byteOffset, e.byteLength).toString("utf8") } }); var dc = s(() => { S6(); _6(); C6() }); var fc, R6 = s(() => { Hp(); dc(); fc = e => { let t; if (typeof e == "string" ? t = Ji(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return Up(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var Gp = s(() => { y6(); R6() }); var jp, A6 = s(() => { Gp(); dc(); jp = class e extends Uint8Array { static fromString(t, r = "utf-8") { if (typeof t == "string") return r === "base64" ? e.mutate(lc(t)) : e.mutate(Ji(t)); throw new Error(`Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`) } static mutate(t) { return Object.setPrototypeOf(t, e.prototype), t } transformToString(t = "utf-8") { return t === "base64" ? fc(this) : As(this) } } }); var T6 = s(() => { }); var yO, SO = s(() => { yO = e => typeof ReadableStream == "function" && (e?.constructor?.name === ReadableStream.name || e instanceof ReadableStream) }); var w6 = s(() => { }); var b6 = s(() => { }); var I6 = s(() => { }); var v6 = s(() => { }); var P6 = s(() => { }); var O6 = s(() => { }); import { Writable as bKe } from "stream"; var cE, D6 = s(() => { cE = class extends bKe { bufferedBytes = []; _write(t, r, o) { this.bufferedBytes.push(t), o() } } }); async function vKe(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } var k6, IKe, N6 = s(() => { D6(); k6 = e => IKe(e) ? vKe(e) : new Promise((t, r) => { let o = new cE; e.pipe(o), e.on("error", n => { o.end(), r(n) }), o.on("error", r), o.on("finish", function () { let n = new Uint8Array(Buffer.concat(this.bufferedBytes)); t(n) }) }), IKe = e => typeof ReadableStream == "function" && e instanceof ReadableStream }); var B6 = s(() => { P6(); O6(); N6() }); var L6 = s(() => { }); async function PKe(e) { let t = await DKe(e), r = lc(t); return new Uint8Array(r) } async function OKe(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } function DKe(e) { return new Promise((t, r) => { let o = new FileReader; o.onloadend = () => { if (o.readyState !== 2) return r(new Error("Reader aborted too early")); let n = o.result ?? "", i = n.indexOf(","), a = i > -1 ? i + 1 : n.length; t(n.substring(a)) }, o.onabort = () => r(new Error("Read aborted")), o.onerror = () => r(o.error), o.readAsDataURL(e) }) } var M6, $6 = s(() => { Gp(); M6 = async e => typeof Blob == "function" && e instanceof Blob || e.constructor?.name === "Blob" ? Blob.prototype.arrayBuffer !== void 0 ? new Uint8Array(await e.arrayBuffer()) : PKe(e) : OKe(e) }); var F6 = s(() => { L6(); $6() }); function pE(e) { if (e.length % 2 !== 0) throw new Error("Hex encoded strings must have an even number length"); let t = new Uint8Array(e.length / 2); for (let r = 0; r < e.length; r += 2) { let o = e.slice(r, r + 2).toLowerCase(); if (o in _O) t[r / 2] = _O[o]; else throw new Error(`Cannot decode unrecognized sequence ${o} as hexadecimal`) } return t } function it(e) { let t = ""; for (let r = 0; r < e.byteLength; r++)t += U6[e[r]]; return t } var U6, _O, Oo = s(() => { U6 = {}, _O = {}; for (let e = 0; e < 256; e++) { let t = e.toString(16).toLowerCase(); t.length === 1 && (t = `0${t}`), U6[e] = t, _O[t] = e } }); var H6, j6, G6, q6 = s(() => {
  F6(); Gp(); Oo(); dc(); SO(); H6 = "The stream has already been transformed.", j6 = e => {
    if (!G6(e) && !yO(e)) { let n = e?.__proto__?.constructor?.name || e; throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${n}`) } let t = !1, r = async () => { if (t) throw new Error(H6); return t = !0, await M6(e) }, o = n => {
      if (typeof n.stream != "function") throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`); return n.stream()
    }; return Object.assign(e, { transformToByteArray: r, transformToString: async n => { let i = await r(); if (n === "base64") return fc(i); if (n === "hex") return it(i); if (n === void 0 || n === "utf8" || n === "utf-8") return As(i); if (typeof TextDecoder == "function") return new TextDecoder(n).decode(i); throw new Error("TextDecoder is not available, please make sure polyfill is provided.") }, transformToWebStream: () => { if (t) throw new Error(H6); if (t = !0, G6(e)) return o(e); if (yO(e)) return e; throw new Error(`Cannot transform payload to web stream, got ${e}`) } })
  }, G6 = e => typeof Blob == "function" && e instanceof Blob
}); import { Readable as CO } from "stream"; var V6, z6, W6 = s(() => { B6(); Hp(); q6(); V6 = "The stream has already been transformed.", z6 = e => { if (!(e instanceof CO)) try { return j6(e) } catch { let n = e?.__proto__?.constructor?.name || e; throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${n}`) } let t = !1, r = async () => { if (t) throw new Error(V6); return t = !0, await k6(e) }; return Object.assign(e, { transformToByteArray: r, transformToString: async o => { let n = await r(); return o === void 0 || Buffer.isEncoding(o) ? Up(n.buffer, n.byteOffset, n.byteLength).toString(o) : new TextDecoder(o).decode(n) }, transformToWebStream: () => { if (t) throw new Error(V6); if (e.readableFlowing !== null) throw new Error("The stream has been consumed by other callbacks."); if (typeof CO.toWeb != "function") throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available."); return t = !0, CO.toWeb(e) } }) } }); var K6 = s(() => { }); var RO = s(() => { A6(); T6(); w6(); b6(); I6(); v6(); W6(); K6(); SO() }); var Do, uE = s(() => { RO(); Do = async (e = new Uint8Array, t) => { if (e instanceof Uint8Array) return jp.mutate(e); if (!e) return jp.mutate(new Uint8Array); let r = t.streamCollector(e); return jp.mutate(await r) } }); function qp(e) { return encodeURIComponent(e).replace(/[!'()*]/g, function (t) { return "%" + t.charCodeAt(0).toString(16).toUpperCase() }) } var AO = s(() => { }); var Zi, TO = s(() => { Zi = e => typeof e == "function" ? e() : e }); var mE, lE = s(() => { mE = (e, t, r, o, n) => ({ name: t, namespace: e, traits: r, input: o, output: n }) }); var Q6, wO, Y6 = s(() => {
  Fp(); gt(); lE(); Q6 = e => (t, r) => async o => {
    let { response: n } = await t(o), { operationSchema: i } = je(r), [, a, c, p, u, l] = i ?? []; try { let m = await e.protocol.deserializeResponse(mE(a, c, p, u, l), { ...e, ...r }, n); return { response: n, output: m } } catch (m) {
      if (Object.defineProperty(m, "$response", { value: n, enumerable: !1, writable: !1, configurable: !1 }), !("$metadata" in m)) {
        let f = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object."; try {
          m.message += `
  `+ f
        } catch { !r.logger || r.logger?.constructor?.name === "NoOpLogger" ? console.warn(f) : r.logger?.warn?.(f) } typeof m.$responseBodyText < "u" && m.$response && (m.$response.body = m.$responseBodyText); try { if ($p.isInstance(n)) { let { headers: h = {} } = n, E = Object.entries(h); m.$metadata = { httpStatusCode: n.statusCode, requestId: wO(/^x-[\w-]+-request-?id$/, E), extendedRequestId: wO(/^x-[\w-]+-id-2$/, E), cfId: wO(/^x-[\w-]+-cf-id$/, E) } } } catch { }
      } throw m
    }
  }, wO = (e, t) => (t.find(([r]) => r.match(e)) || [void 0, void 0])[1]
}); var X6, J6 = s(() => { gt(); lE(); X6 = e => (t, r) => async o => { let { operationSchema: n } = je(r), [, i, a, c, p, u] = n ?? [], l = r.endpointV2?.url && e.urlParser ? async () => e.urlParser(r.endpointV2.url) : e.endpoint, m = await e.protocol.serializeRequest(mE(i, a, c, p, u), o.input, { ...e, ...r, endpoint: l }); return t({ ...o, request: m }) } }); function Fr(e) { return { applyToStack: t => { t.add(X6(e), NKe), t.add(Q6(e), kKe), e.protocol.setSerdeContext(e) } } } var kKe, NKe, Z6 = s(() => { Y6(); J6(); kKe = { name: "deserializerMiddleware", step: "deserialize", tags: ["DESERIALIZER"], override: !0 }, NKe = { name: "serializerMiddleware", step: "serialize", tags: ["SERIALIZER"], override: !0 } }); var fn, hc = s(() => { fn = class { name; namespace; traits; static assign(t, r) { return Object.assign(t, r) } static [Symbol.hasInstance](t) { let r = this.prototype.isPrototypeOf(t); return !r && typeof t == "object" && t !== null ? t.symbol === this.symbol : r } getName() { return this.namespace + "#" + this.name } } }); var e8, t8 = s(() => { hc(); e8 = class e extends fn { static symbol = Symbol.for("@smithy/lis"); name; traits; valueSchema; symbol = e.symbol } }); var r8, o8 = s(() => { hc(); r8 = class e extends fn { static symbol = Symbol.for("@smithy/map"); name; traits; keySchema; valueSchema; symbol = e.symbol } }); var n8, s8 = s(() => { hc(); n8 = class e extends fn { static symbol = Symbol.for("@smithy/ope"); name; traits; input; output; symbol = e.symbol } }); var dE, bO = s(() => { hc(); dE = class e extends fn { static symbol = Symbol.for("@smithy/str"); name; traits; memberNames; memberList; symbol = e.symbol } }); var i8, a8 = s(() => { bO(); i8 = class e extends dE { static symbol = Symbol.for("@smithy/err"); ctor; symbol = e.symbol } }); function fi(e) { if (typeof e == "object") return e; e = e | 0; let t = {}, r = 0; for (let o of ["httpLabel", "idempotent", "idempotencyToken", "sensitive", "httpPayload", "httpResponseCode", "httpQueryParams"]) (e >> r++ & 1) === 1 && (t[o] = 1); return t } var IO = s(() => { }); function Ef(e, t) { if (e instanceof ue) return Object.assign(e, { memberName: t, _isMemberSchema: !0 }); let r = ue; return new r(e, t) } var ue, vO, BKe, c8 = s(() => { TO(); IO(); ue = class e { ref; memberName; static symbol = Symbol.for("@smithy/nor"); symbol = e.symbol; name; schema; _isMemberSchema; traits; memberTraits; normalizedTraits; constructor(t, r) { this.ref = t, this.memberName = r; let o = [], n = t, i = t; for (this._isMemberSchema = !1; vO(n);)o.push(n[1]), n = n[0], i = Zi(n), this._isMemberSchema = !0; if (o.length > 0) { this.memberTraits = {}; for (let a = o.length - 1; a >= 0; --a) { let c = o[a]; Object.assign(this.memberTraits, fi(c)) } } else this.memberTraits = 0; if (i instanceof e) { let a = this.memberTraits; Object.assign(this, i), this.memberTraits = Object.assign({}, a, i.getMemberTraits(), this.getMemberTraits()), this.normalizedTraits = void 0, this.memberName = r ?? i.memberName; return } if (this.schema = Zi(i), BKe(this.schema) ? (this.name = `${this.schema[1]}#${this.schema[2]}`, this.traits = this.schema[3]) : (this.name = this.memberName ?? String(i), this.traits = 0), this._isMemberSchema && !r) throw new Error(`@smithy/core/schema - NormalizedSchema member init ${this.getName(!0)} missing member name.`) } static [Symbol.hasInstance](t) { let r = this.prototype.isPrototypeOf(t); return !r && typeof t == "object" && t !== null ? t.symbol === this.symbol : r } static of(t) { let r = Zi(t); if (r instanceof e) return r; if (vO(r)) { let [o, n] = r; if (o instanceof e) return Object.assign(o.getMergedTraits(), fi(n)), o; throw new Error(`@smithy/core/schema - may not init unwrapped member schema=${JSON.stringify(t, null, 2)}.`) } return new e(r) } getSchema() { let t = this.schema; return t[0] === 0 ? t[4] : t } getName(t = !1) { let { name: r } = this; return !t && r && r.includes("#") ? r.split("#")[1] : r || void 0 } getMemberName() { return this.memberName } isMemberSchema() { return this._isMemberSchema } isListSchema() { let t = this.getSchema(); return typeof t == "number" ? t >= 64 && t < 128 : t[0] === 1 } isMapSchema() { let t = this.getSchema(); return typeof t == "number" ? t >= 128 && t <= 255 : t[0] === 2 } isStructSchema() { let r = this.getSchema()[0]; return r === 3 || r === -3 || r === 4 } isUnionSchema() { return this.getSchema()[0] === 4 } isBlobSchema() { let t = this.getSchema(); return t === 21 || t === 42 } isTimestampSchema() { let t = this.getSchema(); return typeof t == "number" && t >= 4 && t <= 7 } isUnitSchema() { return this.getSchema() === "unit" } isDocumentSchema() { return this.getSchema() === 15 } isStringSchema() { return this.getSchema() === 0 } isBooleanSchema() { return this.getSchema() === 2 } isNumericSchema() { return this.getSchema() === 1 } isBigIntegerSchema() { return this.getSchema() === 17 } isBigDecimalSchema() { return this.getSchema() === 19 } isStreaming() { let { streaming: t } = this.getMergedTraits(); return !!t || this.getSchema() === 42 } isIdempotencyToken() { let t = i => (i & 4) === 4 || !!i?.idempotencyToken, { normalizedTraits: r, traits: o, memberTraits: n } = this; return t(r) || t(o) || t(n) } getMergedTraits() { return this.normalizedTraits ?? (this.normalizedTraits = { ...this.getOwnTraits(), ...this.getMemberTraits() }) } getMemberTraits() { return fi(this.memberTraits) } getOwnTraits() { return fi(this.traits) } getKeySchema() { let [t, r] = [this.isDocumentSchema(), this.isMapSchema()]; if (!t && !r) throw new Error(`@smithy/core/schema - cannot get key for non-map: ${this.getName(!0)}`); let o = this.getSchema(), n = t ? 15 : o[4] ?? 0; return Ef([n, 0], "key") } getValueSchema() { let t = this.getSchema(), [r, o, n] = [this.isDocumentSchema(), this.isMapSchema(), this.isListSchema()], i = typeof t == "number" ? 63 & t : t && typeof t == "object" && (o || n) ? t[3 + t[0]] : r ? 15 : void 0; if (i != null) return Ef([i, 0], o ? "value" : "member"); throw new Error(`@smithy/core/schema - ${this.getName(!0)} has no value member.`) } getMemberSchema(t) { let r = this.getSchema(); if (this.isStructSchema() && r[4].includes(t)) { let o = r[4].indexOf(t), n = r[5][o]; return Ef(vO(n) ? n : [n, 0], t) } if (this.isDocumentSchema()) return Ef([15, 0], t); throw new Error(`@smithy/core/schema - ${this.getName(!0)} has no no member=${t}.`) } getMemberSchemas() { let t = {}; try { for (let [r, o] of this.structIterator()) t[r] = o } catch { } return t } getEventStreamMember() { if (this.isStructSchema()) { for (let [t, r] of this.structIterator()) if (r.isStreaming() && r.isStructSchema()) return t } return "" } *structIterator() { if (this.isUnitSchema()) return; if (!this.isStructSchema()) throw new Error("@smithy/core/schema - cannot iterate non-struct schema."); let t = this.getSchema(); for (let r = 0; r < t[4].length; ++r)yield [t[4][r], Ef([t[5][r], 0], t[4][r])] } }; vO = e => Array.isArray(e) && e.length === 2, BKe = e => Array.isArray(e) && e.length >= 5 }); var p8, u8 = s(() => { hc(); p8 = class e extends fn { static symbol = Symbol.for("@smithy/sim"); name; schemaRef; traits; symbol = e.symbol } }); var m8 = s(() => { }); var k, l8 = s(() => { k = class e { namespace; schemas; exceptions; static registries = new Map; constructor(t, r = new Map, o = new Map) { this.namespace = t, this.schemas = r, this.exceptions = o } static for(t) { return e.registries.has(t) || e.registries.set(t, new e(t)), e.registries.get(t) } register(t, r) { let o = this.normalizeShapeId(t); e.for(o.split("#")[0]).schemas.set(o, r) } getSchema(t) { let r = this.normalizeShapeId(t); if (!this.schemas.has(r)) throw new Error(`@smithy/core/schema - schema not found for ${r}`); return this.schemas.get(r) } registerError(t, r) { let o = t, n = e.for(o[1]); n.schemas.set(o[1] + "#" + o[2], o), n.exceptions.set(o, r) } getErrorCtor(t) { let r = t; return e.for(r[1]).exceptions.get(r) } getBaseException() { for (let t of this.exceptions.keys()) if (Array.isArray(t)) { let [, r, o] = t, n = r + "#" + o; if (n.startsWith("smithy.ts.sdk.synthetic.") && n.endsWith("ServiceException")) return t } } find(t) { return [...this.schemas.values()].find(t) } clear() { this.schemas.clear(), this.exceptions.clear() } normalizeShapeId(t) { return t.includes("#") ? t : this.namespace + "#" + t } } }); var Oe = s(() => { TO(); Z6(); t8(); o8(); s8(); lE(); a8(); c8(); hc(); u8(); bO(); m8(); IO(); l8() }); var d8 = s(() => { }); var PO, LKe, f8, MKe, h8, g8, x8, $Ke, E8, y8, FKe, fE, Vp, S8, UKe, HKe, OO = s(() => {
  PO = e => { if (e != null) { if (typeof e == "string") { let t = parseFloat(e); if (!Number.isNaN(t)) return String(t) !== String(e) && HKe.warn(UKe(`Expected number but observed string: ${e}`)), t } if (typeof e == "number") return e; throw new TypeError(`Expected number, got ${typeof e}: ${e}`) } }, LKe = Math.ceil(34028234663852886e22), f8 = e => { let t = PO(e); if (t !== void 0 && !Number.isNaN(t) && t !== 1 / 0 && t !== -1 / 0 && Math.abs(t) > LKe) throw new TypeError(`Expected 32-bit float, got ${e}`); return t }, MKe = e => { if (e != null) { if (Number.isInteger(e) && !Number.isNaN(e)) return e; throw new TypeError(`Expected integer, got ${typeof e}: ${e}`) } }, h8 = e => x8(e, 16), g8 = e => x8(e, 8), x8 = (e, t) => { let r = MKe(e); if (r !== void 0 && $Ke(r, t) !== r) throw new TypeError(`Expected ${t}-bit integer, got ${e}`); return r }, $Ke = (e, t) => { switch (t) { case 32: return Int32Array.of(e)[0]; case 16: return Int16Array.of(e)[0]; case 8: return Int8Array.of(e)[0] } }, E8 = e => PO(typeof e == "string" ? fE(e) : e), y8 = e => f8(typeof e == "string" ? fE(e) : e), FKe = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g, fE = e => { let t = e.match(FKe); if (t === null || t[0].length !== e.length) throw new TypeError("Expected real number, got implicit NaN"); return parseFloat(e) }, Vp = e => h8(typeof e == "string" ? fE(e) : e), S8 = e => g8(typeof e == "string" ? fE(e) : e), UKe = e => String(new TypeError(e).stack || e).split(`
`).slice(0, 5).filter(t => !t.includes("stackTraceWarning")).join(`
`), HKe = { warn: console.warn }
}); function hi(e) { let t = e.getUTCFullYear(), r = e.getUTCMonth(), o = e.getUTCDay(), n = e.getUTCDate(), i = e.getUTCHours(), a = e.getUTCMinutes(), c = e.getUTCSeconds(), p = n < 10 ? `0${n}` : `${n}`, u = i < 10 ? `0${i}` : `${i}`, l = a < 10 ? `0${a}` : `${a}`, m = c < 10 ? `0${c}` : `${c}`; return `${GKe[o]}, ${p} ${kO[r]} ${t} ${u}:${l}:${m} GMT` } var GKe, kO, jKe, _8, qKe, C8, VKe, zKe, WKe, hE, R8, yf, KKe, QKe, YKe, DO, XKe, JKe, ZKe, Ts, e5e, t5e, zp, A8 = s(() => { OO(); GKe = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], kO = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; jKe = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/), _8 = e => { if (e == null) return; if (typeof e != "string") throw new TypeError("RFC-3339 date-times must be expressed as strings"); let t = jKe.exec(e); if (!t) throw new TypeError("Invalid RFC-3339 date-time value"); let [r, o, n, i, a, c, p, u] = t, l = Vp(zp(o)), m = Ts(n, "month", 1, 12), f = Ts(i, "day", 1, 31); return yf(l, m, f, { hours: a, minutes: c, seconds: p, fractionalMilliseconds: u }) }, qKe = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/), C8 = e => { if (e == null) return; if (typeof e != "string") throw new TypeError("RFC-3339 date-times must be expressed as strings"); let t = qKe.exec(e); if (!t) throw new TypeError("Invalid RFC-3339 date-time value"); let [r, o, n, i, a, c, p, u, l] = t, m = Vp(zp(o)), f = Ts(n, "month", 1, 12), h = Ts(i, "day", 1, 31), E = yf(m, f, h, { hours: a, minutes: c, seconds: p, fractionalMilliseconds: u }); return l.toUpperCase() != "Z" && E.setTime(E.getTime() - t5e(l)), E }, VKe = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/), zKe = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/), WKe = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/), hE = e => { if (e == null) return; if (typeof e != "string") throw new TypeError("RFC-7231 date-times must be expressed as strings"); let t = VKe.exec(e); if (t) { let [r, o, n, i, a, c, p, u] = t; return yf(Vp(zp(i)), DO(n), Ts(o, "day", 1, 31), { hours: a, minutes: c, seconds: p, fractionalMilliseconds: u }) } if (t = zKe.exec(e), t) { let [r, o, n, i, a, c, p, u] = t; return YKe(yf(KKe(i), DO(n), Ts(o, "day", 1, 31), { hours: a, minutes: c, seconds: p, fractionalMilliseconds: u })) } if (t = WKe.exec(e), t) { let [r, o, n, i, a, c, p, u] = t; return yf(Vp(zp(u)), DO(o), Ts(n.trimLeft(), "day", 1, 31), { hours: i, minutes: a, seconds: c, fractionalMilliseconds: p }) } throw new TypeError("Invalid RFC-7231 date-time value") }, R8 = e => { if (e == null) return; let t; if (typeof e == "number") t = e; else if (typeof e == "string") t = E8(e); else if (typeof e == "object" && e.tag === 1) t = e.value; else throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation"); if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0) throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics"); return new Date(Math.round(t * 1e3)) }, yf = (e, t, r, o) => { let n = t - 1; return JKe(e, n, r), new Date(Date.UTC(e, n, r, Ts(o.hours, "hour", 0, 23), Ts(o.minutes, "minute", 0, 59), Ts(o.seconds, "seconds", 0, 60), e5e(o.fractionalMilliseconds))) }, KKe = e => { let t = new Date().getUTCFullYear(), r = Math.floor(t / 100) * 100 + Vp(zp(e)); return r < t ? r + 100 : r }, QKe = 50 * 365 * 24 * 60 * 60 * 1e3, YKe = e => e.getTime() - new Date().getTime() > QKe ? new Date(Date.UTC(e.getUTCFullYear() - 100, e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds())) : e, DO = e => { let t = kO.indexOf(e); if (t < 0) throw new TypeError(`Invalid month: ${e}`); return t + 1 }, XKe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], JKe = (e, t, r) => { let o = XKe[t]; if (t === 1 && ZKe(e) && (o = 29), r > o) throw new TypeError(`Invalid day for ${kO[t]} in ${e}: ${r}`) }, ZKe = e => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), Ts = (e, t, r, o) => { let n = S8(zp(e)); if (n < r || n > o) throw new TypeError(`${t} must be between ${r} and ${o}, inclusive`); return n }, e5e = e => e == null ? 0 : y8("0." + e) * 1e3, t5e = e => { let t = e[0], r = 1; if (t == "+") r = 1; else if (t == "-") r = -1; else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`); let o = Number(e.substring(1, 3)), n = Number(e.substring(4, 6)); return r * (o * 60 + n) * 60 * 1e3 }, zp = e => { let t = 0; for (; t < e.length - 1 && e.charAt(t) === "0";)t++; return t === 0 ? e : e.slice(t) } }); import T8 from "crypto"; var NO, w8 = s(() => { NO = T8.randomUUID.bind(T8) }); var co, ro, b8 = s(() => { w8(); co = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0")), ro = () => { if (NO) return NO(); let e = new Uint8Array(16); return crypto.getRandomValues(e), e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128, co[e[0]] + co[e[1]] + co[e[2]] + co[e[3]] + "-" + co[e[4]] + co[e[5]] + "-" + co[e[6]] + co[e[7]] + "-" + co[e[8]] + co[e[9]] + "-" + co[e[10]] + co[e[11]] + co[e[12]] + co[e[13]] + co[e[14]] + co[e[15]] } }); var Wp = s(() => { b8() }); var I8 = s(() => { Wp() }); var ko, v8 = s(() => { ko = function (t) { return Object.assign(new String(t), { deserializeJSON() { return JSON.parse(String(t)) }, toString() { return String(t) }, toJSON() { return String(t) } }) }; ko.from = e => e && typeof e == "object" && (e instanceof ko || "deserializeJSON" in e) ? e : typeof e == "string" || Object.getPrototypeOf(e) === String.prototype ? ko(String(e)) : ko(JSON.stringify(e)); ko.fromObject = ko.from }); function P8(e) { return (e.includes(",") || e.includes('"')) && (e = `"${e.replace(/"/g, '\\"')}"`), e } var O8 = s(() => { }); function gi(e, t, r) { let o = Number(e); if (o < t || o > r) throw new Error(`Value ${o} out of range [${t}, ${r}]`) } var BO, LO, MO, D8, k8, r5e, o5e, n5e, s5e, i5e, N8, B8, L8, M8 = s(() => { BO = "(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)(?:[ne|u?r]?s?day)?", LO = "(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)", MO = "(\\d?\\d):(\\d{2}):(\\d{2})(?:\\.(\\d+))?", D8 = "(\\d?\\d)", k8 = "(\\d{4})", r5e = new RegExp(/^(\d{4})-(\d\d)-(\d\d)[tT](\d\d):(\d\d):(\d\d)(\.(\d+))?(([-+]\d\d:\d\d)|[zZ])$/), o5e = new RegExp(`^${BO}, ${D8} ${LO} ${k8} ${MO} GMT$`), n5e = new RegExp(`^${BO}, ${D8}-${LO}-(\\d\\d) ${MO} GMT$`), s5e = new RegExp(`^${BO} ${LO} ( [1-9]|\\d\\d) ${MO} ${k8}$`), i5e = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], N8 = e => { if (e == null) return; let t = NaN; if (typeof e == "number") t = e; else if (typeof e == "string") { if (!/^-?\d*\.?\d+$/.test(e)) throw new TypeError("parseEpochTimestamp - numeric string invalid."); t = Number.parseFloat(e) } else typeof e == "object" && e.tag === 1 && (t = e.value); if (isNaN(t) || Math.abs(t) === 1 / 0) throw new TypeError("Epoch timestamps must be valid finite numbers."); return new Date(Math.round(t * 1e3)) }, B8 = e => { if (e == null) return; if (typeof e != "string") throw new TypeError("RFC3339 timestamps must be strings"); let t = r5e.exec(e); if (!t) throw new TypeError(`Invalid RFC3339 timestamp format ${e}`); let [, r, o, n, i, a, c, , p, u] = t; gi(o, 1, 12), gi(n, 1, 31), gi(i, 0, 23), gi(a, 0, 59), gi(c, 0, 60); let l = new Date(Date.UTC(Number(r), Number(o) - 1, Number(n), Number(i), Number(a), Number(c), Number(p) ? Math.round(parseFloat(`0.${p}`) * 1e3) : 0)); if (l.setUTCFullYear(Number(r)), u.toUpperCase() != "Z") { let [, m, f, h] = /([+-])(\d\d):(\d\d)/.exec(u) || [void 0, "+", 0, 0], E = m === "-" ? 1 : -1; l.setTime(l.getTime() + E * (Number(f) * 60 * 60 * 1e3 + Number(h) * 60 * 1e3)) } return l }, L8 = e => { if (e == null) return; if (typeof e != "string") throw new TypeError("RFC7231 timestamps must be strings."); let t, r, o, n, i, a, c, p; if ((p = o5e.exec(e)) ? [, t, r, o, n, i, a, c] = p : (p = n5e.exec(e)) ? ([, t, r, o, n, i, a, c] = p, o = (Number(o) + 1900).toString()) : (p = s5e.exec(e)) && ([, r, t, n, i, a, c, o] = p), o && a) { let u = Date.UTC(Number(o), i5e.indexOf(r), Number(t), Number(n), Number(i), Number(a), c ? Math.round(parseFloat(`0.${c}`) * 1e3) : 0); gi(t, 1, 31), gi(n, 0, 23), gi(i, 0, 59), gi(a, 0, 60); let l = new Date(u); return l.setUTCFullYear(Number(o)), l } throw new TypeError(`Invalid RFC7231 date-time value ${e}.`) } }); function $8(e, t, r) { if (r <= 0 || !Number.isInteger(r)) throw new Error("Invalid number of delimiters (" + r + ") for splitEvery."); let o = e.split(t); if (r === 1) return o; let n = [], i = ""; for (let a = 0; a < o.length; a++)i === "" ? i = o[a] : i += t + o[a], (a + 1) % r === 0 && (n.push(i), i = ""); return i !== "" && n.push(i), n } var F8 = s(() => { }); var gE, U8 = s(() => { gE = e => { let t = e.length, r = [], o = !1, n, i = 0; for (let a = 0; a < t; ++a) { let c = e[a]; switch (c) { case '"': n !== "\\" && (o = !o); break; case ",": o || (r.push(e.slice(i, a)), i = a + 1); break; default: }n = c } return r.push(e.slice(i)), r.map(a => { a = a.trim(); let c = a.length; return c < 2 ? a : (a[0] === '"' && a[c - 1] === '"' && (a = a.slice(1, c - 1)), a.replace(/\\"/g, '"')) }) } }); var H8, _r, G8 = s(() => { H8 = /^-?\d*(\.\d+)?$/, _r = class e { string; type; constructor(t, r) { if (this.string = t, this.type = r, !H8.test(t)) throw new Error('@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point ".", and an optional negation prefix "-".') } toString() { return this.string } static [Symbol.hasInstance](t) { if (!t || typeof t != "object") return !1; let r = t; return e.prototype.isPrototypeOf(t) || r.type === "bigDecimal" && H8.test(r.string) } } }); var Pr = s(() => { d8(); A8(); I8(); v8(); OO(); O8(); M8(); F8(); U8(); G8() }); var ws, Kp = s(() => { ws = class { serdeContext; setSerdeContext(t) { this.serdeContext = t } } }); var $O, j8 = s(() => { dc(); $O = class { marshaller; serializer; deserializer; serdeContext; defaultContentType; constructor({ marshaller: t, serializer: r, deserializer: o, serdeContext: n, defaultContentType: i }) { this.marshaller = t, this.serializer = r, this.deserializer = o, this.serdeContext = n, this.defaultContentType = i } async serializeEventStream({ eventStream: t, requestSchema: r, initialRequest: o }) { let n = this.marshaller, i = r.getEventStreamMember(), a = r.getMemberSchema(i), c = this.serializer, p = this.defaultContentType, u = Symbol("initialRequestMarker"), l = { async*[Symbol.asyncIterator]() { if (o) { let m = { ":event-type": { type: "string", value: "initial-request" }, ":message-type": { type: "string", value: "event" }, ":content-type": { type: "string", value: p } }; c.write(r, o); let f = c.flush(); yield { [u]: !0, headers: m, body: f } } for await (let m of t) yield m } }; return n.serialize(l, m => { if (m[u]) return { headers: m.headers, body: m.body }; let f = Object.keys(m).find(b => b !== "__type") ?? "", { additionalHeaders: h, body: E, eventType: S, explicitPayloadContentType: y } = this.writeEventBody(f, a, m); return { headers: { ":event-type": { type: "string", value: S }, ":message-type": { type: "string", value: "event" }, ":content-type": { type: "string", value: y ?? p }, ...h }, body: E } }) } async deserializeEventStream({ response: t, responseSchema: r, initialResponseContainer: o }) { let n = this.marshaller, i = r.getEventStreamMember(), c = r.getMemberSchema(i).getMemberSchemas(), p = Symbol("initialResponseMarker"), u = n.deserialize(t.body, async f => { let h = Object.keys(f).find(S => S !== "__type") ?? "", E = f[h].body; if (h === "initial-response") { let S = await this.deserializer.read(r, E); return delete S[i], { [p]: !0, ...S } } else if (h in c) { let S = c[h]; if (S.isStructSchema()) { let y = {}, C = !1; for (let [b, L] of S.structIterator()) { let { eventHeader: N, eventPayload: j } = L.getMergedTraits(); if (C = C || !!(N || j), j) L.isBlobSchema() ? y[b] = E : L.isStringSchema() ? y[b] = (this.serdeContext?.utf8Encoder ?? As)(E) : L.isStructSchema() && (y[b] = await this.deserializer.read(L, E)); else if (N) { let re = f[h].headers[b]?.value; re != null && (L.isNumericSchema() ? re && typeof re == "object" && "bytes" in re ? y[b] = BigInt(re.toString()) : y[b] = Number(re) : y[b] = re) } } if (C) return { [h]: y } } return { [h]: await this.deserializer.read(S, E) } } else return { $unknown: f } }), l = u[Symbol.asyncIterator](), m = await l.next(); if (m.done) return u; if (m.value?.[p]) { if (!r) throw new Error("@smithy::core/protocols - initial-response event encountered in event stream but no response schema given."); for (let [f, h] of Object.entries(m.value)) o[f] = h } return { async*[Symbol.asyncIterator]() { for (m?.value?.[p] || (yield m.value); ;) { let { done: f, value: h } = await l.next(); if (f) break; yield h } } } } writeEventBody(t, r, o) { let n = this.serializer, i = t, a = null, c, p = r.getSchema()[4].includes(t), u = {}; if (p) { let f = r.getMemberSchema(t); if (f.isStructSchema()) { for (let [h, E] of f.structIterator()) { let { eventHeader: S, eventPayload: y } = E.getMergedTraits(); if (y) a = h; else if (S) { let C = o[t][h], b = "binary"; E.isNumericSchema() ? (-2) ** 31 <= C && C <= 2 ** 31 - 1 ? b = "integer" : b = "long" : E.isTimestampSchema() ? b = "timestamp" : E.isStringSchema() ? b = "string" : E.isBooleanSchema() && (b = "boolean"), C != null && (u[h] = { type: b, value: C }, delete o[t][h]) } } if (a !== null) { let h = f.getMemberSchema(a); h.isBlobSchema() ? c = "application/octet-stream" : h.isStringSchema() && (c = "text/plain"), n.write(h, o[t][a]) } else n.write(f, o[t]) } else throw new Error("@smithy/core/event-streams - non-struct member not supported in event stream union.") } else { let [f, h] = o[t]; i = f, n.write(15, h) } let l = n.flush(); return { body: typeof l == "string" ? (this.serdeContext?.utf8Decoder ?? Ji)(l) : l, eventType: i, explicitPayloadContentType: c, additionalHeaders: u } } } }); var q8 = {}; Qe(q8, { EventStreamSerde: () => $O }); var V8 = s(() => { j8() }); var Qp, xE = s(() => { Oe(); Fp(); Kp(); Qp = class extends ws { options; constructor(t) { super(), this.options = t } getRequestType() { return Rs } getResponseType() { return $p } setSerdeContext(t) { this.serdeContext = t, this.serializer.setSerdeContext(t), this.deserializer.setSerdeContext(t), this.getPayloadCodec() && this.getPayloadCodec().setSerdeContext(t) } updateServiceEndpoint(t, r) { if ("url" in r) { t.protocol = r.url.protocol, t.hostname = r.url.hostname, t.port = r.url.port ? Number(r.url.port) : void 0, t.path = r.url.pathname, t.fragment = r.url.hash || void 0, t.username = r.url.username || void 0, t.password = r.url.password || void 0, t.query || (t.query = {}); for (let [o, n] of r.url.searchParams.entries()) t.query[o] = n; return t } else return t.protocol = r.protocol, t.hostname = r.hostname, t.port = r.port ? Number(r.port) : void 0, t.path = r.path, t.query = { ...r.query }, t } setHostPrefix(t, r, o) { let n = ue.of(r.input), i = fi(r.traits ?? {}); if (i.endpoint) { let a = i.endpoint?.[0]; if (typeof a == "string") { let c = [...n.structIterator()].filter(([, p]) => p.getMergedTraits().hostLabel); for (let [p] of c) { let u = o[p]; if (typeof u != "string") throw new Error(`@smithy/core/schema - ${p} in input must be a string as hostLabel.`); a = a.replace(`{${p}}`, u) } t.hostname = a + t.hostname } } } deserializeMetadata(t) { return { httpStatusCode: t.statusCode, requestId: t.headers["x-amzn-requestid"] ?? t.headers["x-amzn-request-id"] ?? t.headers["x-amz-request-id"], extendedRequestId: t.headers["x-amz-id-2"], cfId: t.headers["x-amz-cf-id"] } } async serializeEventStream({ eventStream: t, requestSchema: r, initialRequest: o }) { return (await this.loadEventStreamCapability()).serializeEventStream({ eventStream: t, requestSchema: r, initialRequest: o }) } async deserializeEventStream({ response: t, responseSchema: r, initialResponseContainer: o }) { return (await this.loadEventStreamCapability()).deserializeEventStream({ response: t, responseSchema: r, initialResponseContainer: o }) } async loadEventStreamCapability() { let { EventStreamSerde: t } = await Promise.resolve().then(() => (V8(), q8)); return new t({ marshaller: this.getEventStreamMarshaller(), serializer: this.serializer, deserializer: this.deserializer, serdeContext: this.serdeContext, defaultContentType: this.getDefaultContentType() }) } getDefaultContentType() { throw new Error(`@smithy/core/protocols - ${this.constructor.name} getDefaultContentType() implementation missing.`) } async deserializeHttpMessage(t, r, o, n, i) { return [] } getEventStreamMarshaller() { let t = this.serdeContext; if (!t.eventStreamMarshaller) throw new Error("@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext."); return t.eventStreamMarshaller } } }); var Yp, z8 = s(() => { Oe(); Pr(); Fp(); RO(); uE(); AO(); xE(); Yp = class extends Qp { async serializeRequest(t, r, o) { let n = { ...r ?? {} }, i = this.serializer, a = {}, c = {}, p = await o.endpoint(), u = ue.of(t?.input), l = u.getSchema(), m = !1, f, h = new Rs({ protocol: "", hostname: "", port: void 0, path: "", fragment: void 0, query: a, headers: c, body: void 0 }); if (p) { this.updateServiceEndpoint(h, p), this.setHostPrefix(h, t, n); let E = fi(t.traits); if (E.http) { h.method = E.http[0]; let [S, y] = E.http[1].split("?"); h.path == "/" ? h.path = S : h.path += S; let C = new URLSearchParams(y ?? ""); Object.assign(a, Object.fromEntries(C)) } } for (let [E, S] of u.structIterator()) { let y = S.getMergedTraits() ?? {}, C = n[E]; if (!(C == null && !S.isIdempotencyToken())) if (y.httpPayload) S.isStreaming() ? S.isStructSchema() ? n[E] && (f = await this.serializeEventStream({ eventStream: n[E], requestSchema: u })) : f = C : (i.write(S, C), f = i.flush()), delete n[E]; else if (y.httpLabel) { i.write(S, C); let b = i.flush(); h.path.includes(`{${E}+}`) ? h.path = h.path.replace(`{${E}+}`, b.split("/").map(qp).join("/")) : h.path.includes(`{${E}}`) && (h.path = h.path.replace(`{${E}}`, qp(b))), delete n[E] } else if (y.httpHeader) i.write(S, C), c[y.httpHeader.toLowerCase()] = String(i.flush()), delete n[E]; else if (typeof y.httpPrefixHeaders == "string") { for (let [b, L] of Object.entries(C)) { let N = y.httpPrefixHeaders + b; i.write([S.getValueSchema(), { httpHeader: N }], L), c[N.toLowerCase()] = i.flush() } delete n[E] } else y.httpQuery || y.httpQueryParams ? (this.serializeQuery(S, C, a), delete n[E]) : m = !0 } return m && n && (i.write(l, n), f = i.flush()), h.headers = c, h.query = a, h.body = f, h } serializeQuery(t, r, o) { let n = this.serializer, i = t.getMergedTraits(); if (i.httpQueryParams) { for (let [a, c] of Object.entries(r)) if (!(a in o)) { let p = t.getValueSchema(); Object.assign(p.getMergedTraits(), { ...i, httpQuery: a, httpQueryParams: void 0 }), this.serializeQuery(p, c, o) } return } if (t.isListSchema()) { let a = !!t.getMergedTraits().sparse, c = []; for (let p of r) { n.write([t.getValueSchema(), i], p); let u = n.flush(); (a || u !== void 0) && c.push(u) } o[i.httpQuery] = c } else n.write([t, i], r), o[i.httpQuery] = n.flush() } async deserializeResponse(t, r, o) { let n = this.deserializer, i = ue.of(t.output), a = {}; if (o.statusCode >= 300) { let p = await Do(o.body, r); throw p.byteLength > 0 && Object.assign(a, await n.read(15, p)), await this.handleError(t, r, o, a, this.deserializeMetadata(o)), new Error("@smithy/core/protocols - HTTP Protocol error handler failed to throw.") } for (let p in o.headers) { let u = o.headers[p]; delete o.headers[p], o.headers[p.toLowerCase()] = u } let c = await this.deserializeHttpMessage(i, r, o, a); if (c.length) { let p = await Do(o.body, r); if (p.byteLength > 0) { let u = await n.read(i, p); for (let l of c) a[l] = u[l] } } else c.discardResponseBody && await Do(o.body, r); return a.$metadata = this.deserializeMetadata(o), a } async deserializeHttpMessage(t, r, o, n, i) { let a; n instanceof Set ? a = i : a = n; let c = !0, p = this.deserializer, u = ue.of(t), l = []; for (let [m, f] of u.structIterator()) { let h = f.getMemberTraits(); if (h.httpPayload) { if (c = !1, f.isStreaming()) f.isStructSchema() ? a[m] = await this.deserializeEventStream({ response: o, responseSchema: u }) : a[m] = z6(o.body); else if (o.body) { let S = await Do(o.body, r); S.byteLength > 0 && (a[m] = await p.read(f, S)) } } else if (h.httpHeader) { let E = String(h.httpHeader).toLowerCase(), S = o.headers[E]; if (S != null) if (f.isListSchema()) { let y = f.getValueSchema(); y.getMergedTraits().httpHeader = E; let C; y.isTimestampSchema() && y.getSchema() === 4 ? C = $8(S, ",", 2) : C = gE(S); let b = []; for (let L of C) b.push(await p.read(y, L.trim())); a[m] = b } else a[m] = await p.read(f, S) } else if (h.httpPrefixHeaders !== void 0) { a[m] = {}; for (let [E, S] of Object.entries(o.headers)) if (E.startsWith(h.httpPrefixHeaders)) { let y = f.getValueSchema(); y.getMergedTraits().httpHeader = E, a[m][E.slice(h.httpPrefixHeaders.length)] = await p.read(y, S) } } else h.httpResponseCode ? a[m] = o.statusCode : l.push(m) } return l.discardResponseBody = c, l } } }); var Xp, W8 = s(() => { Oe(); Fp(); uE(); xE(); Xp = class extends Qp { async serializeRequest(t, r, o) { let n = this.serializer, i = {}, a = {}, c = await o.endpoint(), p = ue.of(t?.input), u = p.getSchema(), l, m = new Rs({ protocol: "", hostname: "", port: void 0, path: "/", fragment: void 0, query: i, headers: a, body: void 0 }); c && (this.updateServiceEndpoint(m, c), this.setHostPrefix(m, t, r)); let f = { ...r }; if (r) { let h = p.getEventStreamMember(); if (h) { if (f[h]) { let E = {}; for (let [S, y] of p.structIterator()) S !== h && f[S] && (n.write(y, f[S]), E[S] = n.flush()); l = await this.serializeEventStream({ eventStream: f[h], requestSchema: p, initialRequest: E }) } } else n.write(u, f), l = n.flush() } return m.headers = a, m.query = i, m.body = l, m.method = "POST", m } async deserializeResponse(t, r, o) { let n = this.deserializer, i = ue.of(t.output), a = {}; if (o.statusCode >= 300) { let p = await Do(o.body, r); throw p.byteLength > 0 && Object.assign(a, await n.read(15, p)), await this.handleError(t, r, o, a, this.deserializeMetadata(o)), new Error("@smithy/core/protocols - RPC Protocol error handler failed to throw.") } for (let p in o.headers) { let u = o.headers[p]; delete o.headers[p], o.headers[p.toLowerCase()] = u } let c = i.getEventStreamMember(); if (c) a[c] = await this.deserializeEventStream({ response: o, responseSchema: i, initialResponseContainer: a }); else { let p = await Do(o.body, r); p.byteLength > 0 && Object.assign(a, await n.read(i, p)) } return a.$metadata = this.deserializeMetadata(o), a } } }); var K8 = s(() => { }); var Q8 = s(() => { }); function hn(e, t) { if (t.timestampFormat.useTrait && e.isTimestampSchema() && (e.getSchema() === 5 || e.getSchema() === 6 || e.getSchema() === 7)) return e.getSchema(); let { httpLabel: r, httpPrefixHeaders: o, httpHeader: n, httpQuery: i } = e.getMergedTraits(); return (t.httpBindings ? typeof o == "string" || n ? 6 : i || r ? 5 : void 0 : void 0) ?? t.timestampFormat.default } var EE = s(() => { }); var Jp, FO = s(() => { Oe(); Pr(); Gp(); dc(); Kp(); EE(); Jp = class extends ws { settings; constructor(t) { super(), this.settings = t } read(t, r) { let o = ue.of(t); if (o.isListSchema()) return gE(r).map(n => this.read(o.getValueSchema(), n)); if (o.isBlobSchema()) return (this.serdeContext?.base64Decoder ?? lc)(r); if (o.isTimestampSchema()) switch (hn(o, this.settings)) { case 5: return B8(r); case 6: return L8(r); case 7: return N8(r); default: return console.warn("Missing timestamp format, parsing value with Date constructor:", r), new Date(r) }if (o.isStringSchema()) { let n = o.getMergedTraits().mediaType, i = r; if (n) return o.getMergedTraits().httpHeader && (i = this.base64ToUtf8(i)), (n === "application/json" || n.endsWith("+json")) && (i = ko.from(i)), i } return o.isNumericSchema() ? Number(r) : o.isBigIntegerSchema() ? BigInt(r) : o.isBigDecimalSchema() ? new _r(r, "bigDecimal") : o.isBooleanSchema() ? String(r).toLowerCase() === "true" : r } base64ToUtf8(t) { return (this.serdeContext?.utf8Encoder ?? As)((this.serdeContext?.base64Decoder ?? lc)(t)) } } }); var Zp, Y8 = s(() => { Oe(); dc(); Kp(); FO(); Zp = class extends ws { codecDeserializer; stringDeserializer; constructor(t, r) { super(), this.codecDeserializer = t, this.stringDeserializer = new Jp(r) } setSerdeContext(t) { this.stringDeserializer.setSerdeContext(t), this.codecDeserializer.setSerdeContext(t), this.serdeContext = t } read(t, r) { let o = ue.of(t), n = o.getMergedTraits(), i = this.serdeContext?.utf8Encoder ?? As; if (n.httpHeader || n.httpResponseCode) return this.stringDeserializer.read(o, i(r)); if (n.httpPayload) { if (o.isBlobSchema()) { let a = this.serdeContext?.utf8Decoder ?? Ji; return typeof r == "string" ? a(r) : r } else if (o.isStringSchema()) return "byteLength" in r ? i(r) : r } return this.codecDeserializer.read(o, r) } } }); var yE, UO = s(() => { Oe(); Pr(); Gp(); Kp(); EE(); yE = class extends ws { settings; stringBuffer = ""; constructor(t) { super(), this.settings = t } write(t, r) { let o = ue.of(t); switch (typeof r) { case "object": if (r === null) { this.stringBuffer = "null"; return } if (o.isTimestampSchema()) { if (!(r instanceof Date)) throw new Error(`@smithy/core/protocols - received non-Date value ${r} when schema expected Date in ${o.getName(!0)}`); switch (hn(o, this.settings)) { case 5: this.stringBuffer = r.toISOString().replace(".000Z", "Z"); break; case 6: this.stringBuffer = hi(r); break; case 7: this.stringBuffer = String(r.getTime() / 1e3); break; default: console.warn("Missing timestamp format, using epoch seconds", r), this.stringBuffer = String(r.getTime() / 1e3) }return } if (o.isBlobSchema() && "byteLength" in r) { this.stringBuffer = (this.serdeContext?.base64Encoder ?? fc)(r); return } if (o.isListSchema() && Array.isArray(r)) { let a = ""; for (let c of r) { this.write([o.getValueSchema(), o.getMergedTraits()], c); let p = this.flush(), u = o.getValueSchema().isTimestampSchema() ? p : P8(p); a !== "" && (a += ", "), a += u } this.stringBuffer = a; return } this.stringBuffer = JSON.stringify(r, null, 2); break; case "string": let n = o.getMergedTraits().mediaType, i = r; if (n && ((n === "application/json" || n.endsWith("+json")) && (i = ko.from(i)), o.getMergedTraits().httpHeader)) { this.stringBuffer = (this.serdeContext?.base64Encoder ?? fc)(i.toString()); return } this.stringBuffer = r; break; default: o.isIdempotencyToken() ? this.stringBuffer = ro() : this.stringBuffer = String(r) } } flush() { let t = this.stringBuffer; return this.stringBuffer = "", t } } }); var eu, X8 = s(() => { Oe(); UO(); eu = class { codecSerializer; stringSerializer; buffer; constructor(t, r, o = new yE(r)) { this.codecSerializer = t, this.stringSerializer = o } setSerdeContext(t) { this.codecSerializer.setSerdeContext(t), this.stringSerializer.setSerdeContext(t) } write(t, r) { let o = ue.of(t), n = o.getMergedTraits(); if (n.httpHeader || n.httpLabel || n.httpQuery) { this.stringSerializer.write(o, r), this.buffer = this.stringSerializer.flush(); return } return this.codecSerializer.write(o, r) } flush() { if (this.buffer !== void 0) { let t = this.buffer; return this.buffer = void 0, t } return this.codecSerializer.flush() } } }); var rs = s(() => { uE(); AO(); z8(); xE(); W8(); Q8(); K8(); FO(); Y8(); X8(); UO(); EE(); Kp() }); var J8 = s(() => { }); function ea(e, t, r) { e.__smithy_context ? e.__smithy_context.features || (e.__smithy_context.features = {}) : e.__smithy_context = { features: {} }, e.__smithy_context.features[t] = r } var Z8 = s(() => { }); var Cr, eK = s(() => { Cr = class { authSchemes = new Map; constructor(t) { for (let [r, o] of Object.entries(t)) o !== void 0 && this.authSchemes.set(r, o) } getIdentityProvider(t) { return this.authSchemes.get(t) } } }); var tK = s(() => { }); var rK = s(() => { }); var po, oK = s(() => { po = class { async sign(t, r, o) { return t } } }); var nK = s(() => { tK(); rK(); oK() }); var a5e, sK, HO, iK, aK = s(() => { a5e = e => function (r) { return HO(r) && r.expiration.getTime() - Date.now() < e }, sK = a5e(3e5), HO = e => e.expiration !== void 0, iK = (e, t, r) => { if (e === void 0) return; let o = typeof e != "function" ? async () => Promise.resolve(e) : e, n, i, a, c = !1, p = async u => { i || (i = o(u)); try { n = await i, a = !0, c = !1 } finally { i = void 0 } return n }; return t === void 0 ? async u => ((!a || u?.forceRefresh) && (n = await p(u)), n) : async u => ((!a || u?.forceRefresh) && (n = await p(u)), c ? n : r(n) ? (t(n) && await p(u), n) : (c = !0, n)) } }); var cK = s(() => { eK(); nK(); aK() }); var Ie = s(() => { WW(); d6(); g6(); x6(); E6(); J8(); Z8(); cK() }); function c5e(e) { return e === void 0 ? !0 : typeof e == "string" && e.length <= 50 } function SE(e) { let t = yo(e.userAgentAppId ?? GO), { customUserAgent: r } = e; return Object.assign(e, { customUserAgent: typeof r == "string" ? [[r]] : r, userAgentAppId: async () => { let o = await t(); if (!c5e(o)) { let n = e.logger?.constructor?.name === "NoOpLogger" || !e.logger ? console : e.logger; typeof o != "string" ? n?.warn("userAgentAppId must be a string or undefined.") : o.length > 50 && n?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.") } return o } }) } var GO, pK = s(() => { Ie(); GO = void 0 }); var Rr, uK = s(() => { Rr = class { capacity; data = new Map; parameters = []; constructor({ size: t, params: r }) { this.capacity = t ?? 50, r && (this.parameters = r) } get(t, r) { let o = this.hash(t); if (o === !1) return r(); if (!this.data.has(o)) { if (this.data.size > this.capacity + 10) { let n = this.data.keys(), i = 0; for (; ;) { let { value: a, done: c } = n.next(); if (this.data.delete(a), c || ++i > 10) break } } this.data.set(o, r()) } return this.data.get(o) } size() { return this.data.size } hash(t) { let r = "", { parameters: o } = this; if (o.length === 0) return !1; for (let n of o) { let i = String(t[n] ?? ""); if (i.includes("|;")) return !1; r += i + "|;" } return r } } }); var p5e, No, jO = s(() => { p5e = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"), No = e => p5e.test(e) || e.startsWith("[") && e.endsWith("]") }); var u5e, Or, qO = s(() => { u5e = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"), Or = (e, t = !1) => { if (!t) return u5e.test(e); let r = e.split("."); for (let o of r) if (!Or(o)) return !1; return !0 } }); var Rt, _E = s(() => { Rt = {} }); var xi, mK = s(() => { xi = "endpoints" }); function gn(e) { return typeof e != "object" || e == null ? e : "ref" in e ? `$${gn(e.ref)}` : "fn" in e ? `${e.fn}(${(e.argv || []).map(gn).join(", ")})` : JSON.stringify(e, null, 2) } var lK = s(() => { }); var Sf = s(() => { mK(); lK() }); var qt, dK = s(() => { qt = class extends Error { constructor(t) { super(t), this.name = "EndpointError" } } }); var fK = s(() => { }); var hK = s(() => { }); var gK = s(() => { }); var xK = s(() => { }); var EK = s(() => { }); var yK = s(() => { }); var xn = s(() => { dK(); fK(); hK(); gK(); xK(); EK(); yK() }); var SK, _K = s(() => { SK = (e, t) => e === t }); var CK, RK = s(() => { xn(); CK = e => { let t = e.split("."), r = []; for (let o of t) { let n = o.indexOf("["); if (n !== -1) { if (o.indexOf("]") !== o.length - 1) throw new qt(`Path: '${e}' does not end with ']'`); let i = o.slice(n + 1, -1); if (Number.isNaN(parseInt(i))) throw new qt(`Invalid array index: '${i}' in path: '${e}'`); n !== 0 && r.push(o.slice(0, n)), r.push(i) } else r.push(o) } return r } }); var CE, AK = s(() => { xn(); RK(); CE = (e, t) => CK(t).reduce((r, o) => { if (typeof r != "object") throw new qt(`Index '${o}' in '${t}' not found in '${JSON.stringify(e)}'`); return Array.isArray(r) ? r[parseInt(o)] : r[o] }, e) }); var TK, wK = s(() => { TK = e => e != null }); var bK, IK = s(() => { bK = e => !e }); var vK = s(() => { }); var PK, OK = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(PK || (PK = {})) }); var DK, kK = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(DK || (DK = {})) }); var NK = s(() => { }); var BK = s(() => { }); var LK = s(() => { }); var MK = s(() => { }); var $K = s(() => { OK(); kK(); NK(); BK(); LK(); MK() }); var FK = s(() => { }); var UK = s(() => { }); var HK = s(() => { }); var GK = s(() => { }); var jK = s(() => { }); var qK = s(() => { }); var VK = s(() => { }); var zK = s(() => { jK(); qK(); VK() }); var WK = s(() => { }); var KK = s(() => { }); var tu, QK = s(() => { (function (e) { e.HTTP = "http", e.HTTPS = "https" })(tu || (tu = {})) }); var YK = s(() => { }); var XK = s(() => { }); var JK = s(() => { }); var ZK = s(() => { }); var e5 = s(() => { }); var t5 = s(() => { YK(); XK(); JK(); ZK(); e5() }); var r5 = s(() => { }); var o5 = s(() => { }); var n5 = s(() => { }); var s5 = s(() => { o5(); n5() }); var i5 = s(() => { }); var a5, c5 = s(() => { (function (e) { e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER" })(a5 || (a5 = {})) }); var p5 = s(() => { }); var u5 = s(() => { }); var m5 = s(() => { }); var l5 = s(() => { }); var d5 = s(() => { }); var f5 = s(() => { u5(); m5(); l5(); d5() }); var h5 = s(() => { }); var g5 = s(() => { }); var x5 = s(() => { }); var E5, y5 = s(() => { (function (e) { e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services" })(E5 || (E5 = {})) }); var S5 = s(() => { }); var _5 = s(() => { }); var C5 = s(() => { }); var R5 = s(() => { }); var A5 = s(() => { }); var T5 = s(() => { }); var w5 = s(() => { }); var b5 = s(() => { }); var I5 = s(() => { }); var v5 = s(() => { }); var P5 = s(() => { }); var O5 = s(() => { }); var D5 = s(() => { }); var k5 = s(() => { }); var N5, B5 = s(() => { (function (e) { e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0" })(N5 || (N5 = {})) }); var L5 = s(() => { }); var M5 = s(() => { }); var $5 = s(() => { }); var F5 = s(() => { }); var U5 = s(() => { }); var H5 = s(() => { }); var G5 = s(() => { }); var j5 = s(() => { vK(); $K(); FK(); UK(); HK(); GK(); zK(); WK(); KK(); QK(); t5(); r5(); s5(); i5(); c5(); p5(); f5(); h5(); g5(); x5(); y5(); S5(); _5(); C5(); R5(); A5(); T5(); w5(); b5(); I5(); v5(); P5(); O5(); D5(); k5(); B5(); L5(); M5(); $5(); F5(); U5(); H5(); G5() }); var VO, q5, V5 = s(() => { j5(); jO(); VO = { [tu.HTTP]: 80, [tu.HTTPS]: 443 }, q5 = e => { let t = (() => { try { if (e instanceof URL) return e; if (typeof e == "object" && "hostname" in e) { let { hostname: f, port: h, protocol: E = "", path: S = "", query: y = {} } = e, C = new URL(`${E}//${f}${h ? `:${h}` : ""}${S}`); return C.search = Object.entries(y).map(([b, L]) => `${b}=${L}`).join("&"), C } return new URL(e) } catch { return null } })(); if (!t) return console.error(`Unable to parse ${JSON.stringify(e)} as a whatwg URL.`), null; let r = t.href, { host: o, hostname: n, pathname: i, protocol: a, search: c } = t; if (c) return null; let p = a.slice(0, -1); if (!Object.values(tu).includes(p)) return null; let u = No(n), l = r.includes(`${o}:${VO[p]}`) || typeof e == "string" && e.includes(`${o}:${VO[p]}`), m = `${o}${l ? `:${VO[p]}` : ""}`; return { scheme: p, authority: m, path: i, normalizedPath: i.endsWith("/") ? i : `${i}/`, isIp: u } } }); var z5, W5 = s(() => { z5 = (e, t) => e === t }); var K5, Q5 = s(() => { K5 = (e, t, r, o) => t >= r || e.length < r ? null : o ? e.substring(e.length - r, e.length - t) : e.substring(t, r) }); var Y5, X5 = s(() => { Y5 = e => encodeURIComponent(e).replace(/[!*'()]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`) }); var zO = s(() => { _K(); AK(); wK(); qO(); IK(); V5(); W5(); Q5(); X5() }); var J5, Z5 = s(() => { zO(); J5 = { booleanEquals: SK, getAttr: CE, isSet: TK, isValidHostLabel: Or, not: bK, parseURL: q5, stringEquals: z5, substring: K5, uriEncode: Y5 } }); var RE, WO = s(() => { zO(); RE = (e, t) => { let r = [], o = { ...t.endpointParams, ...t.referenceRecord }, n = 0; for (; n < e.length;) { let i = e.indexOf("{", n); if (i === -1) { r.push(e.slice(n)); break } r.push(e.slice(n, i)); let a = e.indexOf("}", i); if (a === -1) { r.push(e.slice(i)); break } e[i + 1] === "{" && e[a + 1] === "}" && (r.push(e.slice(i + 1, a)), n = a + 2); let c = e.substring(i + 1, a); if (c.includes("#")) { let [p, u] = c.split("#"); r.push(CE(o[p], u)) } else r.push(o[c]); n = a + 1 } return r.join("") } }); var e9, t9 = s(() => { e9 = ({ ref: e }, t) => ({ ...t.endpointParams, ...t.referenceRecord })[e] }); var gc, AE, r9, _f = s(() => { xn(); _E(); Z5(); WO(); t9(); gc = (e, t, r) => { if (typeof e == "string") return RE(e, r); if (e.fn) return r9.callFunction(e, r); if (e.ref) return e9(e, r); throw new qt(`'${t}': ${String(e)} is not a string, function or reference.`) }, AE = ({ fn: e, argv: t }, r) => { let o = t.map(i => ["boolean", "number"].includes(typeof i) ? i : r9.evaluateExpression(i, "arg", r)), n = e.split("."); return n[0] in Rt && n[1] != null ? Rt[n[0]][n[1]](...o) : J5[e](...o) }, r9 = { evaluateExpression: gc, callFunction: AE } }); var o9 = s(() => { _f() }); var n9, s9 = s(() => { Sf(); xn(); o9(); n9 = ({ assign: e, ...t }, r) => { if (e && e in r.referenceRecord) throw new qt(`'${e}' is already defined in Reference Record.`); let o = AE(t, r); return r.logger?.debug?.(`${xi} evaluateCondition: ${gn(t)} = ${gn(o)}`), { result: o === "" ? !0 : !!o, ...e != null && { toAssign: { name: e, value: o } } } } }); var ru, TE = s(() => { Sf(); s9(); ru = (e = [], t) => { let r = {}; for (let o of e) { let { result: n, toAssign: i } = n9(o, { ...t, referenceRecord: { ...t.referenceRecord, ...r } }); if (!n) return { result: n }; i && (r[i.name] = i.value, t.logger?.debug?.(`${xi} assign: ${i.name} := ${gn(i.value)}`)) } return { result: !0, referenceRecord: r } } }); var i9, a9 = s(() => { xn(); _f(); i9 = (e, t) => Object.entries(e).reduce((r, [o, n]) => ({ ...r, [o]: n.map(i => { let a = gc(i, "Header value entry", t); if (typeof a != "string") throw new qt(`Header '${o}' value '${a}' is not a string`); return a }) }), {}) }); var KO, c9, p9, u9 = s(() => { xn(); WO(); KO = (e, t) => Object.entries(e).reduce((r, [o, n]) => ({ ...r, [o]: p9.getEndpointProperty(n, t) }), {}), c9 = (e, t) => { if (Array.isArray(e)) return e.map(r => c9(r, t)); switch (typeof e) { case "string": return RE(e, t); case "object": if (e === null) throw new qt(`Unexpected endpoint property: ${e}`); return p9.getEndpointProperties(e, t); case "boolean": return e; default: throw new qt(`Unexpected endpoint property type: ${typeof e}`) } }, p9 = { getEndpointProperty: c9, getEndpointProperties: KO } }); var m9, l9 = s(() => { xn(); _f(); m9 = (e, t) => { let r = gc(e, "Endpoint URL", t); if (typeof r == "string") try { return new URL(r) } catch (o) { throw console.error(`Failed to construct URL with ${r}`, o), o } throw new qt(`Endpoint URL must be a string, got ${typeof r}`) } }); var d9, f9 = s(() => { Sf(); TE(); a9(); u9(); l9(); d9 = (e, t) => { let { conditions: r, endpoint: o } = e, { result: n, referenceRecord: i } = ru(r, t); if (!n) return; let a = { ...t, referenceRecord: { ...t.referenceRecord, ...i } }, { url: c, properties: p, headers: u } = o; return t.logger?.debug?.(`${xi} Resolving endpoint from template: ${gn(o)}`), { ...u != null && { headers: i9(u, a) }, ...p != null && { properties: KO(p, a) }, url: m9(c, a) } } }); var h9, g9 = s(() => { xn(); TE(); _f(); h9 = (e, t) => { let { conditions: r, error: o } = e, { result: n, referenceRecord: i } = ru(r, t); if (n) throw new qt(gc(o, "Error", { ...t, referenceRecord: { ...t.referenceRecord, ...i } })) } }); var QO, m5e, x9, E9 = s(() => { xn(); TE(); f9(); g9(); QO = (e, t) => { for (let r of e) if (r.type === "endpoint") { let o = d9(r, t); if (o) return o } else if (r.type === "error") h9(r, t); else if (r.type === "tree") { let o = x9.evaluateTreeRule(r, t); if (o) return o } else throw new qt(`Unknown endpoint rule: ${r}`); throw new qt("Rules evaluation failed") }, m5e = (e, t) => { let { conditions: r, rules: o } = e, { result: n, referenceRecord: i } = ru(r, t); if (n) return x9.evaluateRules(o, { ...t, referenceRecord: { ...t.referenceRecord, ...i } }) }, x9 = { evaluateRules: QO, evaluateTreeRule: m5e } }); var y9 = s(() => { _E(); E9() }); var Ur, S9 = s(() => { Sf(); xn(); y9(); Ur = (e, t) => { let { endpointParams: r, logger: o } = t, { parameters: n, rules: i } = e; t.logger?.debug?.(`${xi} Initial EndpointParams: ${gn(r)}`); let a = Object.entries(n).filter(([, u]) => u.default != null).map(([u, l]) => [u, l.default]); if (a.length > 0) for (let [u, l] of a) r[u] = r[u] ?? l; let c = Object.entries(n).filter(([, u]) => u.required).map(([u]) => u); for (let u of c) if (r[u] == null) throw new qt(`Missing required parameter: '${u}'`); let p = QO(i, { endpointParams: r, logger: o, referenceRecord: {} }); return t.logger?.debug?.(`${xi} Resolved endpoint: ${gn(p)}`), p } }); var Ft = s(() => { uK(); jO(); qO(); _E(); S9(); xn() }); var YO = s(() => { Ft() }); var XO, _9 = s(() => { Ft(); YO(); XO = (e, t = !1) => { if (t) { for (let r of e.split(".")) if (!XO(r)) return !1; return !0 } return !(!Or(e) || e.length < 3 || e.length > 63 || e !== e.toLowerCase() || No(e)) } }); var C9, l5e, R9, A9 = s(() => { C9 = ":", l5e = "/", R9 = e => { let t = e.split(C9); if (t.length < 6) return null; let [r, o, n, i, a, ...c] = t; if (r !== "arn" || o === "" || n === "" || c.join(C9) === "") return null; let p = c.map(u => u.split(l5e)).flat(); return { partition: o, service: n, region: i, accountId: a, resourceId: p } } }); var w9, T9 = s(() => { w9 = { partitions: [{ id: "aws", outputs: { dnsSuffix: "amazonaws.com", dualStackDnsSuffix: "api.aws", implicitGlobalRegion: "us-east-1", name: "aws", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$", regions: { "af-south-1": { description: "Africa (Cape Town)" }, "ap-east-1": { description: "Asia Pacific (Hong Kong)" }, "ap-east-2": { description: "Asia Pacific (Taipei)" }, "ap-northeast-1": { description: "Asia Pacific (Tokyo)" }, "ap-northeast-2": { description: "Asia Pacific (Seoul)" }, "ap-northeast-3": { description: "Asia Pacific (Osaka)" }, "ap-south-1": { description: "Asia Pacific (Mumbai)" }, "ap-south-2": { description: "Asia Pacific (Hyderabad)" }, "ap-southeast-1": { description: "Asia Pacific (Singapore)" }, "ap-southeast-2": { description: "Asia Pacific (Sydney)" }, "ap-southeast-3": { description: "Asia Pacific (Jakarta)" }, "ap-southeast-4": { description: "Asia Pacific (Melbourne)" }, "ap-southeast-5": { description: "Asia Pacific (Malaysia)" }, "ap-southeast-6": { description: "Asia Pacific (New Zealand)" }, "ap-southeast-7": { description: "Asia Pacific (Thailand)" }, "aws-global": { description: "aws global region" }, "ca-central-1": { description: "Canada (Central)" }, "ca-west-1": { description: "Canada West (Calgary)" }, "eu-central-1": { description: "Europe (Frankfurt)" }, "eu-central-2": { description: "Europe (Zurich)" }, "eu-north-1": { description: "Europe (Stockholm)" }, "eu-south-1": { description: "Europe (Milan)" }, "eu-south-2": { description: "Europe (Spain)" }, "eu-west-1": { description: "Europe (Ireland)" }, "eu-west-2": { description: "Europe (London)" }, "eu-west-3": { description: "Europe (Paris)" }, "il-central-1": { description: "Israel (Tel Aviv)" }, "me-central-1": { description: "Middle East (UAE)" }, "me-south-1": { description: "Middle East (Bahrain)" }, "mx-central-1": { description: "Mexico (Central)" }, "sa-east-1": { description: "South America (Sao Paulo)" }, "us-east-1": { description: "US East (N. Virginia)" }, "us-east-2": { description: "US East (Ohio)" }, "us-west-1": { description: "US West (N. California)" }, "us-west-2": { description: "US West (Oregon)" } } }, { id: "aws-cn", outputs: { dnsSuffix: "amazonaws.com.cn", dualStackDnsSuffix: "api.amazonwebservices.com.cn", implicitGlobalRegion: "cn-northwest-1", name: "aws-cn", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^cn\\-\\w+\\-\\d+$", regions: { "aws-cn-global": { description: "aws-cn global region" }, "cn-north-1": { description: "China (Beijing)" }, "cn-northwest-1": { description: "China (Ningxia)" } } }, { id: "aws-eusc", outputs: { dnsSuffix: "amazonaws.eu", dualStackDnsSuffix: "api.amazonwebservices.eu", implicitGlobalRegion: "eusc-de-east-1", name: "aws-eusc", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$", regions: { "eusc-de-east-1": { description: "EU (Germany)" } } }, { id: "aws-iso", outputs: { dnsSuffix: "c2s.ic.gov", dualStackDnsSuffix: "api.aws.ic.gov", implicitGlobalRegion: "us-iso-east-1", name: "aws-iso", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-iso\\-\\w+\\-\\d+$", regions: { "aws-iso-global": { description: "aws-iso global region" }, "us-iso-east-1": { description: "US ISO East" }, "us-iso-west-1": { description: "US ISO WEST" } } }, { id: "aws-iso-b", outputs: { dnsSuffix: "sc2s.sgov.gov", dualStackDnsSuffix: "api.aws.scloud", implicitGlobalRegion: "us-isob-east-1", name: "aws-iso-b", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-isob\\-\\w+\\-\\d+$", regions: { "aws-iso-b-global": { description: "aws-iso-b global region" }, "us-isob-east-1": { description: "US ISOB East (Ohio)" }, "us-isob-west-1": { description: "US ISOB West" } } }, { id: "aws-iso-e", outputs: { dnsSuffix: "cloud.adc-e.uk", dualStackDnsSuffix: "api.cloud-aws.adc-e.uk", implicitGlobalRegion: "eu-isoe-west-1", name: "aws-iso-e", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$", regions: { "aws-iso-e-global": { description: "aws-iso-e global region" }, "eu-isoe-west-1": { description: "EU ISOE West" } } }, { id: "aws-iso-f", outputs: { dnsSuffix: "csp.hci.ic.gov", dualStackDnsSuffix: "api.aws.hci.ic.gov", implicitGlobalRegion: "us-isof-south-1", name: "aws-iso-f", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-isof\\-\\w+\\-\\d+$", regions: { "aws-iso-f-global": { description: "aws-iso-f global region" }, "us-isof-east-1": { description: "US ISOF EAST" }, "us-isof-south-1": { description: "US ISOF SOUTH" } } }, { id: "aws-us-gov", outputs: { dnsSuffix: "amazonaws.com", dualStackDnsSuffix: "api.aws", implicitGlobalRegion: "us-gov-west-1", name: "aws-us-gov", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-gov\\-\\w+\\-\\d+$", regions: { "aws-us-gov-global": { description: "aws-us-gov global region" }, "us-gov-east-1": { description: "AWS GovCloud (US-East)" }, "us-gov-west-1": { description: "AWS GovCloud (US-West)" } } }], version: "1.1" } }); var f5e, h5e, b9, I9, JO = s(() => { T9(); f5e = w9, h5e = "", b9 = e => { let { partitions: t } = f5e; for (let o of t) { let { regions: n, outputs: i } = o; for (let [a, c] of Object.entries(n)) if (a === e) return { ...i, ...c } } for (let o of t) { let { regionRegex: n, outputs: i } = o; if (new RegExp(n).test(e)) return { ...i } } let r = t.find(o => o.id === "aws"); if (!r) throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."); return { ...r.outputs } }, I9 = () => h5e }); var Cf, v9 = s(() => { Ft(); _9(); A9(); JO(); Cf = { isVirtualHostableS3Bucket: XO, parseArn: R9, partition: b9 }; Rt.aws = Cf }); function P9(e) { let t = {}; if (e = e.replace(/^\?/, ""), e) for (let r of e.split("&")) { let [o, n = null] = r.split("="); o = decodeURIComponent(o), n && (n = decodeURIComponent(n)), o in t ? Array.isArray(t[o]) ? t[o].push(n) : t[o] = [t[o], n] : t[o] = n } return t } var O9 = s(() => { }); var bs, Rf = s(() => { O9(); bs = e => { if (typeof e == "string") return bs(new URL(e)); let { hostname: t, pathname: r, port: o, protocol: n, search: i } = e, a; return i && (a = P9(i)), { hostname: t, port: o ? parseInt(o) : void 0, protocol: n, path: r, query: a } } }); var D9 = s(() => { }); var k9 = s(() => { }); var N9 = s(() => { }); var B9 = s(() => { }); var L9 = s(() => { }); var M9 = s(() => { }); var $9 = s(() => { }); var F9 = s(() => { }); var U9 = s(() => { N9(); B9(); L9(); M9(); $9(); F9() }); var wE = s(() => { v9(); JO(); YO(); D9(); k9(); U9() }); var H9, Hr, G9 = s(() => {
  H9 = { warningEmitted: !1 }, Hr = e => {
    e && !H9.warningEmitted && parseInt(e.substring(1, e.indexOf("."))) < 20 && (H9.warningEmitted = !0, process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js ${e} in January 2026.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/c895JFp`))
  }
}); function ee(e, t, r) { return e.$source || (e.$source = {}), e.$source[t] = r, e } var j9 = s(() => { }); function ye(e, t, r) { e.__aws_sdk_context ? e.__aws_sdk_context.features || (e.__aws_sdk_context.features = {}) : e.__aws_sdk_context = { features: {} }, e.__aws_sdk_context.features[t] = r } var q9 = s(() => { }); var V9 = s(() => { }); var He = s(() => { G9(); j9(); q9(); V9() }); var z9 = s(() => { }); var W9 = s(() => { z9() }); var K9 = s(() => { }); var Q9 = s(() => { }); var Y9 = s(() => { }); function g5e(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var ou, X9 = s(() => { ou = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = g5e(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var bE, J9 = s(() => { bE = class { statusCode; reason; headers; body; constructor(t) { this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body } static isInstance(t) { if (!t) return !1; let r = t; return typeof r.statusCode == "number" && typeof r.headers == "object" } } }); var Z9 = s(() => { }); var eQ = s(() => { }); var IE = s(() => { W9(); K9(); Q9(); Y9(); X9(); J9(); Z9(); eQ() }); var ZO, tQ = s(() => { IE(); ZO = e => bE.isInstance(e) ? e.headers?.date ?? e.headers?.Date : void 0 }); var nu, eD = s(() => { nu = e => new Date(Date.now() + e) }); var rQ, oQ = s(() => { eD(); rQ = (e, t) => Math.abs(nu(t).getTime() - e) >= 3e5 }); var tD, nQ = s(() => { oQ(); tD = (e, t) => { let r = Date.parse(e); return rQ(r, t) ? r - Date.now() : t } }); var rD = s(() => { tQ(); eD(); nQ() }); var Af, vE, Vt, oD = s(() => { IE(); rD(); Af = (e, t) => { if (!t) throw new Error(`Property \`${e}\` is not resolved for AWS SDK SigV4Auth`); return t }, vE = async e => { let t = Af("context", e.context), r = Af("config", e.config), o = t.endpointV2?.properties?.authSchemes?.[0], i = await Af("signer", r.signer)(o), a = e?.signingRegion, c = e?.signingRegionSet, p = e?.signingName; return { config: r, signer: i, signingRegion: a, signingRegionSet: c, signingName: p } }, Vt = class { async sign(t, r, o) { if (!ou.isInstance(t)) throw new Error("The request is not an instance of `HttpRequest` and cannot be signed"); let n = await vE(o), { config: i, signer: a } = n, { signingRegion: c, signingName: p } = n, u = o.context; if (u?.authSchemes?.length ?? !1) { let [m, f] = u.authSchemes; m?.name === "sigv4a" && f?.name === "sigv4" && (c = f?.signingRegion ?? c, p = f?.signingName ?? p) } return await a.sign(t, { signingDate: nu(i.systemClockOffset), signingRegion: c, signingService: p }) } errorHandler(t) { return r => { let o = r.ServerTime ?? ZO(r.$response); if (o) { let n = Af("config", t.config), i = n.systemClockOffset; n.systemClockOffset = tD(o, n.systemClockOffset), n.systemClockOffset !== i && r.$metadata && (r.$metadata.clockSkewCorrected = !0) } throw r } } successHandler(t, r) { let o = ZO(t); if (o) { let n = Af("config", r.config); n.systemClockOffset = tD(o, n.systemClockOffset) } } } }); var Tf, sQ = s(() => { IE(); rD(); oD(); Tf = class extends Vt { async sign(t, r, o) { if (!ou.isInstance(t)) throw new Error("The request is not an instance of `HttpRequest` and cannot be signed"); let { config: n, signer: i, signingRegion: a, signingRegionSet: c, signingName: p } = await vE(o), l = (await n.sigv4aSigningRegionSet?.() ?? c ?? [a]).join(","); return await i.sign(t, { signingDate: nu(n.systemClockOffset), signingRegion: l, signingService: p }) } } }); var nD, iQ = s(() => { nD = e => typeof e == "string" && e.length > 0 ? e.split(",").map(t => t.trim()) : [] }); var aQ, sD = s(() => { aQ = e => `AWS_BEARER_TOKEN_${e.replace(/[\s-]/g, "_").toUpperCase()}` }); var cQ, pQ, Gr, uQ = s(() => { iQ(); sD(); cQ = "AWS_AUTH_SCHEME_PREFERENCE", pQ = "auth_scheme_preference", Gr = { environmentVariableSelector: (e, t) => { if (t?.signingName && aQ(t.signingName) in e) return ["httpBearerAuth"]; if (cQ in e) return nD(e[cQ]) }, configFileSelector: e => { if (pQ in e) return nD(e[pQ]) }, default: [] } }); var kt, wf = s(() => { kt = class e extends Error { name = "ProviderError"; tryNextLink; constructor(t, r = !0) { let o, n = !0; typeof r == "boolean" ? (o = void 0, n = r) : r != null && typeof r == "object" && (o = r.logger, n = r.tryNextLink ?? !0), super(t), this.tryNextLink = n, Object.setPrototypeOf(this, e.prototype), o?.debug?.(`@smithy/property-provider ${n ? "->" : "(!)"} ${t}`) } static from(t, r = !0) { return Object.assign(new this(t.message, r), t) } } }); var I, mQ = s(() => { wf(); I = class e extends kt { name = "CredentialsProviderError"; constructor(t, r = !0) { super(t, r), Object.setPrototypeOf(this, e.prototype) } } }); var at, lQ = s(() => { wf(); at = class e extends kt { name = "TokenProviderError"; constructor(t, r = !0) { super(t, r), Object.setPrototypeOf(this, e.prototype) } } }); var sr, dQ = s(() => { wf(); sr = (...e) => async () => { if (e.length === 0) throw new kt("No providers in chain"); let t; for (let r of e) try { return await r() } catch (o) { if (t = o, o?.tryNextLink) continue; throw o } throw t } }); var Is, fQ = s(() => { Is = e => () => Promise.resolve(e) }); var jr, hQ = s(() => { jr = (e, t, r) => { let o, n, i, a = !1, c = async () => { n || (n = e()); try { o = await n, i = !0, a = !1 } finally { n = void 0 } return o }; return t === void 0 ? async p => ((!i || p?.forceRefresh) && (o = await c()), o) : async p => ((!i || p?.forceRefresh) && (o = await c()), a ? o : r && !r(o) ? (a = !0, o) : (t(o) && await c(), o)) } }); var Z = s(() => { mQ(); wf(); lQ(); dQ(); fQ(); hQ() }); var gQ, xQ, EQ = s(() => { Ie(); Z(); gQ = e => (e.sigv4aSigningRegionSet = yo(e.sigv4aSigningRegionSet), e), xQ = { environmentVariableSelector(e) { if (e.AWS_SIGV4A_SIGNING_REGION_SET) return e.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map(t => t.trim()); throw new kt("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", { tryNextLink: !0 }) }, configFileSelector(e) { if (e.sigv4a_signing_region_set) return (e.sigv4a_signing_region_set ?? "").split(",").map(t => t.trim()); throw new kt("sigv4a_signing_region_set not set in profile.", { tryNextLink: !0 }) }, default: void 0 } }); import { Buffer as yQ } from "buffer"; var SQ, _Q = s(() => { SQ = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? yQ.from(e, t) : yQ.from(e) } }); var bf, iD = s(() => { _Q(); bf = e => { let t = SQ(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var Ei, CQ = s(() => { iD(); Ei = e => typeof e == "string" ? bf(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) }); var RQ = s(() => { }); var su = s(() => { iD(); CQ(); RQ() }); var AQ, TQ, aD, wQ, bQ, cD, pD, uD, mD, x5e, IQ, vQ, If, PQ, OQ, DQ, kQ, PE, NQ, BQ, LQ, lD, MQ, ta = s(() => { AQ = "X-Amz-Algorithm", TQ = "X-Amz-Credential", aD = "X-Amz-Date", wQ = "X-Amz-SignedHeaders", bQ = "X-Amz-Expires", cD = "X-Amz-Signature", pD = "X-Amz-Security-Token", uD = "authorization", mD = aD.toLowerCase(), x5e = "date", IQ = [uD, mD, x5e], vQ = cD.toLowerCase(), If = "x-amz-content-sha256", PQ = pD.toLowerCase(), OQ = { authorization: !0, "cache-control": !0, connection: !0, expect: !0, from: !0, "keep-alive": !0, "max-forwards": !0, pragma: !0, referer: !0, te: !0, trailer: !0, "transfer-encoding": !0, upgrade: !0, "user-agent": !0, "x-amzn-trace-id": !0 }, DQ = /^proxy-/, kQ = /^sec-/, PE = "AWS4-HMAC-SHA256", NQ = "AWS4-HMAC-SHA256-PAYLOAD", BQ = "UNSIGNED-PAYLOAD", LQ = 50, lD = "aws4_request", MQ = 60 * 60 * 24 * 7 }); var OE, dD, DE, FQ, $Q, fD = s(() => { Oo(); su(); ta(); OE = {}, dD = [], DE = (e, t, r) => `${e}/${t}/${r}/${lD}`, FQ = async (e, t, r, o, n) => { let i = await $Q(e, t.secretAccessKey, t.accessKeyId), a = `${r}:${o}:${n}:${it(i)}:${t.sessionToken}`; if (a in OE) return OE[a]; for (dD.push(a); dD.length > LQ;)delete OE[dD.shift()]; let c = `AWS4${t.secretAccessKey}`; for (let p of [r, o, n, lD]) c = await $Q(e, c, p); return OE[a] = c }, $Q = (e, t, r) => { let o = new e(t); return o.update(Ei(r)), o.digest() } }); var hD, UQ = s(() => { ta(); hD = ({ headers: e }, t, r) => { let o = {}; for (let n of Object.keys(e).sort()) { if (e[n] == null) continue; let i = n.toLowerCase(); (i in OQ || t?.has(i) || DQ.test(i) || kQ.test(i)) && (!r || r && !r.has(i)) || (o[i] = e[n].trim().replace(/\s+/g, " ")) } return o } }); var kE, HQ = s(() => { cr(); Oo(); su(); ta(); kE = async ({ headers: e, body: t }, r) => { for (let o of Object.keys(e)) if (o.toLowerCase() === If) return e[o]; if (t == null) return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"; if (typeof t == "string" || ArrayBuffer.isView(t) || Le(t)) { let o = new r; return o.update(Ei(t)), it(await o.digest()) } return BQ } }); function jQ(e) { for (let t = 0; t < 8; t++)e[t] ^= 255; for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--); } var NE, GQ, E5e, gD, qQ = s(() => { Oo(); su(); NE = class { format(t) { let r = []; for (let i of Object.keys(t)) { let a = bf(i); r.push(Uint8Array.from([a.byteLength]), a, this.formatHeaderValue(t[i])) } let o = new Uint8Array(r.reduce((i, a) => i + a.byteLength, 0)), n = 0; for (let i of r) o.set(i, n), n += i.byteLength; return o } formatHeaderValue(t) { switch (t.type) { case "boolean": return Uint8Array.from([t.value ? 0 : 1]); case "byte": return Uint8Array.from([2, t.value]); case "short": let r = new DataView(new ArrayBuffer(3)); return r.setUint8(0, 3), r.setInt16(1, t.value, !1), new Uint8Array(r.buffer); case "integer": let o = new DataView(new ArrayBuffer(5)); return o.setUint8(0, 4), o.setInt32(1, t.value, !1), new Uint8Array(o.buffer); case "long": let n = new Uint8Array(9); return n[0] = 5, n.set(t.value.bytes, 1), n; case "binary": let i = new DataView(new ArrayBuffer(3 + t.value.byteLength)); i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, !1); let a = new Uint8Array(i.buffer); return a.set(t.value, 3), a; case "string": let c = bf(t.value), p = new DataView(new ArrayBuffer(3 + c.byteLength)); p.setUint8(0, 7), p.setUint16(1, c.byteLength, !1); let u = new Uint8Array(p.buffer); return u.set(c, 3), u; case "timestamp": let l = new Uint8Array(9); return l[0] = 8, l.set(gD.fromNumber(t.value.valueOf()).bytes, 1), l; case "uuid": if (!E5e.test(t.value)) throw new Error(`Invalid UUID received: ${t.value}`); let m = new Uint8Array(17); return m[0] = 9, m.set(pE(t.value.replace(/\-/g, "")), 1), m } } }; (function (e) { e[e.boolTrue = 0] = "boolTrue", e[e.boolFalse = 1] = "boolFalse", e[e.byte = 2] = "byte", e[e.short = 3] = "short", e[e.integer = 4] = "integer", e[e.long = 5] = "long", e[e.byteArray = 6] = "byteArray", e[e.string = 7] = "string", e[e.timestamp = 8] = "timestamp", e[e.uuid = 9] = "uuid" })(GQ || (GQ = {})); E5e = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/, gD = class e { bytes; constructor(t) { if (this.bytes = t, t.byteLength !== 8) throw new Error("Int64 buffers must be exactly 8 bytes") } static fromNumber(t) { if (t > 9223372036854776e3 || t < -9223372036854776e3) throw new Error(`${t} is too large (or, if negative, too small) to represent as an Int64`); let r = new Uint8Array(8); for (let o = 7, n = Math.abs(Math.round(t)); o > -1 && n > 0; o--, n /= 256)r[o] = n; return t < 0 && jQ(r), new e(r) } valueOf() { let t = this.bytes.slice(0), r = t[0] & 128; return r && jQ(t), parseInt(it(t), 16) * (r ? -1 : 1) } toString() { return String(this.valueOf()) } } }); var VQ, zQ = s(() => { VQ = (e, t) => { e = e.toLowerCase(); for (let r of Object.keys(t)) if (e === r.toLowerCase()) return !0; return !1 } }); var WQ = s(() => { }); var KQ = s(() => { WQ() }); var QQ = s(() => { }); var YQ = s(() => { }); var XQ = s(() => { }); function y5e(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var iu, JQ = s(() => { iu = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = y5e(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var ZQ = s(() => { }); var e7 = s(() => { }); var t7 = s(() => { }); var xD = s(() => { KQ(); QQ(); YQ(); XQ(); JQ(); ZQ(); e7(); t7() }); var r7, o7 = s(() => { xD(); r7 = (e, t = {}) => { let { headers: r, query: o = {} } = iu.clone(e); for (let n of Object.keys(r)) { let i = n.toLowerCase(); (i.slice(0, 6) === "x-amz-" && !t.unhoistableHeaders?.has(i) || t.hoistableHeaders?.has(i)) && (o[n] = r[n], delete r[n]) } return { ...e, headers: r, query: o } } }); var ED, n7 = s(() => { xD(); ta(); ED = e => { e = iu.clone(e); for (let t of Object.keys(e.headers)) IQ.indexOf(t.toLowerCase()) > -1 && delete e.headers[t]; return e } }); var au, S5e, s7 = s(() => { au = e => encodeURIComponent(e).replace(/[!'()*]/g, S5e), S5e = e => `%${e.charCodeAt(0).toString(16).toUpperCase()}` }); var i7 = s(() => { }); var yD = s(() => { s7(); i7() }); var a7, c7 = s(() => { yD(); ta(); a7 = ({ query: e = {} }) => { let t = [], r = {}; for (let o of Object.keys(e)) { if (o.toLowerCase() === vQ) continue; let n = au(o); t.push(n); let i = e[o]; typeof i == "string" ? r[n] = `${n}=${au(i)}` : Array.isArray(i) && (r[n] = i.slice(0).reduce((a, c) => a.concat([`${n}=${au(c)}`]), []).sort().join("&")) } return t.sort().map(o => r[o]).filter(o => o).join("&") } }); var p7, _5e, u7 = s(() => { p7 = e => _5e(e).toISOString().replace(/\.\d{3}Z$/, "Z"), _5e = e => typeof e == "number" ? new Date(e * 1e3) : typeof e == "string" ? Number(e) ? new Date(Number(e) * 1e3) : new Date(e) : e }); var BE, m7 = s(() => {
  Oo(); gt(); yD(); su(); c7(); u7(); BE = class {
    service; regionProvider; credentialProvider; sha256; uriEscapePath; applyChecksum; constructor({ applyChecksum: t, credentials: r, region: o, service: n, sha256: i, uriEscapePath: a = !0 }) { this.service = n, this.sha256 = i, this.uriEscapePath = a, this.applyChecksum = typeof t == "boolean" ? t : !0, this.regionProvider = le(o), this.credentialProvider = le(r) } createCanonicalRequest(t, r, o) {
      let n = Object.keys(r).sort(); return `${t.method}
${this.getCanonicalPath(t)}
${a7(t)}
${n.map(i => `${i}:${r[i]}`).join(`
`)}

${n.join(";")}
${o}`
    } async createStringToSign(t, r, o, n) {
      let i = new this.sha256; i.update(Ei(o)); let a = await i.digest(); return `${n}
${t}
${r}
${it(a)}`
    } getCanonicalPath({ path: t }) { if (this.uriEscapePath) { let r = []; for (let i of t.split("/")) i?.length !== 0 && i !== "." && (i === ".." ? r.pop() : r.push(i)); let o = `${t?.startsWith("/") ? "/" : ""}${r.join("/")}${r.length > 0 && t?.endsWith("/") ? "/" : ""}`; return au(o).replace(/%2F/g, "/") } return t } validateResolvedCredentials(t) { if (typeof t != "object" || typeof t.accessKeyId != "string" || typeof t.secretAccessKey != "string") throw new Error("Resolved credential object is not valid") } formatDate(t) { let r = p7(t).replace(/[\-:]/g, ""); return { longDate: r, shortDate: r.slice(0, 8) } } getCanonicalHeaderList(t) { return Object.keys(t).sort().join(";") }
  }
}); var xc, l7 = s(() => {
  Oo(); su(); ta(); fD(); UQ(); HQ(); qQ(); zQ(); o7(); n7(); m7(); xc = class extends BE {
    headerFormatter = new NE; constructor({ applyChecksum: t, credentials: r, region: o, service: n, sha256: i, uriEscapePath: a = !0 }) { super({ applyChecksum: t, credentials: r, region: o, service: n, sha256: i, uriEscapePath: a }) } async presign(t, r = {}) { let { signingDate: o = new Date, expiresIn: n = 3600, unsignableHeaders: i, unhoistableHeaders: a, signableHeaders: c, hoistableHeaders: p, signingRegion: u, signingService: l } = r, m = await this.credentialProvider(); this.validateResolvedCredentials(m); let f = u ?? await this.regionProvider(), { longDate: h, shortDate: E } = this.formatDate(o); if (n > MQ) return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future"); let S = DE(E, f, l ?? this.service), y = r7(ED(t), { unhoistableHeaders: a, hoistableHeaders: p }); m.sessionToken && (y.query[pD] = m.sessionToken), y.query[AQ] = PE, y.query[TQ] = `${m.accessKeyId}/${S}`, y.query[aD] = h, y.query[bQ] = n.toString(10); let C = hD(y, i, c); return y.query[wQ] = this.getCanonicalHeaderList(C), y.query[cD] = await this.getSignature(h, S, this.getSigningKey(m, f, E, l), this.createCanonicalRequest(y, C, await kE(t, this.sha256))), y } async sign(t, r) { return typeof t == "string" ? this.signString(t, r) : t.headers && t.payload ? this.signEvent(t, r) : t.message ? this.signMessage(t, r) : this.signRequest(t, r) } async signEvent({ headers: t, payload: r }, { signingDate: o = new Date, priorSignature: n, signingRegion: i, signingService: a }) {
      let c = i ?? await this.regionProvider(), { shortDate: p, longDate: u } = this.formatDate(o), l = DE(p, c, a ?? this.service), m = await kE({ headers: {}, body: r }, this.sha256), f = new this.sha256; f.update(t); let h = it(await f.digest()), E = [NQ, u, l, n, h, m].join(`
`); return this.signString(E, { signingDate: o, signingRegion: c, signingService: a })
    } async signMessage(t, { signingDate: r = new Date, signingRegion: o, signingService: n }) { return this.signEvent({ headers: this.headerFormatter.format(t.message.headers), payload: t.message.body }, { signingDate: r, signingRegion: o, signingService: n, priorSignature: t.priorSignature }).then(a => ({ message: t.message, signature: a })) } async signString(t, { signingDate: r = new Date, signingRegion: o, signingService: n } = {}) { let i = await this.credentialProvider(); this.validateResolvedCredentials(i); let a = o ?? await this.regionProvider(), { shortDate: c } = this.formatDate(r), p = new this.sha256(await this.getSigningKey(i, a, c, n)); return p.update(Ei(t)), it(await p.digest()) } async signRequest(t, { signingDate: r = new Date, signableHeaders: o, unsignableHeaders: n, signingRegion: i, signingService: a } = {}) { let c = await this.credentialProvider(); this.validateResolvedCredentials(c); let p = i ?? await this.regionProvider(), u = ED(t), { longDate: l, shortDate: m } = this.formatDate(r), f = DE(m, p, a ?? this.service); u.headers[mD] = l, c.sessionToken && (u.headers[PQ] = c.sessionToken); let h = await kE(u, this.sha256); !VQ(If, u.headers) && this.applyChecksum && (u.headers[If] = h); let E = hD(u, n, o), S = await this.getSignature(l, f, this.getSigningKey(c, p, m, a), this.createCanonicalRequest(u, E, h)); return u.headers[uD] = `${PE} Credential=${c.accessKeyId}/${f}, SignedHeaders=${this.getCanonicalHeaderList(E)}, Signature=${S}`, u } async getSignature(t, r, o, n) { let i = await this.createStringToSign(t, r, n, PE), a = new this.sha256(await o); return a.update(Ei(i)), it(await a.digest()) } getSigningKey(t, r, o, n) { return FQ(this.sha256, t, o, r, n || this.service) }
  }
}); var SD, d7 = s(() => { SD = { SignatureV4a: null } }); var LE = s(() => { l7(); ta(); fD(); d7() }); function C5e(e, { credentials: t, credentialDefaultProvider: r }) { let o; return t ? t?.memoized ? o = t : o = iK(t, sK, HO) : r ? o = yo(r(Object.assign({}, e, { parentClientConfig: e }))) : o = async () => { throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.") }, o.memoized = !0, o } function R5e(e, t) { if (t.configBound) return t; let r = async o => t({ ...o, callerClientConfig: e }); return r.memoized = t.memoized, r.configBound = !0, r } var qr, f7 = s(() => { He(); Ie(); LE(); qr = e => { let t = e.credentials, r = !!e.credentials, o; Object.defineProperty(e, "credentials", { set(u) { u && u !== t && u !== o && (r = !0), t = u; let l = C5e(e, { credentials: t, credentialDefaultProvider: e.credentialDefaultProvider }), m = R5e(e, l); r && !m.attributed ? (o = async f => m(f).then(h => ee(h, "CREDENTIALS_CODE", "e")), o.memoized = m.memoized, o.configBound = m.configBound, o.attributed = !0) : o = m }, get() { return o }, enumerable: !0, configurable: !0 }), e.credentials = t; let { signingEscapePath: n = !0, systemClockOffset: i = e.systemClockOffset || 0, sha256: a } = e, c; return e.signer ? c = yo(e.signer) : e.regionInfoProvider ? c = () => yo(e.region)().then(async u => [await e.regionInfoProvider(u, { useFipsEndpoint: await e.useFipsEndpoint(), useDualstackEndpoint: await e.useDualstackEndpoint() }) || {}, u]).then(([u, l]) => { let { signingRegion: m, signingService: f } = u; e.signingRegion = e.signingRegion || m || l, e.signingName = e.signingName || f || e.serviceId; let h = { ...e, credentials: e.credentials, region: e.signingRegion, service: e.signingName, sha256: a, uriEscapePath: n }, E = e.signerConstructor || xc; return new E(h) }) : c = async u => { u = Object.assign({}, { name: "sigv4", signingName: e.signingName || e.defaultSigningName, signingRegion: await yo(e.region)(), properties: {} }, u); let l = u.signingRegion, m = u.signingName; e.signingRegion = e.signingRegion || l, e.signingName = e.signingName || m || e.serviceId; let f = { ...e, credentials: e.credentials, region: e.signingRegion, service: e.signingName, sha256: a, uriEscapePath: n }, h = e.signerConstructor || xc; return new h(f) }, Object.assign(e, { systemClockOffset: i, signingEscapePath: n, signer: c }) } }); var h7 = s(() => { oD(); sQ(); uQ(); EQ(); f7() }); var g7 = s(() => { h7(); sD() }); var x7 = s(() => { }); var E7 = s(() => { rs() }); var y7 = s(() => { }); var S7 = s(() => { }); var _7 = s(() => { }); var _D, C7 = s(() => { _D = (e, t = {}) => { Object.entries(t).filter(([, o]) => o !== void 0).forEach(([o, n]) => { (e[o] == null || e[o] === "") && (e[o] = n) }); let r = e.message || e.Message || "UnknownError"; return e.message = r, delete e.Message, e } }); var R7 = s(() => { }); var A7 = s(() => { }); var T7 = s(() => { }); var w7 = s(() => { }); var b7 = s(() => { }); var I7 = s(() => { b7() }); var v7 = s(() => { }); var CD, P7 = s(() => { CD = e => { let t = "#text"; for (let r in e) e.hasOwnProperty(r) && e[r][t] !== void 0 ? e[r] = e[r][t] : typeof e[r] == "object" && e[r] !== null && (e[r] = CD(e[r])); return e } }); var O7 = s(() => { }); var D7 = s(() => { }); var k7 = s(() => { }); var N7 = s(() => { }); var B7 = s(() => { }); var L7 = s(() => { }); var cu = s(() => { x7(); E7(); y7(); S7(); _7(); R7(); A7(); T7(); C7(); w7(); I7(); v7(); P7(); O7(); D7(); k7(); N7(); B7(); L7(); Pr() }); var vs, vf = s(() => { Oe(); cu(); vs = class { queryCompat; constructor(t = !1) { this.queryCompat = t } resolveRestContentType(t, r) { let o = r.getMemberSchemas(), n = Object.values(o).find(i => !!i.getMergedTraits().httpPayload); if (n) { let i = n.getMergedTraits().mediaType; return i || (n.isStringSchema() ? "text/plain" : n.isBlobSchema() ? "application/octet-stream" : t) } else if (!r.isUnitSchema() && Object.values(o).find(a => { let { httpQuery: c, httpQueryParams: p, httpHeader: u, httpLabel: l, httpPrefixHeaders: m } = a.getMergedTraits(); return !c && !p && !u && !l && m === void 0 })) return t } async getErrorSchemaOrThrowBaseException(t, r, o, n, i, a) { let c = r, p = t; t.includes("#") && ([c, p] = t.split("#")); let u = { $metadata: i, $fault: o.statusCode < 500 ? "client" : "server" }, l = k.for(c); try { return { errorSchema: a?.(l, p) ?? l.getSchema(t), errorMetadata: u } } catch { n.message = n.message ?? n.Message ?? "UnknownError"; let f = k.for("smithy.ts.sdk.synthetic." + c), h = f.getBaseException(); if (h) { let E = f.getErrorCtor(h) ?? Error; throw this.decorateServiceException(Object.assign(new E({ name: p }), u), n) } throw this.decorateServiceException(Object.assign(new Error(p), u), n) } } decorateServiceException(t, r = {}) { if (this.queryCompat) { let o = t.Message ?? r.Message, n = _D(t, r); o && (n.message = o), n.Error = { ...n.Error, Type: n.Error.Type, Code: n.Error.Code, Message: n.Error.message ?? n.Error.Message ?? o }; let i = n.$metadata.requestId; return i && (n.RequestId = i), n } return _D(t, r) } setQueryCompatError(t, r) { let o = r.headers?.["x-amzn-query-error"]; if (t !== void 0 && o != null) { let [n, i] = o.split(";"), a = Object.entries(t), c = { Code: n, Type: i }; Object.assign(t, c); for (let [p, u] of a) c[p === "message" ? "Message" : p] = u; delete c.__type, t.Error = c } } queryCompatOutput(t, r) { t.Error && (r.Error = t.Error), t.Type && (r.Type = t.Type), t.Code && (r.Code = t.Code) } findQueryCompatibleError(t, r) { try { return t.getSchema(r) } catch { return t.find(n => ue.of(n).getMergedTraits().awsQueryError?.[0] === r) } } } }); var M7 = s(() => { }); var $7 = s(() => { }); var uo, ra = s(() => { uo = class { serdeContext; setSerdeContext(t) { this.serdeContext = t } } }); import { Buffer as RD } from "buffer"; var ME, $E, Pf = s(() => { cr(); ME = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return RD.from(e, t, r) }, $E = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? RD.from(e, t) : RD.from(e) } }); var A5e, FE, F7 = s(() => { Pf(); A5e = /^[A-Za-z0-9+/]*={0,2}$/, FE = e => { if (e.length * 3 % 4 !== 0) throw new TypeError("Incorrect padding on base64 string."); if (!A5e.exec(e)) throw new TypeError("Invalid base64 string."); let t = $E(e, "base64"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength) } }); var U7, H7 = s(() => { Pf(); U7 = e => { let t = $E(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var G7 = s(() => { }); var UE, j7 = s(() => { Pf(); UE = e => { if (typeof e == "string") return e; if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number") throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."); return ME(e.buffer, e.byteOffset, e.byteLength).toString("utf8") } }); var HE = s(() => { H7(); G7(); j7() }); var Ec, q7 = s(() => { Pf(); HE(); Ec = e => { let t; if (typeof e == "string" ? t = U7(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return ME(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var Of = s(() => { F7(); q7() }); function* pu(e, t) { if (e.isUnitSchema()) return; let r = e.getSchema(); for (let o = 0; o < r[4].length; ++o) { let n = r[4][o], i = r[5][o], a = new ue([i, 0], n); !(n in t) && !a.isIdempotencyToken() || (yield [n, a]) } } function* V7(e, t, r) { if (e.isUnitSchema()) return; let o = e.getSchema(), n = Object.keys(t).filter(i => i !== "__type").length; for (let i = 0; i < o[4].length && n !== 0; ++i) { let a = o[4][i], c = o[5][i], p = new ue([c, 0], a), u = a; r && (u = p.getMergedTraits()[r] ?? a), u in t && (yield [a, p], n -= 1) } } var Df = s(() => { Oe() }); var uu, AD = s(() => { uu = class { from; to; keys; constructor(t, r) { this.from = t, this.to = r, this.keys = new Set(Object.keys(this.from).filter(o => o !== "__type")) } mark(t) { this.keys.delete(t) } hasUnknown() { return this.keys.size === 1 && Object.keys(this.to).length === 0 } writeUnknown() { if (this.hasUnknown()) { let t = this.keys.values().next().value, r = this.from[t]; this.to.$unknown = [t, r] } } } }); function z7(e, t, r) { if (r?.source) { let o = r.source; if (typeof t == "number" && (t > Number.MAX_SAFE_INTEGER || t < Number.MIN_SAFE_INTEGER || o !== String(t))) return o.includes(".") ? new _r(o, "bigDecimal") : BigInt(o) } return t } var W7 = s(() => { Pr() }); var K7, Q7 = s(() => { cu(); HE(); K7 = (e, t) => Do(e, t).then(r => (t?.utf8Encoder ?? UE)(r)) }); var Y7, GE, kf = s(() => { Q7(); Y7 = (e, t) => K7(e, t).then(r => { if (r.length) try { return JSON.parse(r) } catch (o) { throw o?.name === "SyntaxError" && Object.defineProperty(o, "$responseBodyText", { value: r }), o } return {} }), GE = (e, t) => { let r = (i, a) => Object.keys(i).find(c => c.toLowerCase() === a.toLowerCase()), o = i => { let a = i; return typeof a == "number" && (a = a.toString()), a.indexOf(",") >= 0 && (a = a.split(",")[0]), a.indexOf(":") >= 0 && (a = a.split(":")[0]), a.indexOf("#") >= 0 && (a = a.split("#")[1]), a }, n = r(e.headers, "x-amzn-errortype"); if (n !== void 0) return o(e.headers[n]); if (t && typeof t == "object") { let i = r(t, "code"); if (i && t[i] !== void 0) return o(t[i]); if (t.__type !== void 0) return o(t.__type) } } }); var mu, TD = s(() => { rs(); Oe(); Pr(); Of(); ra(); Df(); AD(); W7(); kf(); mu = class extends uo { settings; constructor(t) { super(), this.settings = t } async read(t, r) { return this._read(t, typeof r == "string" ? JSON.parse(r, z7) : await Y7(r, this.serdeContext)) } readObject(t, r) { return this._read(t, r) } _read(t, r) { let o = r !== null && typeof r == "object", n = ue.of(t); if (o) { if (n.isStructSchema()) { let a = n.isUnionSchema(), c = {}, p; a && (p = new uu(r, c)); for (let [u, l] of V7(n, r, this.settings.jsonName ? "jsonName" : !1)) { let m = this.settings.jsonName ? l.getMergedTraits().jsonName ?? u : u; a && p.mark(m), r[m] != null && (c[u] = this._read(l, r[m])) } return a && p.writeUnknown(), c } if (Array.isArray(r) && n.isListSchema()) { let a = n.getValueSchema(), c = [], p = !!n.getMergedTraits().sparse; for (let u of r) (p || u != null) && c.push(this._read(a, u)); return c } if (n.isMapSchema()) { let a = n.getValueSchema(), c = {}, p = !!n.getMergedTraits().sparse; for (let [u, l] of Object.entries(r)) (p || l != null) && (c[u] = this._read(a, l)); return c } } if (n.isBlobSchema() && typeof r == "string") return FE(r); let i = n.getMergedTraits().mediaType; if (n.isStringSchema() && typeof r == "string" && i) return i === "application/json" || i.endsWith("+json") ? ko.from(r) : r; if (n.isTimestampSchema() && r != null) switch (hn(n, this.settings)) { case 5: return C8(r); case 6: return hE(r); case 7: return R8(r); default: return console.warn("Missing timestamp format, parsing value with Date constructor:", r), new Date(r) }if (n.isBigIntegerSchema() && (typeof r == "number" || typeof r == "string")) return BigInt(r); if (n.isBigDecimalSchema() && r != null) { if (r instanceof _r) return r; let a = r; return a.type === "bigDecimal" && "string" in a ? new _r(a.string, a.type) : new _r(String(r), "bigDecimal") } if (n.isNumericSchema() && typeof r == "string") { switch (r) { case "Infinity": return 1 / 0; case "-Infinity": return -1 / 0; case "NaN": return NaN }return r } if (n.isDocumentSchema()) if (o) { let a = Array.isArray(r) ? [] : {}; for (let [c, p] of Object.entries(r)) p instanceof _r ? a[c] = p : a[c] = this._read(n, p); return a } else return structuredClone(r); return r } } }); var X7, jE, J7 = s(() => { Pr(); X7 = "\u039D", jE = class { values = new Map; counter = 0; stage = 0; createReplacer() { if (this.stage === 1) throw new Error("@aws-sdk/core/protocols - JsonReplacer already created."); if (this.stage === 2) throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted."); return this.stage = 1, (t, r) => { if (r instanceof _r) { let o = `${X7 + "nv" + this.counter++}_` + r.string; return this.values.set(`"${o}"`, r.string), o } if (typeof r == "bigint") { let o = r.toString(), n = `${X7 + "b" + this.counter++}_` + o; return this.values.set(`"${n}"`, o), n } return r } } replaceInJson(t) { if (this.stage === 0) throw new Error("@aws-sdk/core/protocols - JsonReplacer not created yet."); if (this.stage === 2) throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted."); if (this.stage = 2, this.counter === 0) return t; for (let [r, o] of this.values) t = t.replace(r, o); return t } } }); var lu, wD = s(() => { rs(); Oe(); Pr(); Of(); ra(); Df(); J7(); lu = class extends uo { settings; buffer; useReplacer = !1; rootSchema; constructor(t) { super(), this.settings = t } write(t, r) { this.rootSchema = ue.of(t), this.buffer = this._write(this.rootSchema, r) } writeDiscriminatedDocument(t, r) { this.write(t, r), typeof this.buffer == "object" && (this.buffer.__type = ue.of(t).getName(!0)) } flush() { let { rootSchema: t, useReplacer: r } = this; if (this.rootSchema = void 0, this.useReplacer = !1, t?.isStructSchema() || t?.isDocumentSchema()) { if (!r) return JSON.stringify(this.buffer); let o = new jE; return o.replaceInJson(JSON.stringify(this.buffer, o.createReplacer(), 0)) } return this.buffer } _write(t, r, o) { let n = r !== null && typeof r == "object", i = ue.of(t); if (n) { if (i.isStructSchema()) { let a = {}; for (let [c, p] of pu(i, r)) { let u = this._write(p, r[c], i); if (u !== void 0) { let l = p.getMergedTraits().jsonName, m = this.settings.jsonName ? l ?? c : c; a[m] = u } } if (i.isUnionSchema() && Object.keys(a).length === 0) { let { $unknown: c } = r; if (Array.isArray(c)) { let [p, u] = c; a[p] = this._write(15, u) } } return a } if (Array.isArray(r) && i.isListSchema()) { let a = i.getValueSchema(), c = [], p = !!i.getMergedTraits().sparse; for (let u of r) (p || u != null) && c.push(this._write(a, u)); return c } if (i.isMapSchema()) { let a = i.getValueSchema(), c = {}, p = !!i.getMergedTraits().sparse; for (let [u, l] of Object.entries(r)) (p || l != null) && (c[u] = this._write(a, l)); return c } if (r instanceof Uint8Array && (i.isBlobSchema() || i.isDocumentSchema())) return i === this.rootSchema ? r : (this.serdeContext?.base64Encoder ?? Ec)(r); if (r instanceof Date && (i.isTimestampSchema() || i.isDocumentSchema())) switch (hn(i, this.settings)) { case 5: return r.toISOString().replace(".000Z", "Z"); case 6: return hi(r); case 7: return r.getTime() / 1e3; default: return console.warn("Missing timestamp format, using epoch seconds", r), r.getTime() / 1e3 }r instanceof _r && (this.useReplacer = !0) } if (!(r === null && o?.isStructSchema())) { if (i.isStringSchema()) { if (typeof r > "u" && i.isIdempotencyToken()) return ro(); let a = i.getMergedTraits().mediaType; return r != null && a && (a === "application/json" || a.endsWith("+json")) ? ko.from(r) : r } if (typeof r == "number" && i.isNumericSchema()) return Math.abs(r) === 1 / 0 || isNaN(r) ? String(r) : r; if (typeof r == "string" && i.isBlobSchema()) return i === this.rootSchema ? r : (this.serdeContext?.base64Encoder ?? Ec)(r); if (typeof r == "bigint" && (this.useReplacer = !0), i.isDocumentSchema()) if (n) { let a = Array.isArray(r) ? [] : {}; for (let [c, p] of Object.entries(r)) p instanceof _r ? (this.useReplacer = !0, a[c] = p) : a[c] = this._write(i, p); return a } else return structuredClone(r); return r } } } }); var oa, qE = s(() => { ra(); TD(); wD(); oa = class extends uo { settings; constructor(t) { super(), this.settings = t } createSerializer() { let t = new lu(this.settings); return t.setSerdeContext(this.serdeContext), t } createDeserializer() { let t = new mu(this.settings); return t.setSerdeContext(this.serdeContext), t } } }); var VE, bD = s(() => { rs(); Oe(); vf(); qE(); kf(); VE = class extends Xp { serializer; deserializer; serviceTarget; codec; mixin; awsQueryCompatible; constructor({ defaultNamespace: t, serviceTarget: r, awsQueryCompatible: o, jsonCodec: n }) { super({ defaultNamespace: t }), this.serviceTarget = r, this.codec = n ?? new oa({ timestampFormat: { useTrait: !0, default: 7 }, jsonName: !1 }), this.serializer = this.codec.createSerializer(), this.deserializer = this.codec.createDeserializer(), this.awsQueryCompatible = !!o, this.mixin = new vs(this.awsQueryCompatible) } async serializeRequest(t, r, o) { let n = await super.serializeRequest(t, r, o); return n.path.endsWith("/") || (n.path += "/"), Object.assign(n.headers, { "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`, "x-amz-target": `${this.serviceTarget}.${t.name}` }), this.awsQueryCompatible && (n.headers["x-amzn-query-mode"] = "true"), (Zi(t.input) === "unit" || !n.body) && (n.body = "{}"), n } getPayloadCodec() { return this.codec } async handleError(t, r, o, n, i) { this.awsQueryCompatible && this.mixin.setQueryCompatError(n, o); let a = GE(o, n) ?? "Unknown", { errorSchema: c, errorMetadata: p } = await this.mixin.getErrorSchemaOrThrowBaseException(a, this.options.defaultNamespace, o, n, i, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : void 0), u = ue.of(c), l = n.message ?? n.Message ?? "Unknown", m = k.for(c[1]).getErrorCtor(c) ?? Error, f = new m(l), h = {}; for (let [E, S] of u.structIterator()) n[E] != null && (h[E] = this.codec.createDeserializer().readObject(S, n[E])); throw this.awsQueryCompatible && this.mixin.queryCompatOutput(n, h), this.mixin.decorateServiceException(Object.assign(f, p, { $fault: u.getMergedTraits().error, message: l }, h), n) } } }); var du, Z7 = s(() => { bD(); du = class extends VE { constructor({ defaultNamespace: t, serviceTarget: r, awsQueryCompatible: o, jsonCodec: n }) { super({ defaultNamespace: t, serviceTarget: r, awsQueryCompatible: o, jsonCodec: n }) } getShapeId() { return "aws.protocols#awsJson1_0" } getJsonRpcVersion() { return "1.0" } getDefaultContentType() { return "application/x-amz-json-1.0" } } }); var eY = s(() => { }); var En, tY = s(() => { rs(); Oe(); vf(); qE(); kf(); En = class extends Yp { serializer; deserializer; codec; mixin = new vs; constructor({ defaultNamespace: t }) { super({ defaultNamespace: t }); let r = { timestampFormat: { useTrait: !0, default: 7 }, httpBindings: !0, jsonName: !0 }; this.codec = new oa(r), this.serializer = new eu(this.codec.createSerializer(), r), this.deserializer = new Zp(this.codec.createDeserializer(), r) } getShapeId() { return "aws.protocols#restJson1" } getPayloadCodec() { return this.codec } setSerdeContext(t) { this.codec.setSerdeContext(t), super.setSerdeContext(t) } async serializeRequest(t, r, o) { let n = await super.serializeRequest(t, r, o), i = ue.of(t.input); if (!n.headers["content-type"]) { let a = this.mixin.resolveRestContentType(this.getDefaultContentType(), i); a && (n.headers["content-type"] = a) } return n.body == null && n.headers["content-type"] === this.getDefaultContentType() && (n.body = "{}"), n } async deserializeResponse(t, r, o) { let n = await super.deserializeResponse(t, r, o), i = ue.of(t.output); for (let [a, c] of i.structIterator()) c.getMemberTraits().httpPayload && !(a in n) && (n[a] = null); return n } async handleError(t, r, o, n, i) { let a = GE(o, n) ?? "Unknown", { errorSchema: c, errorMetadata: p } = await this.mixin.getErrorSchemaOrThrowBaseException(a, this.options.defaultNamespace, o, n, i), u = ue.of(c), l = n.message ?? n.Message ?? "Unknown", m = k.for(c[1]).getErrorCtor(c) ?? Error, f = new m(l); await this.deserializeHttpMessage(c, r, o, n); let h = {}; for (let [E, S] of u.structIterator()) { let y = S.getMergedTraits().jsonName ?? E; h[E] = this.codec.createDeserializer().readObject(S, n[y]) } throw this.mixin.decorateServiceException(Object.assign(f, p, { $fault: u.getMergedTraits().error, message: l }, h), n) } getDefaultContentType() { return "application/json" } } }); var rY = s(() => { }); function oY(e) { return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") } var nY = s(() => { }); function sY(e) { return e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;") } var iY = s(() => { }); var yc, ID = s(() => { iY(); yc = class { value; constructor(t) { this.value = t } toString() { return sY("" + this.value) } } }); var Bo, aY = s(() => { nY(); ID(); Bo = class e { name; children; attributes = {}; static of(t, r, o) { let n = new e(t); return r !== void 0 && n.addChildNode(new yc(r)), o !== void 0 && n.withName(o), n } constructor(t, r = []) { this.name = t, this.children = r } withName(t) { return this.name = t, this } addAttribute(t, r) { return this.attributes[t] = r, this } addChildNode(t) { return this.children.push(t), this } removeAttribute(t) { return delete this.attributes[t], this } n(t) { return this.name = t, this } c(t) { return this.children.push(t), this } a(t, r) { return r != null && (this.attributes[t] = r), this } cc(t, r, o = r) { if (t[r] != null) { let n = e.of(r, t[r]).withName(o); this.c(n) } } l(t, r, o, n) { t[r] != null && n().map(a => { a.withName(o), this.c(a) }) } lc(t, r, o, n) { if (t[r] != null) { let i = n(), a = new e(o); i.map(c => { a.c(c) }), this.c(a) } } toString() { let t = !!this.children.length, r = `<${this.name}`, o = this.attributes; for (let n of Object.keys(o)) { let i = o[n]; i != null && (r += ` ${n}="${oY("" + i)}"`) } return r += t ? `>${this.children.map(n => n.toString()).join("")}</${this.name}>` : "/>" } } }); function zE(e, t) { let r = [], o = t.exec(e); for (; o;) { let n = []; n.startIndex = t.lastIndex - o[0].length; let i = o.length; for (let a = 0; a < i; a++)n.push(o[a]); r.push(n), o = t.exec(e) } return r } function pY(e) { return typeof e < "u" } var cY, T5e, w5e, b5e, Nf, WE = s(() => { "use strict"; cY = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", T5e = cY + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", w5e = "[" + cY + "][" + T5e + "]*", b5e = new RegExp("^" + w5e + "$"); Nf = function (e) { let t = b5e.exec(e); return !(t === null || typeof t > "u") } }); function fY(e, t) {
  t = Object.assign({}, I5e, t); let r = [], o = !1, n = !1; e[0] === "\uFEFF" && (e = e.substr(1)); for (let i = 0; i < e.length; i++)if (e[i] === "<" && e[i + 1] === "?") { if (i += 2, i = mY(e, i), i.err) return i } else if (e[i] === "<") {
    let a = i; if (i++, e[i] === "!") { i = lY(e, i); continue } else {
      let c = !1; e[i] === "/" && (c = !0, i++); let p = ""; for (; i < e.length && e[i] !== ">" && e[i] !== " " && e[i] !== "	" && e[i] !== `
`&& e[i] !== "\r"; i++)p += e[i]; if (p = p.trim(), p[p.length - 1] === "/" && (p = p.substring(0, p.length - 1), i--), !L5e(p)) { let m; return p.trim().length === 0 ? m = "Invalid space after '<'." : m = "Tag '" + p + "' is an invalid name.", pr("InvalidTag", m, So(e, i)) } let u = O5e(e, i); if (u === !1) return pr("InvalidAttr", "Attributes for '" + p + "' have open quote.", So(e, i)); let l = u.value; if (i = u.index, l[l.length - 1] === "/") { let m = i - l.length; l = l.substring(0, l.length - 1); let f = dY(l, t); if (f === !0) o = !0; else return pr(f.err.code, f.err.msg, So(e, m + f.err.line)) } else if (c) if (u.tagClosed) { if (l.trim().length > 0) return pr("InvalidTag", "Closing tag '" + p + "' can't have attributes or invalid starting.", So(e, a)); if (r.length === 0) return pr("InvalidTag", "Closing tag '" + p + "' has not been opened.", So(e, a)); { let m = r.pop(); if (p !== m.tagName) { let f = So(e, m.tagStartPos); return pr("InvalidTag", "Expected closing tag '" + m.tagName + "' (opened in line " + f.line + ", col " + f.col + ") instead of closing tag '" + p + "'.", So(e, a)) } r.length == 0 && (n = !0) } } else return pr("InvalidTag", "Closing tag '" + p + "' doesn't have proper closing.", So(e, i)); else { let m = dY(l, t); if (m !== !0) return pr(m.err.code, m.err.msg, So(e, i - l.length + m.err.line)); if (n === !0) return pr("InvalidXml", "Multiple possible root nodes found.", So(e, i)); t.unpairedTags.indexOf(p) !== -1 || r.push({ tagName: p, tagStartPos: a }), o = !0 } for (i++; i < e.length; i++)if (e[i] === "<") if (e[i + 1] === "!") { i++, i = lY(e, i); continue } else if (e[i + 1] === "?") { if (i = mY(e, ++i), i.err) return i } else break; else if (e[i] === "&") { let m = N5e(e, i); if (m == -1) return pr("InvalidChar", "char '&' is not expected.", So(e, i)); i = m } else if (n === !0 && !uY(e[i])) return pr("InvalidXml", "Extra text at the end", So(e, i)); e[i] === "<" && i--
    }
  } else { if (uY(e[i])) continue; return pr("InvalidChar", "char '" + e[i] + "' is not expected.", So(e, i)) } if (o) { if (r.length == 1) return pr("InvalidTag", "Unclosed tag '" + r[0].tagName + "'.", So(e, r[0].tagStartPos)); if (r.length > 0) return pr("InvalidXml", "Invalid '" + JSON.stringify(r.map(i => i.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) } else return pr("InvalidXml", "Start tag expected.", 1); return !0
} function uY(e) {
  return e === " " || e === "	" || e === `
`|| e === "\r"
} function mY(e, t) { let r = t; for (; t < e.length; t++)if (e[t] == "?" || e[t] == " ") { let o = e.substr(r, t - r); if (t > 5 && o === "xml") return pr("InvalidXml", "XML declaration allowed only at the start of the document.", So(e, t)); if (e[t] == "?" && e[t + 1] == ">") { t++; break } else continue } return t } function lY(e, t) { if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") { for (t += 3; t < e.length; t++)if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") { t += 2; break } } else if (e.length > t + 8 && e[t + 1] === "D" && e[t + 2] === "O" && e[t + 3] === "C" && e[t + 4] === "T" && e[t + 5] === "Y" && e[t + 6] === "P" && e[t + 7] === "E") { let r = 1; for (t += 8; t < e.length; t++)if (e[t] === "<") r++; else if (e[t] === ">" && (r--, r === 0)) break } else if (e.length > t + 9 && e[t + 1] === "[" && e[t + 2] === "C" && e[t + 3] === "D" && e[t + 4] === "A" && e[t + 5] === "T" && e[t + 6] === "A" && e[t + 7] === "[") { for (t += 8; t < e.length; t++)if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") { t += 2; break } } return t } function O5e(e, t) { let r = "", o = "", n = !1; for (; t < e.length; t++) { if (e[t] === v5e || e[t] === P5e) o === "" ? o = e[t] : o !== e[t] || (o = ""); else if (e[t] === ">" && o === "") { n = !0; break } r += e[t] } return o !== "" ? !1 : { value: r, index: t, tagClosed: n } } function dY(e, t) { let r = zE(e, D5e), o = {}; for (let n = 0; n < r.length; n++) { if (r[n][1].length === 0) return pr("InvalidAttr", "Attribute '" + r[n][2] + "' has no space in starting.", Bf(r[n])); if (r[n][3] !== void 0 && r[n][4] === void 0) return pr("InvalidAttr", "Attribute '" + r[n][2] + "' is without value.", Bf(r[n])); if (r[n][3] === void 0 && !t.allowBooleanAttributes) return pr("InvalidAttr", "boolean attribute '" + r[n][2] + "' is not allowed.", Bf(r[n])); let i = r[n][2]; if (!B5e(i)) return pr("InvalidAttr", "Attribute '" + i + "' is an invalid name.", Bf(r[n])); if (!o.hasOwnProperty(i)) o[i] = 1; else return pr("InvalidAttr", "Attribute '" + i + "' is repeated.", Bf(r[n])) } return !0 } function k5e(e, t) { let r = /\d/; for (e[t] === "x" && (t++, r = /[\da-fA-F]/); t < e.length; t++) { if (e[t] === ";") return t; if (!e[t].match(r)) break } return -1 } function N5e(e, t) { if (t++, e[t] === ";") return -1; if (e[t] === "#") return t++, k5e(e, t); let r = 0; for (; t < e.length; t++, r++)if (!(e[t].match(/\w/) && r < 20)) { if (e[t] === ";") break; return -1 } return t } function pr(e, t, r) { return { err: { code: e, msg: t, line: r.line || r, col: r.col } } } function B5e(e) { return Nf(e) } function L5e(e) { return Nf(e) } function So(e, t) { let r = e.substring(0, t).split(/\r?\n/); return { line: r.length, col: r[r.length - 1].length + 1 } } function Bf(e) { return e.startIndex + e[1].length } var I5e, v5e, P5e, D5e, hY = s(() => { "use strict"; WE(); I5e = { allowBooleanAttributes: !1, unpairedTags: [] }; v5e = '"', P5e = "'"; D5e = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g") }); var M5e, gY, xY = s(() => { M5e = { preserveOrder: !1, attributeNamePrefix: "@_", attributesGroupName: !1, textNodeName: "#text", ignoreAttributes: !0, removeNSPrefix: !1, allowBooleanAttributes: !1, parseTagValue: !0, parseAttributeValue: !1, trimValues: !0, cdataPropName: !1, numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 }, tagValueProcessor: function (e, t) { return t }, attributeValueProcessor: function (e, t) { return t }, stopNodes: [], alwaysCreateTextNode: !1, isArray: () => !1, commentPropName: !1, unpairedTags: [], processEntities: !0, htmlEntities: !1, ignoreDeclaration: !1, ignorePiTags: !1, transformTagName: !1, transformAttributeName: !1, updateTag: function (e, t, r) { return e }, captureMetaData: !1 }, gY = function (e) { return Object.assign({}, M5e, e) } }); var KE, Qo, QE = s(() => { "use strict"; typeof Symbol != "function" ? KE = "@@xmlMetadata" : KE = Symbol("XML Node Metadata"); Qo = class { constructor(t) { this.tagname = t, this.child = [], this[":@"] = {} } add(t, r) { t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: r }) } addChild(t, r) { t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child }), r !== void 0 && (this.child[this.child.length - 1][KE] = { startIndex: r }) } static getMetaDataSymbol() { return KE } } }); function vD(e, t) { let r = {}; if (e[t + 3] === "O" && e[t + 4] === "C" && e[t + 5] === "T" && e[t + 6] === "Y" && e[t + 7] === "P" && e[t + 8] === "E") { t = t + 9; let o = 1, n = !1, i = !1, a = ""; for (; t < e.length; t++)if (e[t] === "<" && !i) { if (n && Sc(e, "!ENTITY", t)) { t += 7; let c, p;[c, p, t] = $5e(e, t + 1), p.indexOf("&") === -1 && (r[c] = { regx: RegExp(`&${c};`, "g"), val: p }) } else if (n && Sc(e, "!ELEMENT", t)) { t += 8; let { index: c } = U5e(e, t + 1); t = c } else if (n && Sc(e, "!ATTLIST", t)) t += 8; else if (n && Sc(e, "!NOTATION", t)) { t += 9; let { index: c } = F5e(e, t + 1); t = c } else if (Sc(e, "!--", t)) i = !0; else throw new Error("Invalid DOCTYPE"); o++, a = "" } else if (e[t] === ">") { if (i ? e[t - 1] === "-" && e[t - 2] === "-" && (i = !1, o--) : o--, o === 0) break } else e[t] === "[" ? n = !0 : a += e[t]; if (o !== 0) throw new Error("Unclosed DOCTYPE") } else throw new Error("Invalid Tag instead of DOCTYPE"); return { entities: r, i: t } } function $5e(e, t) { t = na(e, t); let r = ""; for (; t < e.length && !/\s/.test(e[t]) && e[t] !== '"' && e[t] !== "'";)r += e[t], t++; if (PD(r), t = na(e, t), e.substring(t, t + 6).toUpperCase() === "SYSTEM") throw new Error("External entities are not supported"); if (e[t] === "%") throw new Error("Parameter entities are not supported"); let o = ""; return [t, o] = YE(e, t, "entity"), t--, [r, o, t] } function F5e(e, t) { t = na(e, t); let r = ""; for (; t < e.length && !/\s/.test(e[t]);)r += e[t], t++; PD(r), t = na(e, t); let o = e.substring(t, t + 6).toUpperCase(); if (o !== "SYSTEM" && o !== "PUBLIC") throw new Error(`Expected SYSTEM or PUBLIC, found "${o}"`); t += o.length, t = na(e, t); let n = null, i = null; if (o === "PUBLIC") [t, n] = YE(e, t, "publicIdentifier"), t = na(e, t), (e[t] === '"' || e[t] === "'") && ([t, i] = YE(e, t, "systemIdentifier")); else if (o === "SYSTEM" && ([t, i] = YE(e, t, "systemIdentifier"), !i)) throw new Error("Missing mandatory system identifier for SYSTEM notation"); return { notationName: r, publicIdentifier: n, systemIdentifier: i, index: --t } } function YE(e, t, r) { let o = "", n = e[t]; if (n !== '"' && n !== "'") throw new Error(`Expected quoted string, found "${n}"`); for (t++; t < e.length && e[t] !== n;)o += e[t], t++; if (e[t] !== n) throw new Error(`Unterminated ${r} value`); return t++, [t, o] } function U5e(e, t) { t = na(e, t); let r = ""; for (; t < e.length && !/\s/.test(e[t]);)r += e[t], t++; if (!PD(r)) throw new Error(`Invalid element name: "${r}"`); t = na(e, t); let o = ""; if (e[t] === "E" && Sc(e, "MPTY", t)) t += 4; else if (e[t] === "A" && Sc(e, "NY", t)) t += 2; else if (e[t] === "(") { for (t++; t < e.length && e[t] !== ")";)o += e[t], t++; if (e[t] !== ")") throw new Error("Unterminated content model") } else throw new Error(`Invalid Element Expression, found "${e[t]}"`); return { elementName: r, contentModel: o.trim(), index: t } } function Sc(e, t, r) { for (let o = 0; o < t.length; o++)if (t[o] !== e[r + o + 1]) return !1; return !0 } function PD(e) { if (Nf(e)) return e; throw new Error(`Invalid entity name ${e}`) } var na, EY = s(() => { WE(); na = (e, t) => { for (; t < e.length && /\s/.test(e[t]);)t++; return t } }); function OD(e, t = {}) { if (t = Object.assign({}, j5e, t), !e || typeof e != "string") return e; let r = e.trim(); if (t.skipLike !== void 0 && t.skipLike.test(r)) return e; if (e === "0") return 0; if (t.hex && H5e.test(r)) return W5e(r, 16); if (r.includes("e") || r.includes("E")) return V5e(e, r, t); { let o = G5e.exec(r); if (o) { let n = o[1] || "", i = o[2], a = z5e(o[3]), c = n ? e[i.length + 1] === "." : e[i.length] === "."; if (!t.leadingZeros && (i.length > 1 || i.length === 1 && !c)) return e; { let p = Number(r), u = String(p); if (p === 0) return p; if (u.search(/[eE]/) !== -1) return t.eNotation ? p : e; if (r.indexOf(".") !== -1) return u === "0" || u === a || u === `${n}${a}` ? p : e; let l = i ? a : r; return i ? l === u || n + l === u ? p : e : l === u || l === n + u ? p : e } } else return e } } function V5e(e, t, r) { if (!r.eNotation) return e; let o = t.match(q5e); if (o) { let n = o[1] || "", i = o[3].indexOf("e") === -1 ? "E" : "e", a = o[2], c = n ? e[a.length + 1] === i : e[a.length] === i; return a.length > 1 && c ? e : a.length === 1 && (o[3].startsWith(`.${i}`) || o[3][0] === i) ? Number(t) : r.leadingZeros && !c ? (t = (o[1] || "") + o[3], Number(t)) : e } else return e } function z5e(e) { return e && e.indexOf(".") !== -1 && (e = e.replace(/0+$/, ""), e === "." ? e = "0" : e[0] === "." ? e = "0" + e : e[e.length - 1] === "." && (e = e.substring(0, e.length - 1))), e } function W5e(e, t) { if (parseInt) return parseInt(e, t); if (Number.parseInt) return Number.parseInt(e, t); if (window && window.parseInt) return window.parseInt(e, t); throw new Error("parseInt, Number.parseInt, window.parseInt are not supported") } var H5e, G5e, j5e, q5e, yY = s(() => { H5e = /^[-+]?0x[a-fA-F0-9]+$/, G5e = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, j5e = { hex: !0, leadingZeros: !0, decimalPoint: ".", eNotation: !0 }; q5e = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/ }); function DD(e) { return typeof e == "function" ? e : Array.isArray(e) ? t => { for (let r of e) if (typeof r == "string" && t === r || r instanceof RegExp && r.test(t)) return !0 } : () => !1 } var SY = s(() => { }); function K5e(e) { let t = Object.keys(e); for (let r = 0; r < t.length; r++) { let o = t[r]; this.lastEntities[o] = { regex: new RegExp("&" + o + ";", "g"), val: e[o] } } } function Q5e(e, t, r, o, n, i, a) { if (e !== void 0 && (this.options.trimValues && !o && (e = e.trim()), e.length > 0)) { a || (e = this.replaceEntitiesValue(e)); let c = this.options.tagValueProcessor(t, e, r, n, i); return c == null ? e : typeof c != typeof e || c !== e ? c : this.options.trimValues ? ND(e, this.options.parseTagValue, this.options.numberParseOptions) : e.trim() === e ? ND(e, this.options.parseTagValue, this.options.numberParseOptions) : e } } function Y5e(e) { if (this.options.removeNSPrefix) { let t = e.split(":"), r = e.charAt(0) === "/" ? "/" : ""; if (t[0] === "xmlns") return ""; t.length === 2 && (e = r + t[1]) } return e } function J5e(e, t, r) { if (this.options.ignoreAttributes !== !0 && typeof e == "string") { let o = zE(e, X5e), n = o.length, i = {}; for (let a = 0; a < n; a++) { let c = this.resolveNameSpace(o[a][1]); if (this.ignoreAttributesFn(c, t)) continue; let p = o[a][4], u = this.options.attributeNamePrefix + c; if (c.length) if (this.options.transformAttributeName && (u = this.options.transformAttributeName(u)), u === "__proto__" && (u = "#__proto__"), p !== void 0) { this.options.trimValues && (p = p.trim()), p = this.replaceEntitiesValue(p); let l = this.options.attributeValueProcessor(c, p, t); l == null ? i[u] = p : typeof l != typeof p || l !== p ? i[u] = l : i[u] = ND(p, this.options.parseAttributeValue, this.options.numberParseOptions) } else this.options.allowBooleanAttributes && (i[u] = !0) } if (!Object.keys(i).length) return; if (this.options.attributesGroupName) { let a = {}; return a[this.options.attributesGroupName] = i, a } return i } } function e9e(e, t, r, o) { this.options.captureMetaData || (o = void 0); let n = this.options.updateTag(t.tagname, r, t[":@"]); n === !1 || (typeof n == "string" && (t.tagname = n), e.addChild(t, o)) } function r9e(e, t, r, o) { return e && (o === void 0 && (o = t.child.length === 0), e = this.parseTextData(e, t.tagname, r, !1, t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1, o), e !== void 0 && e !== "" && t.add(this.options.textNodeName, e), e = ""), e } function o9e(e, t, r) { let o = "*." + r; for (let n in e) { let i = e[n]; if (o === i || t === i) return !0 } return !1 } function n9e(e, t, r = ">") { let o, n = ""; for (let i = t; i < e.length; i++) { let a = e[i]; if (o) a === o && (o = ""); else if (a === '"' || a === "'") o = a; else if (a === r[0]) if (r[1]) { if (e[i + 1] === r[1]) return { data: n, index: i } } else return { data: n, index: i }; else a === "	" && (a = " "); n += a } } function _c(e, t, r, o) { let n = e.indexOf(t, r); if (n === -1) throw new Error(o); return n + t.length - 1 } function kD(e, t, r, o = ">") { let n = n9e(e, t + 1, o); if (!n) return; let i = n.data, a = n.index, c = i.search(/\s/), p = i, u = !0; c !== -1 && (p = i.substring(0, c), i = i.substring(c + 1).trimStart()); let l = p; if (r) { let m = p.indexOf(":"); m !== -1 && (p = p.substr(m + 1), u = p !== n.data.substr(m + 1)) } return { tagName: p, tagExp: i, closeIndex: a, attrExpPresent: u, rawTagName: l } } function s9e(e, t, r) { let o = r, n = 1; for (; r < e.length; r++)if (e[r] === "<") if (e[r + 1] === "/") { let i = _c(e, ">", r, `${t} is not closed`); if (e.substring(r + 2, i).trim() === t && (n--, n === 0)) return { tagContent: e.substring(o, r), i }; r = i } else if (e[r + 1] === "?") r = _c(e, "?>", r + 1, "StopNode is not closed."); else if (e.substr(r + 1, 3) === "!--") r = _c(e, "-->", r + 3, "StopNode is not closed."); else if (e.substr(r + 1, 2) === "![") r = _c(e, "]]>", r, "StopNode is not closed.") - 2; else { let i = kD(e, r, ">"); i && ((i && i.tagName) === t && i.tagExp[i.tagExp.length - 1] !== "/" && n++, r = i.closeIndex) } } function ND(e, t, r) { if (t && typeof e == "string") { let o = e.trim(); return o === "true" ? !0 : o === "false" ? !1 : OD(e, r) } else return pY(e) ? e : "" } var Lf, X5e, Z5e, t9e, _Y = s(() => {
  "use strict"; WE(); QE(); EY(); yY(); SY(); Lf = class { constructor(t) { this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "\xA2" }, pound: { regex: /&(pound|#163);/g, val: "\xA3" }, yen: { regex: /&(yen|#165);/g, val: "\xA5" }, euro: { regex: /&(euro|#8364);/g, val: "\u20AC" }, copyright: { regex: /&(copy|#169);/g, val: "\xA9" }, reg: { regex: /&(reg|#174);/g, val: "\xAE" }, inr: { regex: /&(inr|#8377);/g, val: "\u20B9" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (r, o) => String.fromCodePoint(Number.parseInt(o, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (r, o) => String.fromCodePoint(Number.parseInt(o, 16)) } }, this.addExternalEntities = K5e, this.parseXml = Z5e, this.parseTextData = Q5e, this.resolveNameSpace = Y5e, this.buildAttributesMap = J5e, this.isItStopNode = o9e, this.replaceEntitiesValue = t9e, this.readStopNodeData = s9e, this.saveTextToParentTag = r9e, this.addChild = e9e, this.ignoreAttributesFn = DD(this.options.ignoreAttributes) } }; X5e = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm"); Z5e = function (e) {
    e = e.replace(/\r\n?/g, `
`); let t = new Qo("!xml"), r = t, o = "", n = ""; for (let i = 0; i < e.length; i++)if (e[i] === "<") if (e[i + 1] === "/") { let c = _c(e, ">", i, "Closing Tag is not closed."), p = e.substring(i + 2, c).trim(); if (this.options.removeNSPrefix) { let m = p.indexOf(":"); m !== -1 && (p = p.substr(m + 1)) } this.options.transformTagName && (p = this.options.transformTagName(p)), r && (o = this.saveTextToParentTag(o, r, n)); let u = n.substring(n.lastIndexOf(".") + 1); if (p && this.options.unpairedTags.indexOf(p) !== -1) throw new Error(`Unpaired tag can not be used as closing tag: </${p}>`); let l = 0; u && this.options.unpairedTags.indexOf(u) !== -1 ? (l = n.lastIndexOf(".", n.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l = n.lastIndexOf("."), n = n.substring(0, l), r = this.tagsNodeStack.pop(), o = "", i = c } else if (e[i + 1] === "?") { let c = kD(e, i, !1, "?>"); if (!c) throw new Error("Pi Tag is not closed."); if (o = this.saveTextToParentTag(o, r, n), !(this.options.ignoreDeclaration && c.tagName === "?xml" || this.options.ignorePiTags)) { let p = new Qo(c.tagName); p.add(this.options.textNodeName, ""), c.tagName !== c.tagExp && c.attrExpPresent && (p[":@"] = this.buildAttributesMap(c.tagExp, n, c.tagName)), this.addChild(r, p, n, i) } i = c.closeIndex + 1 } else if (e.substr(i + 1, 3) === "!--") { let c = _c(e, "-->", i + 4, "Comment is not closed."); if (this.options.commentPropName) { let p = e.substring(i + 4, c - 2); o = this.saveTextToParentTag(o, r, n), r.add(this.options.commentPropName, [{ [this.options.textNodeName]: p }]) } i = c } else if (e.substr(i + 1, 2) === "!D") { let c = vD(e, i); this.docTypeEntities = c.entities, i = c.i } else if (e.substr(i + 1, 2) === "![") { let c = _c(e, "]]>", i, "CDATA is not closed.") - 2, p = e.substring(i + 9, c); o = this.saveTextToParentTag(o, r, n); let u = this.parseTextData(p, r.tagname, n, !0, !1, !0, !0); u == null && (u = ""), this.options.cdataPropName ? r.add(this.options.cdataPropName, [{ [this.options.textNodeName]: p }]) : r.add(this.options.textNodeName, u), i = c + 2 } else { let c = kD(e, i, this.options.removeNSPrefix), p = c.tagName, u = c.rawTagName, l = c.tagExp, m = c.attrExpPresent, f = c.closeIndex; this.options.transformTagName && (p = this.options.transformTagName(p)), r && o && r.tagname !== "!xml" && (o = this.saveTextToParentTag(o, r, n, !1)); let h = r; h && this.options.unpairedTags.indexOf(h.tagname) !== -1 && (r = this.tagsNodeStack.pop(), n = n.substring(0, n.lastIndexOf("."))), p !== t.tagname && (n += n ? "." + p : p); let E = i; if (this.isItStopNode(this.options.stopNodes, n, p)) { let S = ""; if (l.length > 0 && l.lastIndexOf("/") === l.length - 1) p[p.length - 1] === "/" ? (p = p.substr(0, p.length - 1), n = n.substr(0, n.length - 1), l = p) : l = l.substr(0, l.length - 1), i = c.closeIndex; else if (this.options.unpairedTags.indexOf(p) !== -1) i = c.closeIndex; else { let C = this.readStopNodeData(e, u, f + 1); if (!C) throw new Error(`Unexpected end of ${u}`); i = C.i, S = C.tagContent } let y = new Qo(p); p !== l && m && (y[":@"] = this.buildAttributesMap(l, n, p)), S && (S = this.parseTextData(S, p, n, !0, m, !0, !0)), n = n.substr(0, n.lastIndexOf(".")), y.add(this.options.textNodeName, S), this.addChild(r, y, n, E) } else { if (l.length > 0 && l.lastIndexOf("/") === l.length - 1) { p[p.length - 1] === "/" ? (p = p.substr(0, p.length - 1), n = n.substr(0, n.length - 1), l = p) : l = l.substr(0, l.length - 1), this.options.transformTagName && (p = this.options.transformTagName(p)); let S = new Qo(p); p !== l && m && (S[":@"] = this.buildAttributesMap(l, n, p)), this.addChild(r, S, n, E), n = n.substr(0, n.lastIndexOf(".")) } else { let S = new Qo(p); this.tagsNodeStack.push(r), p !== l && m && (S[":@"] = this.buildAttributesMap(l, n, p)), this.addChild(r, S, n, E), r = S } o = "", i = f } } else o += e[i]; return t.child
  }; t9e = function (e) { if (this.options.processEntities) { for (let t in this.docTypeEntities) { let r = this.docTypeEntities[t]; e = e.replace(r.regx, r.val) } for (let t in this.lastEntities) { let r = this.lastEntities[t]; e = e.replace(r.regex, r.val) } if (this.options.htmlEntities) for (let t in this.htmlEntities) { let r = this.htmlEntities[t]; e = e.replace(r.regex, r.val) } e = e.replace(this.ampEntity.regex, this.ampEntity.val) } return e }
}); function LD(e, t) { return CY(e, t) } function CY(e, t, r) { let o, n = {}; for (let i = 0; i < e.length; i++) { let a = e[i], c = i9e(a), p = ""; if (r === void 0 ? p = c : p = r + "." + c, c === t.textNodeName) o === void 0 ? o = a[c] : o += "" + a[c]; else { if (c === void 0) continue; if (a[c]) { let u = CY(a[c], t, p), l = c9e(u, t); a[BD] !== void 0 && (u[BD] = a[BD]), a[":@"] ? a9e(u, a[":@"], p, t) : Object.keys(u).length === 1 && u[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? u = u[t.textNodeName] : Object.keys(u).length === 0 && (t.alwaysCreateTextNode ? u[t.textNodeName] = "" : u = ""), n[c] !== void 0 && n.hasOwnProperty(c) ? (Array.isArray(n[c]) || (n[c] = [n[c]]), n[c].push(u)) : t.isArray(c, p, l) ? n[c] = [u] : n[c] = u } } } return typeof o == "string" ? o.length > 0 && (n[t.textNodeName] = o) : o !== void 0 && (n[t.textNodeName] = o), n } function i9e(e) { let t = Object.keys(e); for (let r = 0; r < t.length; r++) { let o = t[r]; if (o !== ":@") return o } } function a9e(e, t, r, o) { if (t) { let n = Object.keys(t), i = n.length; for (let a = 0; a < i; a++) { let c = n[a]; o.isArray(c, r + "." + c, !0, !0) ? e[c] = [t[c]] : e[c] = t[c] } } } function c9e(e, t) { let { textNodeName: r } = t, o = Object.keys(e).length; return !!(o === 0 || o === 1 && (e[r] || typeof e[r] == "boolean" || e[r] === 0)) } var BD, RY = s(() => { "use strict"; QE(); BD = Qo.getMetaDataSymbol() }); var fu, AY = s(() => { xY(); _Y(); RY(); hY(); QE(); fu = class { constructor(t) { this.externalEntities = {}, this.options = gY(t) } parse(t, r) { if (typeof t != "string") if (t.toString) t = t.toString(); else throw new Error("XML data is accepted in String or Bytes[] form."); if (r) { r === !0 && (r = {}); let i = fY(t, r); if (i !== !0) throw Error(`${i.err.msg}:${i.err.line}:${i.err.col}`) } let o = new Lf(this.options); o.addExternalEntities(this.externalEntities); let n = o.parseXml(t); return this.options.preserveOrder || n === void 0 ? n : LD(n, this.options) } addEntity(t, r) { if (r.indexOf("&") !== -1) throw new Error("Entity value can't have '&'"); if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'"); if (r === "&") throw new Error("An entity with value '&' is not permitted"); this.externalEntities[t] = r } static getMetaDataSymbol() { return Qo.getMetaDataSymbol() } } }); var TY = s(() => { "use strict"; AY() }); function $D(e) { return MD.parse(e, !0) } var MD, wY = s(() => {
  TY(); MD = new fu({
    attributeNamePrefix: "", htmlEntities: !0, ignoreAttributes: !1, ignoreDeclaration: !0, parseTagValue: !1, trimValues: !1, tagValueProcessor: (e, t) => t.trim() === "" && t.includes(`
`) ? "" : void 0
  }); MD.addEntity("#xD", "\r"); MD.addEntity("#10", `
`)
}); var FD = s(() => { aY(); ID(); wY() }); var hu, XE = s(() => { FD(); rs(); Oe(); cu(); HE(); ra(); AD(); hu = class extends uo { settings; stringDeserializer; constructor(t) { super(), this.settings = t, this.stringDeserializer = new Jp(t) } setSerdeContext(t) { this.serdeContext = t, this.stringDeserializer.setSerdeContext(t) } read(t, r, o) { let n = ue.of(t), i = n.getMemberSchemas(); if (n.isStructSchema() && n.isMemberSchema() && !!Object.values(i).find(u => !!u.getMemberTraits().eventPayload)) { let u = {}, l = Object.keys(i)[0]; return i[l].isBlobSchema() ? u[l] = r : u[l] = this.read(i[l], r), u } let c = (this.serdeContext?.utf8Encoder ?? UE)(r), p = this.parseXml(c); return this.readSchema(t, o ? p[o] : p) } readSchema(t, r) { let o = ue.of(t); if (o.isUnitSchema()) return; let n = o.getMergedTraits(); if (o.isListSchema() && !Array.isArray(r)) return this.readSchema(o, [r]); if (r == null) return r; if (typeof r == "object") { let i = !!n.sparse, a = !!n.xmlFlattened; if (o.isListSchema()) { let p = o.getValueSchema(), u = [], l = p.getMergedTraits().xmlName ?? "member", m = a ? r : (r[0] ?? r)[l], f = Array.isArray(m) ? m : [m]; for (let h of f) (h != null || i) && u.push(this.readSchema(p, h)); return u } let c = {}; if (o.isMapSchema()) { let p = o.getKeySchema(), u = o.getValueSchema(), l; a ? l = Array.isArray(r) ? r : [r] : l = Array.isArray(r.entry) ? r.entry : [r.entry]; let m = p.getMergedTraits().xmlName ?? "key", f = u.getMergedTraits().xmlName ?? "value"; for (let h of l) { let E = h[m], S = h[f]; (S != null || i) && (c[E] = this.readSchema(u, S)) } return c } if (o.isStructSchema()) { let p = o.isUnionSchema(), u; p && (u = new uu(r, c)); for (let [l, m] of o.structIterator()) { let f = m.getMergedTraits(), h = f.httpPayload ? f.xmlName ?? m.getName() : m.getMemberTraits().xmlName ?? l; p && u.mark(h), r[h] != null && (c[l] = this.readSchema(m, r[h])) } return p && u.writeUnknown(), c } if (o.isDocumentSchema()) return r; throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${o.getName(!0)}`) } return o.isListSchema() ? [] : o.isMapSchema() || o.isStructSchema() ? {} : this.stringDeserializer.read(o, r) } parseXml(t) { if (t.length) { let r; try { r = $D(t) } catch (a) { throw a && typeof a == "object" && Object.defineProperty(a, "$responseBodyText", { value: t }), a } let o = "#text", n = Object.keys(r)[0], i = r[n]; return i[o] && (i[n] = i[o], delete i[o]), CD(i) } return {} } } }); var JE, bY = s(() => { rs(); Oe(); Pr(); cu(); Of(); ra(); Df(); JE = class extends uo { settings; buffer; constructor(t) { super(), this.settings = t } write(t, r, o = "") { this.buffer === void 0 && (this.buffer = ""); let n = ue.of(t); if (o && !o.endsWith(".") && (o += "."), n.isBlobSchema()) (typeof r == "string" || r instanceof Uint8Array) && (this.writeKey(o), this.writeValue((this.serdeContext?.base64Encoder ?? Ec)(r))); else if (n.isBooleanSchema() || n.isNumericSchema() || n.isStringSchema()) r != null ? (this.writeKey(o), this.writeValue(String(r))) : n.isIdempotencyToken() && (this.writeKey(o), this.writeValue(ro())); else if (n.isBigIntegerSchema()) r != null && (this.writeKey(o), this.writeValue(String(r))); else if (n.isBigDecimalSchema()) r != null && (this.writeKey(o), this.writeValue(r instanceof _r ? r.string : String(r))); else if (n.isTimestampSchema()) { if (r instanceof Date) switch (this.writeKey(o), hn(n, this.settings)) { case 5: this.writeValue(r.toISOString().replace(".000Z", "Z")); break; case 6: this.writeValue(hi(r)); break; case 7: this.writeValue(String(r.getTime() / 1e3)); break } } else if (n.isDocumentSchema()) Array.isArray(r) ? this.write(79, r, o) : r instanceof Date ? this.write(4, r, o) : r instanceof Uint8Array ? this.write(21, r, o) : r && typeof r == "object" ? this.write(143, r, o) : (this.writeKey(o), this.writeValue(String(r))); else if (n.isListSchema()) { if (Array.isArray(r)) if (r.length === 0) this.settings.serializeEmptyLists && (this.writeKey(o), this.writeValue("")); else { let i = n.getValueSchema(), a = this.settings.flattenLists || n.getMergedTraits().xmlFlattened, c = 1; for (let p of r) { if (p == null) continue; let u = this.getKey("member", i.getMergedTraits().xmlName), l = a ? `${o}${c}` : `${o}${u}.${c}`; this.write(i, p, l), ++c } } } else if (n.isMapSchema()) { if (r && typeof r == "object") { let i = n.getKeySchema(), a = n.getValueSchema(), c = n.getMergedTraits().xmlFlattened, p = 1; for (let [u, l] of Object.entries(r)) { if (l == null) continue; let m = this.getKey("key", i.getMergedTraits().xmlName), f = c ? `${o}${p}.${m}` : `${o}entry.${p}.${m}`, h = this.getKey("value", a.getMergedTraits().xmlName), E = c ? `${o}${p}.${h}` : `${o}entry.${p}.${h}`; this.write(i, u, f), this.write(a, l, E), ++p } } } else if (n.isStructSchema()) { if (r && typeof r == "object") { let i = !1; for (let [a, c] of pu(n, r)) { if (r[a] == null && !c.isIdempotencyToken()) continue; let p = this.getKey(a, c.getMergedTraits().xmlName), u = `${o}${p}`; this.write(c, r[a], u), i = !0 } if (!i && n.isUnionSchema()) { let { $unknown: a } = r; if (Array.isArray(a)) { let [c, p] = a, u = `${o}${c}`; this.write(15, p, u) } } } } else if (!n.isUnitSchema()) throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${n.getName(!0)}`) } flush() { if (this.buffer === void 0) throw new Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer."); let t = this.buffer; return delete this.buffer, t } getKey(t, r) { let o = r ?? t; return this.settings.capitalizeKeys ? o[0].toUpperCase() + o.slice(1) : o } writeKey(t) { t.endsWith(".") && (t = t.slice(0, t.length - 1)), this.buffer += `&${qp(t)}=` } writeValue(t) { this.buffer += qp(t) } } }); var ZE, IY = s(() => { rs(); Oe(); vf(); XE(); bY(); ZE = class extends Xp { options; serializer; deserializer; mixin = new vs; constructor(t) { super({ defaultNamespace: t.defaultNamespace }), this.options = t; let r = { timestampFormat: { useTrait: !0, default: 5 }, httpBindings: !1, xmlNamespace: t.xmlNamespace, serviceNamespace: t.defaultNamespace, serializeEmptyLists: !0 }; this.serializer = new JE(r), this.deserializer = new hu(r) } getShapeId() { return "aws.protocols#awsQuery" } setSerdeContext(t) { this.serializer.setSerdeContext(t), this.deserializer.setSerdeContext(t) } getPayloadCodec() { throw new Error("AWSQuery protocol has no payload codec.") } async serializeRequest(t, r, o) { let n = await super.serializeRequest(t, r, o); n.path.endsWith("/") || (n.path += "/"), Object.assign(n.headers, { "content-type": "application/x-www-form-urlencoded" }), (Zi(t.input) === "unit" || !n.body) && (n.body = ""); let i = t.name.split("#")[1] ?? t.name; return n.body = `Action=${i}&Version=${this.options.version}` + n.body, n.body.endsWith("&") && (n.body = n.body.slice(-1)), n } async deserializeResponse(t, r, o) { let n = this.deserializer, i = ue.of(t.output), a = {}; if (o.statusCode >= 300) { let m = await Do(o.body, r); m.byteLength > 0 && Object.assign(a, await n.read(15, m)), await this.handleError(t, r, o, a, this.deserializeMetadata(o)) } for (let m in o.headers) { let f = o.headers[m]; delete o.headers[m], o.headers[m.toLowerCase()] = f } let c = t.name.split("#")[1] ?? t.name, p = i.isStructSchema() && this.useNestedResult() ? c + "Result" : void 0, u = await Do(o.body, r); return u.byteLength > 0 && Object.assign(a, await n.read(i, u, p)), { $metadata: this.deserializeMetadata(o), ...a } } useNestedResult() { return !0 } async handleError(t, r, o, n, i) { let a = this.loadQueryErrorCode(o, n) ?? "Unknown", c = this.loadQueryError(n), p = this.loadQueryErrorMessage(n); c.message = p, c.Error = { Type: c.Type, Code: c.Code, Message: p }; let { errorSchema: u, errorMetadata: l } = await this.mixin.getErrorSchemaOrThrowBaseException(a, this.options.defaultNamespace, o, c, i, this.mixin.findQueryCompatibleError), m = ue.of(u), f = k.for(u[1]).getErrorCtor(u) ?? Error, h = new f(p), E = { Type: c.Error.Type, Code: c.Error.Code, Error: c.Error }; for (let [S, y] of m.structIterator()) { let C = y.getMergedTraits().xmlName ?? S, b = c[C] ?? n[C]; E[S] = this.deserializer.readSchema(y, b) } throw this.mixin.decorateServiceException(Object.assign(h, l, { $fault: m.getMergedTraits().error, message: p }, E), n) } loadQueryErrorCode(t, r) { let o = (r.Errors?.[0]?.Error ?? r.Errors?.Error ?? r.Error)?.Code; if (o !== void 0) return o; if (t.statusCode == 404) return "NotFound" } loadQueryError(t) { return t.Errors?.[0]?.Error ?? t.Errors?.Error ?? t.Error } loadQueryErrorMessage(t) { let r = this.loadQueryError(t); return r?.message ?? r?.Message ?? t.message ?? t.Message ?? "Unknown" } getDefaultContentType() { return "application/x-www-form-urlencoded" } } }); var vY = s(() => { }); var PY, UD = s(() => { PY = (e, t) => { if (t?.Error?.Code !== void 0) return t.Error.Code; if (t?.Code !== void 0) return t.Code; if (e.statusCode == 404) return "NotFound" } }); var ey, HD = s(() => { FD(); rs(); Oe(); Pr(); cu(); Of(); ra(); Df(); ey = class extends uo { settings; stringBuffer; byteBuffer; buffer; constructor(t) { super(), this.settings = t } write(t, r) { let o = ue.of(t); if (o.isStringSchema() && typeof r == "string") this.stringBuffer = r; else if (o.isBlobSchema()) this.byteBuffer = "byteLength" in r ? r : (this.serdeContext?.base64Decoder ?? FE)(r); else { this.buffer = this.writeStruct(o, r, void 0); let n = o.getMergedTraits(); n.httpPayload && !n.xmlName && this.buffer.withName(o.getName()) } } flush() { if (this.byteBuffer !== void 0) { let r = this.byteBuffer; return delete this.byteBuffer, r } if (this.stringBuffer !== void 0) { let r = this.stringBuffer; return delete this.stringBuffer, r } let t = this.buffer; return this.settings.xmlNamespace && (t?.attributes?.xmlns || t.addAttribute("xmlns", this.settings.xmlNamespace)), delete this.buffer, t.toString() } writeStruct(t, r, o) { let n = t.getMergedTraits(), i = t.isMemberSchema() && !n.httpPayload ? t.getMemberTraits().xmlName ?? t.getMemberName() : n.xmlName ?? t.getName(); if (!i || !t.isStructSchema()) throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${t.getName(!0)}.`); let a = Bo.of(i), [c, p] = this.getXmlnsAttribute(t, o); for (let [l, m] of pu(t, r)) { let f = r[l]; if (f != null || m.isIdempotencyToken()) { if (m.getMergedTraits().xmlAttribute) { a.addAttribute(m.getMergedTraits().xmlName ?? l, this.writeSimple(m, f)); continue } if (m.isListSchema()) this.writeList(m, f, a, p); else if (m.isMapSchema()) this.writeMap(m, f, a, p); else if (m.isStructSchema()) a.addChildNode(this.writeStruct(m, f, p)); else { let h = Bo.of(m.getMergedTraits().xmlName ?? m.getMemberName()); this.writeSimpleInto(m, f, h, p), a.addChildNode(h) } } } let { $unknown: u } = r; if (u && t.isUnionSchema() && Array.isArray(u) && Object.keys(r).length === 1) { let [l, m] = u, f = Bo.of(l); if (typeof m != "string") if (r instanceof Bo || r instanceof yc) a.addChildNode(r); else throw new Error("@aws-sdk - $unknown union member in XML requires value of type string, @aws-sdk/xml-builder::XmlNode or XmlText."); this.writeSimpleInto(0, m, f, p), a.addChildNode(f) } return p && a.addAttribute(c, p), a } writeList(t, r, o, n) { if (!t.isMemberSchema()) throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${t.getName(!0)}`); let i = t.getMergedTraits(), a = t.getValueSchema(), c = a.getMergedTraits(), p = !!c.sparse, u = !!i.xmlFlattened, [l, m] = this.getXmlnsAttribute(t, n), f = (h, E) => { if (a.isListSchema()) this.writeList(a, Array.isArray(E) ? E : [E], h, m); else if (a.isMapSchema()) this.writeMap(a, E, h, m); else if (a.isStructSchema()) { let S = this.writeStruct(a, E, m); h.addChildNode(S.withName(u ? i.xmlName ?? t.getMemberName() : c.xmlName ?? "member")) } else { let S = Bo.of(u ? i.xmlName ?? t.getMemberName() : c.xmlName ?? "member"); this.writeSimpleInto(a, E, S, m), h.addChildNode(S) } }; if (u) for (let h of r) (p || h != null) && f(o, h); else { let h = Bo.of(i.xmlName ?? t.getMemberName()); m && h.addAttribute(l, m); for (let E of r) (p || E != null) && f(h, E); o.addChildNode(h) } } writeMap(t, r, o, n, i = !1) { if (!t.isMemberSchema()) throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${t.getName(!0)}`); let a = t.getMergedTraits(), c = t.getKeySchema(), u = c.getMergedTraits().xmlName ?? "key", l = t.getValueSchema(), m = l.getMergedTraits(), f = m.xmlName ?? "value", h = !!m.sparse, E = !!a.xmlFlattened, [S, y] = this.getXmlnsAttribute(t, n), C = (b, L, N) => { let j = Bo.of(u, L), [re, Ce] = this.getXmlnsAttribute(c, y); Ce && j.addAttribute(re, Ce), b.addChildNode(j); let O = Bo.of(f); l.isListSchema() ? this.writeList(l, N, O, y) : l.isMapSchema() ? this.writeMap(l, N, O, y, !0) : l.isStructSchema() ? O = this.writeStruct(l, N, y) : this.writeSimpleInto(l, N, O, y), b.addChildNode(O) }; if (E) { for (let [b, L] of Object.entries(r)) if (h || L != null) { let N = Bo.of(a.xmlName ?? t.getMemberName()); C(N, b, L), o.addChildNode(N) } } else { let b; i || (b = Bo.of(a.xmlName ?? t.getMemberName()), y && b.addAttribute(S, y), o.addChildNode(b)); for (let [L, N] of Object.entries(r)) if (h || N != null) { let j = Bo.of("entry"); C(j, L, N), (i ? o : b).addChildNode(j) } } } writeSimple(t, r) { if (r === null) throw new Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value."); let o = ue.of(t), n = null; if (r && typeof r == "object") if (o.isBlobSchema()) n = (this.serdeContext?.base64Encoder ?? Ec)(r); else if (o.isTimestampSchema() && r instanceof Date) switch (hn(o, this.settings)) { case 5: n = r.toISOString().replace(".000Z", "Z"); break; case 6: n = hi(r); break; case 7: n = String(r.getTime() / 1e3); break; default: console.warn("Missing timestamp format, using http date", r), n = hi(r); break } else { if (o.isBigDecimalSchema() && r) return r instanceof _r ? r.string : String(r); throw o.isMapSchema() || o.isListSchema() ? new Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.") : new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${o.getName(!0)}`) } if ((o.isBooleanSchema() || o.isNumericSchema() || o.isBigIntegerSchema() || o.isBigDecimalSchema()) && (n = String(r)), o.isStringSchema() && (r === void 0 && o.isIdempotencyToken() ? n = ro() : n = String(r)), n === null) throw new Error(`Unhandled schema-value pair ${o.getName(!0)}=${r}`); return n } writeSimpleInto(t, r, o, n) { let i = this.writeSimple(t, r), a = ue.of(t), c = new yc(i), [p, u] = this.getXmlnsAttribute(a, n); u && o.addAttribute(p, u), o.addChildNode(c) } getXmlnsAttribute(t, r) { let o = t.getMergedTraits(), [n, i] = o.xmlNamespace ?? []; return i && i !== r ? [n ? `xmlns:${n}` : "xmlns", i] : [void 0, void 0] } } }); var ty, GD = s(() => { ra(); XE(); HD(); ty = class extends uo { settings; constructor(t) { super(), this.settings = t } createSerializer() { let t = new ey(this.settings); return t.setSerdeContext(this.serdeContext), t } createDeserializer() { let t = new hu(this.settings); return t.setSerdeContext(this.serdeContext), t } } }); var ry, OY = s(() => { rs(); Oe(); vf(); UD(); GD(); ry = class extends Yp { codec; serializer; deserializer; mixin = new vs; constructor(t) { super(t); let r = { timestampFormat: { useTrait: !0, default: 5 }, httpBindings: !0, xmlNamespace: t.xmlNamespace, serviceNamespace: t.defaultNamespace }; this.codec = new ty(r), this.serializer = new eu(this.codec.createSerializer(), r), this.deserializer = new Zp(this.codec.createDeserializer(), r) } getPayloadCodec() { return this.codec } getShapeId() { return "aws.protocols#restXml" } async serializeRequest(t, r, o) { let n = await super.serializeRequest(t, r, o), i = ue.of(t.input); if (!n.headers["content-type"]) { let a = this.mixin.resolveRestContentType(this.getDefaultContentType(), i); a && (n.headers["content-type"] = a) } return typeof n.body == "string" && n.headers["content-type"] === this.getDefaultContentType() && !n.body.startsWith("<?xml ") && !this.hasUnstructuredPayloadBinding(i) && (n.body = '<?xml version="1.0" encoding="UTF-8"?>' + n.body), n } async deserializeResponse(t, r, o) { return super.deserializeResponse(t, r, o) } async handleError(t, r, o, n, i) { let a = PY(o, n) ?? "Unknown", { errorSchema: c, errorMetadata: p } = await this.mixin.getErrorSchemaOrThrowBaseException(a, this.options.defaultNamespace, o, n, i), u = ue.of(c), l = n.Error?.message ?? n.Error?.Message ?? n.message ?? n.Message ?? "Unknown", m = k.for(c[1]).getErrorCtor(c) ?? Error, f = new m(l); await this.deserializeHttpMessage(c, r, o, n); let h = {}; for (let [E, S] of u.structIterator()) { let y = S.getMergedTraits().xmlName ?? E, C = n.Error?.[y] ?? n[y]; h[E] = this.codec.createDeserializer().readSchema(S, C) } throw this.mixin.decorateServiceException(Object.assign(f, p, { $fault: u.getMergedTraits().error, message: l }, h), n) } getDefaultContentType() { return "application/xml" } hasUnstructuredPayloadBinding(t) { for (let [, r] of t.structIterator()) if (r.getMergedTraits().httpPayload) return !(r.isStructSchema() || r.isMapSchema() || r.isListSchema()); return !1 } } }); var yn = s(() => { M7(); $7(); Z7(); eY(); bD(); tY(); qE(); TD(); wD(); rY(); kf(); vY(); IY(); OY(); GD(); XE(); HD(); UD() }); var Ye = s(() => { He(); g7(); yn() }); async function DY(e, t, r) { if (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" && ye(e, "PROTOCOL_RPC_V2_CBOR", "M"), typeof t.retryStrategy == "function") { let i = await t.retryStrategy(); typeof i.acquireInitialRetryToken == "function" ? i.constructor?.name?.includes("Adaptive") ? ye(e, "RETRY_MODE_ADAPTIVE", "F") : ye(e, "RETRY_MODE_STANDARD", "E") : ye(e, "RETRY_MODE_LEGACY", "D") } if (typeof t.accountIdEndpointMode == "function") { let i = e.endpointV2; switch (String(i?.url?.hostname).match(p9e) && ye(e, "ACCOUNT_ID_ENDPOINT", "O"), await t.accountIdEndpointMode?.()) { case "disabled": ye(e, "ACCOUNT_ID_MODE_DISABLED", "Q"); break; case "preferred": ye(e, "ACCOUNT_ID_MODE_PREFERRED", "P"); break; case "required": ye(e, "ACCOUNT_ID_MODE_REQUIRED", "R"); break } } let n = e.__smithy_context?.selectedHttpAuthScheme?.identity; if (n?.$source) { let i = n; i.accountId && ye(e, "RESOLVED_ACCOUNT_ID", "T"); for (let [a, c] of Object.entries(i.$source ?? {})) ye(e, a, c) } } var p9e, kY = s(() => { Ye(); p9e = /\d{12}\.ddb/ }); var jD, oy, qD, ny, NY, BY, VD, LY = s(() => { jD = "user-agent", oy = "x-amz-user-agent", qD = " ", ny = "/", NY = /[^!$%&'*+\-.^_`|~\w]/g, BY = /[^!$%&'*+\-.^_`|~\w#]/g, VD = "-" }); function MY(e) { let t = ""; for (let r in e) { let o = e[r]; if (t.length + o.length + 1 <= 1024) { t.length ? t += "," + o : t += o; continue } break } return t } var $Y = s(() => { }); var u9e, sy, m9e, iy, FY = s(() => { wE(); di(); kY(); LY(); $Y(); u9e = e => (t, r) => async o => { let { request: n } = o; if (!dn.isInstance(n)) return t(o); let { headers: i } = n, a = r?.userAgent?.map(sy) || [], c = (await e.defaultUserAgentProvider()).map(sy); await DY(r, e, o); let p = r; c.push(`m/${MY(Object.assign({}, r.__smithy_context?.features, p.__aws_sdk_context?.features))}`); let u = e?.customUserAgent?.map(sy) || [], l = await e.userAgentAppId(); l && c.push(sy(["app", `${l}`])); let m = I9(), f = (m ? [m] : []).concat([...c, ...a, ...u]).join(qD), h = [...c.filter(E => E.startsWith("aws-sdk-")), ...u].join(qD); return e.runtime !== "browser" ? (h && (i[oy] = i[oy] ? `${i[jD]} ${h}` : h), i[jD] = f) : i[oy] = f, t({ ...o, request: n }) }, sy = e => { let t = e[0].split(ny).map(a => a.replace(NY, VD)).join(ny), r = e[1]?.replace(BY, VD), o = t.indexOf(ny), n = t.substring(0, o), i = t.substring(o + 1); return n === "api" && (i = i.toLowerCase()), [n, i, r].filter(a => a && a.length > 0).reduce((a, c, p) => { switch (p) { case 0: return c; case 1: return `${a}/${c}`; default: return `${a}#${c}` } }, "") }, m9e = { name: "getUserAgentMiddleware", step: "build", priority: "low", tags: ["SET_USER_AGENT", "USER_AGENT"], override: !0 }, iy = e => ({ applyToStack: t => { t.add(u9e(e), m9e) } }) }); var ay = s(() => { pK(); FY() }); var xt, UY = s(() => { xt = (e, t, r) => { if (t in e) { if (e[t] === "true") return !0; if (e[t] === "false") return !1; throw new Error(`Cannot load ${r} "${t}". Expected "true" or "false", got ${e[t]}.`) } } }); var HY = s(() => { }); var ct, GY = s(() => { (function (e) { e.ENV = "env", e.CONFIG = "shared config entry" })(ct || (ct = {})) }); var os = s(() => { UY(); HY(); GY() }); var l9e, d9e, cy, jY = s(() => { os(); l9e = "AWS_USE_DUALSTACK_ENDPOINT", d9e = "use_dualstack_endpoint", cy = { environmentVariableSelector: e => xt(e, l9e, ct.ENV), configFileSelector: e => xt(e, d9e, ct.CONFIG), default: !1 } }); var f9e, h9e, py, qY = s(() => { os(); f9e = "AWS_USE_FIPS_ENDPOINT", h9e = "use_fips_endpoint", py = { environmentVariableSelector: e => xt(e, f9e, ct.ENV), configFileSelector: e => xt(e, h9e, ct.CONFIG), default: !1 } }); var VY = s(() => { }); var zY = s(() => { }); var WY = s(() => { jY(); qY(); VY(); zY() }); var g9e, x9e, gu, uy, KY = s(() => { g9e = "AWS_REGION", x9e = "region", gu = { environmentVariableSelector: e => e[g9e], configFileSelector: e => e[x9e], default: () => { throw new Error("Region is missing") } }, uy = { preferredFile: "credentials" } }); var QY, YY, XY = s(() => { Ft(); QY = new Set, YY = (e, t = Or) => { if (!QY.has(e) && !t(e)) if (e === "*") console.warn('@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.'); else throw new Error(`Region not accepted: region="${e}" is not a valid hostname component.`); else QY.add(e) } }); var my, zD = s(() => { my = e => typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")) }); var JY, ZY = s(() => { zD(); JY = e => my(e) ? ["fips-aws-global", "aws-fips"].includes(e) ? "us-east-1" : e.replace(/fips-(dkr-|prod-)?|-fips/, "") : e }); var ly, eX = s(() => { XY(); ZY(); zD(); ly = e => { let { region: t, useFipsEndpoint: r } = e; if (!t) throw new Error("Region is missing"); return Object.assign(e, { region: async () => { let o = typeof t == "function" ? await t() : t, n = JY(o); return YY(n), n }, useFipsEndpoint: async () => { let o = typeof t == "string" ? t : await t(); return my(o) ? !0 : typeof r != "function" ? Promise.resolve(!!r) : r() } }) } }); var tX = s(() => { KY(); eX() }); var rX = s(() => { }); var oX = s(() => { }); var nX = s(() => { }); var sX = s(() => { rX(); oX(); nX() }); var xu = s(() => { WY(); tX(); sX() }); function E9e(e) { return t => async r => { let o = r.request; if (dn.isInstance(o)) { let { body: n, headers: i } = o; if (n && Object.keys(i).map(a => a.toLowerCase()).indexOf(iX) === -1) try { let a = e(n); o.headers = { ...o.headers, [iX]: String(a) } } catch { } } return t({ ...r, request: o }) } } var iX, y9e, dy, WD = s(() => { di(); iX = "content-length"; y9e = { step: "build", tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"], name: "contentLengthMiddleware", override: !0 }, dy = e => ({ applyToStack: t => { t.add(E9e(e.bodyLengthChecker), y9e) } }) }); var aX, S9e, _9e, C9e, R9e, A9e, cX = s(() => { aX = async e => { let t = e?.Bucket || ""; if (typeof e.Bucket == "string" && (e.Bucket = t.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), A9e(t)) { if (e.ForcePathStyle === !0) throw new Error("Path-style addressing cannot be used with ARN buckets") } else (!R9e(t) || t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:") || t.toLowerCase() !== t || t.length < 3) && (e.ForcePathStyle = !0); return e.DisableMultiRegionAccessPoints && (e.disableMultiRegionAccessPoints = !0, e.DisableMRAP = !0), e }, S9e = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, _9e = /(\d+\.){3}\d+/, C9e = /\.\./, R9e = e => S9e.test(e) && !_9e.test(e) && !C9e.test(e), A9e = e => { let [t, r, o, , , n] = e.split(":"), i = t === "arn" && e.split(":").length >= 6, a = !!(i && r && o && n); if (i && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`); return a } }); var pX = s(() => { cX() }); var uX, mX = s(() => { uX = (e, t, r, o = !1) => { let n = async () => { let i; return o ? i = r.clientContextParams?.[e] ?? r[e] ?? r[t] : i = r[e] ?? r[t], typeof i == "function" ? i() : i }; return e === "credentialScope" || t === "CredentialScope" ? async () => { let i = typeof r.credentials == "function" ? await r.credentials() : r.credentials; return i?.credentialScope ?? i?.CredentialScope } : e === "accountId" || t === "AccountId" ? async () => { let i = typeof r.credentials == "function" ? await r.credentials() : r.credentials; return i?.accountId ?? i?.AccountId } : e === "endpoint" || t === "endpoint" ? async () => { if (r.isCustomEndpoint === !1) return; let i = await n(); if (i && typeof i == "object") { if ("url" in i) return i.url.href; if ("hostname" in i) { let { protocol: a, hostname: c, port: p, path: u } = i; return `${a}//${c}${p ? ":" + p : ""}${u}` } } return i } : n } }); function fy(e) { try { let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? [])); return t.delete("CONFIG"), t.delete("CONFIG_PREFIX_SEPARATOR"), t.delete("ENV"), [...t].join(", ") } catch { return e } } var KD = s(() => { }); var lX, dX = s(() => { Z(); KD(); lX = (e, t) => async () => { try { let r = e(process.env, t); if (r === void 0) throw new Error; return r } catch (r) { throw new I(r.message || `Not found in ENV: ${fy(e.toString())}`, { logger: t?.logger }) } } }); import { homedir as T9e } from "os"; import { sep as w9e } from "path"; var QD, b9e, sa, Eu = s(() => { QD = {}, b9e = () => process && process.geteuid ? `${process.geteuid()}` : "DEFAULT", sa = () => { let { HOME: e, USERPROFILE: t, HOMEPATH: r, HOMEDRIVE: o = `C:${w9e}` } = process.env; if (e) return e; if (t) return t; if (r) return `${o}${r}`; let n = b9e(); return QD[n] || (QD[n] = T9e()), QD[n] } }); var YD, I9e, Sn, fX = s(() => { YD = "AWS_PROFILE", I9e = "default", Sn = e => e.profile || process.env[YD] || I9e }); import { createHash as v9e } from "crypto"; import { join as P9e } from "path"; var hy, XD = s(() => { Eu(); hy = e => { let r = v9e("sha1").update(e).digest("hex"); return P9e(sa(), ".aws", "sso", "cache", `${r}.json`) } }); import { readFile as O9e } from "fs/promises"; var Mf, $f, JD = s(() => { XD(); Mf = {}, $f = async e => { if (Mf[e]) return Mf[e]; let t = hy(e), r = await O9e(t, "utf8"); return JSON.parse(r) } }); var Yo, gy = s(() => { Yo = "." }); var hX, gX = s(() => { Lp(); gy(); hX = e => Object.entries(e).filter(([t]) => { let r = t.indexOf(Yo); return r === -1 ? !1 : Object.values(li).includes(t.substring(0, r)) }).reduce((t, [r, o]) => { let n = r.indexOf(Yo), i = r.substring(0, n) === li.PROFILE ? r.substring(n + 1) : r; return t[i] = o, t }, { ...e.default && { default: e.default } }) }); import { join as D9e } from "path"; var k9e, xy, ZD = s(() => { Eu(); k9e = "AWS_CONFIG_FILE", xy = () => process.env[k9e] || D9e(sa(), ".aws", "config") }); import { join as N9e } from "path"; var B9e, xX, EX = s(() => { Eu(); B9e = "AWS_SHARED_CREDENTIALS_FILE", xX = () => process.env[B9e] || N9e(sa(), ".aws", "credentials") }); var L9e, M9e, Ff, ek = s(() => { Lp(); gy(); L9e = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/, M9e = ["__proto__", "profile __proto__"], Ff = e => { let t = {}, r, o; for (let n of e.split(/\r?\n/)) { let i = n.split(/(^|\s)[;#]/)[0].trim(); if (i[0] === "[" && i[i.length - 1] === "]") { r = void 0, o = void 0; let c = i.substring(1, i.length - 1), p = L9e.exec(c); if (p) { let [, u, , l] = p; Object.values(li).includes(u) && (r = [u, l].join(Yo)) } else r = c; if (M9e.includes(c)) throw new Error(`Found invalid profile name "${c}"`) } else if (r) { let c = i.indexOf("="); if (![0, -1].includes(c)) { let [p, u] = [i.substring(0, c).trim(), i.substring(c + 1).trim()]; if (u === "") o = p; else { o && n.trimStart() === n && (o = void 0), t[r] = t[r] || {}; let l = o ? [o, p].join(Yo) : p; t[r][l] = u } } } } return t } }); import { readFile as $9e } from "node:fs/promises"; var tk, Uf, Hf, Ey = s(() => { tk = {}, Uf = {}, Hf = (e, t) => Uf[e] !== void 0 ? Uf[e] : ((!tk[e] || t?.ignoreCache) && (tk[e] = $9e(e, "utf8")), tk[e]) }); import { join as yX } from "path"; var SX, yy, Sy = s(() => { gX(); ZD(); EX(); Eu(); ek(); Ey(); gy(); SX = () => ({}), yy = async (e = {}) => { let { filepath: t = xX(), configFilepath: r = xy() } = e, o = sa(), n = "~/", i = t; t.startsWith(n) && (i = yX(o, t.slice(2))); let a = r; r.startsWith(n) && (a = yX(o, r.slice(2))); let c = await Promise.all([Hf(a, { ignoreCache: e.ignoreCache }).then(Ff).then(hX).catch(SX), Hf(i, { ignoreCache: e.ignoreCache }).then(Ff).catch(SX)]); return { configFile: c[0], credentialsFile: c[1] } } }); var _X, CX = s(() => { Lp(); Sy(); _X = e => Object.entries(e).filter(([t]) => t.startsWith(li.SSO_SESSION + Yo)).reduce((t, [r, o]) => ({ ...t, [r.substring(r.indexOf(Yo) + 1)]: o }), {}) }); var F9e, _y, RX = s(() => { ZD(); CX(); ek(); Ey(); F9e = () => ({}), _y = async (e = {}) => Hf(e.configFilepath ?? xy()).then(Ff).then(_X).catch(F9e) }); var AX, TX = s(() => { AX = (...e) => { let t = {}; for (let r of e) for (let [o, n] of Object.entries(r)) t[o] !== void 0 ? Object.assign(t[o], n) : t[o] = n; return t } }); var ia, wX = s(() => { Sy(); TX(); ia = async e => { let t = await yy(e); return AX(t.configFile, t.credentialsFile) } }); var Gf, bX = s(() => { JD(); Ey(); Gf = { getFileRecord() { return Uf }, interceptFile(e, t) { Uf[e] = Promise.resolve(t) }, getTokenRecord() { return Mf }, interceptToken(e, t) { Mf[e] = t } } }); var IX = s(() => { }); var Xo = s(() => { Eu(); fX(); XD(); JD(); Sy(); RX(); wX(); bX(); IX() }); var vX, PX = s(() => { Z(); Xo(); KD(); vX = (e, { preferredFile: t = "config", ...r } = {}) => async () => { let o = Sn(r), { configFile: n, credentialsFile: i } = await yy(r), a = i[o] || {}, c = n[o] || {}, p = t === "config" ? { ...a, ...c } : { ...c, ...a }; try { let l = e(p, t === "config" ? n : i); if (l === void 0) throw new Error; return l } catch (u) { throw new I(u.message || `Not found in config files w/ profile [${o}]: ${fy(e.toString())}`, { logger: r.logger }) } } }); var U9e, OX, DX = s(() => { Z(); U9e = e => typeof e == "function", OX = e => U9e(e) ? async () => await e() : Is(e) }); var It, kX = s(() => { Z(); dX(); PX(); DX(); It = ({ environmentVariableSelector: e, configFileSelector: t, default: r }, o = {}) => { let { signingName: n, logger: i } = o; return jr(sr(lX(e, { signingName: n, logger: i }), vX(t, o), OX(r))) } }); var Cc = s(() => { kX() }); var NX, BX, LX, MX = s(() => { Xo(); NX = "AWS_ENDPOINT_URL", BX = "endpoint_url", LX = e => ({ environmentVariableSelector: t => { let r = e.split(" ").map(i => i.toUpperCase()), o = t[[NX, ...r].join("_")]; if (o) return o; let n = t[NX]; if (n) return n }, configFileSelector: (t, r) => { if (r && t.services) { let n = r[["services", t.services].join(Yo)]; if (n) { let i = e.split(" ").map(c => c.toLowerCase()), a = n[[i.join("_"), BX].join(Yo)]; if (a) return a } } let o = t[BX]; if (o) return o }, default: void 0 }) }); var Cy, rk = s(() => { Cc(); MX(); Cy = async e => It(LX(e ?? ""))() }); var Ry, Ay = s(() => { Rf(); Ry = e => typeof e == "object" ? "url" in e ? bs(e.url) : e : bs(e) }); var $X, H9e, ok = s(() => { pX(); mX(); rk(); Ay(); $X = async (e, t, r, o) => { if (!r.isCustomEndpoint) { let a; r.serviceConfiguredEndpoint ? a = await r.serviceConfiguredEndpoint() : a = await Cy(r.serviceId), a && (r.endpoint = () => Promise.resolve(Ry(a)), r.isCustomEndpoint = !0) } let n = await H9e(e, t, r); if (typeof r.endpointProvider != "function") throw new Error("config.endpointProvider is not set."); return r.endpointProvider(n, o) }, H9e = async (e, t, r) => { let o = {}, n = t?.getEndpointParameterInstructions?.() || {}; for (let [i, a] of Object.entries(n)) switch (a.type) { case "staticContextParams": o[i] = a.value; break; case "contextParams": o[i] = e[a.name]; break; case "clientContextParams": case "builtInParams": o[i] = await uX(a.name, i, r, a.type !== "builtInParams")(); break; case "operationContextParams": o[i] = a.get(e); break; default: throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(a)) }return Object.keys(n).length === 0 && Object.assign(o, r), String(r.serviceId).toLowerCase() === "s3" && await aX(o), o } }); var FX = s(() => { ok(); Ay() }); var UX, nk = s(() => { Ie(); gt(); ok(); UX = ({ config: e, instructions: t }) => (r, o) => async n => { e.isCustomEndpoint && ea(o, "ENDPOINT_OVERRIDE", "N"); let i = await $X(n.input, { getEndpointParameterInstructions() { return t } }, { ...e }, o); o.endpointV2 = i, o.authSchemes = i.properties?.authSchemes; let a = o.authSchemes?.[0]; if (a) { o.signing_region = a.signingRegion, o.signing_service = a.signingName; let p = je(o)?.selectedHttpAuthScheme?.httpAuthOption; p && (p.signingProperties = Object.assign(p.signingProperties || {}, { signing_region: a.signingRegion, signingRegion: a.signingRegion, signing_service: a.signingName, signingName: a.signingName, signingRegionSet: a.signingRegionSet }, a.properties)) } return r({ ...n }) } }); var HX = s(() => { }); var GX = s(() => { }); var jX, qX = s(() => { jX = { name: "serializerMiddleware", step: "serialize", tags: ["SERIALIZER"], override: !0 } }); var VX = s(() => { HX(); qX(); GX() }); var G9e, G, zX = s(() => { VX(); nk(); G9e = { step: "serialize", tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"], name: "endpointV2Middleware", override: !0, relation: "before", toMiddleware: jX.name }, G = (e, t) => ({ applyToStack: r => { r.addRelativeTo(UX({ config: e, instructions: t }), G9e) } }) }); var Ty, WX = s(() => { gt(); rk(); Ay(); Ty = e => { let t = e.tls ?? !0, { endpoint: r, useDualstackEndpoint: o, useFipsEndpoint: n } = e, i = r != null ? async () => Ry(await le(r)()) : void 0, c = Object.assign(e, { endpoint: i, tls: t, isCustomEndpoint: !!r, useDualstackEndpoint: le(o ?? !1), useFipsEndpoint: le(n ?? !1) }), p; return c.serviceConfiguredEndpoint = async () => (e.serviceId && !p && (p = Cy(e.serviceId)), p), c } }); var KX = s(() => { }); var QX = s(() => { }); var me = s(() => { FX(); nk(); zX(); WX(); KX(); QX() }); var yi, yu, Su, wy = s(() => { (function (e) { e.STANDARD = "standard", e.ADAPTIVE = "adaptive" })(yi || (yi = {})); yu = 3, Su = yi.STANDARD }); var YX, XX, JX, ZX, eJ, tJ = s(() => { YX = ["BandwidthLimitExceeded", "EC2ThrottledException", "LimitExceededException", "PriorRequestNotComplete", "ProvisionedThroughputExceededException", "RequestLimitExceeded", "RequestThrottled", "RequestThrottledException", "SlowDown", "ThrottledException", "Throttling", "ThrottlingException", "TooManyRequestsException", "TransactionInProgressException"], XX = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], JX = [500, 502, 503, 504], ZX = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], eJ = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"] }); var j9e, q9e, V9e, by, Iy, rJ, sk = s(() => { tJ(); j9e = e => e?.$retryable !== void 0, q9e = e => e.$metadata?.clockSkewCorrected, V9e = e => { let t = new Set(["Failed to fetch", "NetworkError when attempting to fetch resource", "The Internet connection appears to be offline", "Load failed", "Network request failed"]); return e && e instanceof TypeError ? t.has(e.message) : !1 }, by = e => e.$metadata?.httpStatusCode === 429 || YX.includes(e.name) || e.$retryable?.throttling == !0, Iy = (e, t = 0) => j9e(e) || q9e(e) || XX.includes(e.name) || ZX.includes(e?.code || "") || eJ.includes(e?.code || "") || JX.includes(e.$metadata?.httpStatusCode || 0) || V9e(e) || e.cause !== void 0 && t <= 10 && Iy(e.cause, t + 1), rJ = e => { if (e.$metadata?.httpStatusCode !== void 0) { let t = e.$metadata.httpStatusCode; return 500 <= t && t <= 599 && !Iy(e) } return !1 } }); var vy, ik = s(() => { sk(); vy = class e { static setTimeoutFn = setTimeout; beta; minCapacity; minFillRate; scaleConstant; smooth; currentCapacity = 0; enabled = !1; lastMaxRate = 0; measuredTxRate = 0; requestCount = 0; fillRate; lastThrottleTime; lastTimestamp = 0; lastTxRateBucket; maxCapacity; timeWindow = 0; constructor(t) { this.beta = t?.beta ?? .7, this.minCapacity = t?.minCapacity ?? 1, this.minFillRate = t?.minFillRate ?? .5, this.scaleConstant = t?.scaleConstant ?? .4, this.smooth = t?.smooth ?? .8; let r = this.getCurrentTimeInSeconds(); this.lastThrottleTime = r, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity } getCurrentTimeInSeconds() { return Date.now() / 1e3 } async getSendToken() { return this.acquireTokenBucket(1) } async acquireTokenBucket(t) { if (this.enabled) { if (this.refillTokenBucket(), t > this.currentCapacity) { let r = (t - this.currentCapacity) / this.fillRate * 1e3; await new Promise(o => e.setTimeoutFn(o, r)) } this.currentCapacity = this.currentCapacity - t } } refillTokenBucket() { let t = this.getCurrentTimeInSeconds(); if (!this.lastTimestamp) { this.lastTimestamp = t; return } let r = (t - this.lastTimestamp) * this.fillRate; this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + r), this.lastTimestamp = t } updateClientSendingRate(t) { let r; if (this.updateMeasuredRate(), by(t)) { let n = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate; this.lastMaxRate = n, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), r = this.cubicThrottle(n), this.enableTokenBucket() } else this.calculateTimeWindow(), r = this.cubicSuccess(this.getCurrentTimeInSeconds()); let o = Math.min(r, 2 * this.measuredTxRate); this.updateTokenBucketRate(o) } calculateTimeWindow() { this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3)) } cubicThrottle(t) { return this.getPrecise(t * this.beta) } cubicSuccess(t) { return this.getPrecise(this.scaleConstant * Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate) } enableTokenBucket() { this.enabled = !0 } updateTokenBucketRate(t) { this.refillTokenBucket(), this.fillRate = Math.max(t, this.minFillRate), this.maxCapacity = Math.max(t, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity) } updateMeasuredRate() { let t = this.getCurrentTimeInSeconds(), r = Math.floor(t * 2) / 2; if (this.requestCount++, r > this.lastTxRateBucket) { let o = this.requestCount / (r - this.lastTxRateBucket); this.measuredTxRate = this.getPrecise(o * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = r } } getPrecise(t) { return parseFloat(t.toFixed(8)) } } }); var oJ, nJ, sJ = s(() => { oJ = "amz-sdk-invocation-id", nJ = "amz-sdk-request" }); var aJ, cJ = s(() => { aJ = () => { let e = 100; return { computeNextBackoffDelay: o => Math.floor(Math.min(2e4, Math.random() * 2 ** o * e)), setDelayBase: o => { e = o } } } }); var ak, pJ = s(() => { ak = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({ getRetryCount: () => t, getRetryDelay: () => Math.min(2e4, e), getRetryCost: () => r }) }); var _u, ck = s(() => { wy(); cJ(); pJ(); _u = class { maxAttempts; mode = yi.STANDARD; capacity = 500; retryBackoffStrategy = aJ(); maxAttemptsProvider; constructor(t) { this.maxAttempts = t, this.maxAttemptsProvider = typeof t == "function" ? t : async () => t } async acquireInitialRetryToken(t) { return ak({ retryDelay: 100, retryCount: 0 }) } async refreshRetryTokenForRetry(t, r) { let o = await this.getMaxAttempts(); if (this.shouldRetry(t, r, o)) { let n = r.errorType; this.retryBackoffStrategy.setDelayBase(n === "THROTTLING" ? 500 : 100); let i = this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()), a = r.retryAfterHint ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i) : i, c = this.getCapacityCost(n); return this.capacity -= c, ak({ retryDelay: a, retryCount: t.getRetryCount() + 1, retryCost: c }) } throw new Error("No retry token available") } recordSuccess(t) { this.capacity = Math.max(500, this.capacity + (t.getRetryCost() ?? 1)) } getCapacity() { return this.capacity } async getMaxAttempts() { try { return await this.maxAttemptsProvider() } catch { return console.warn(`Max attempts provider could not resolve. Using default of ${yu}`), yu } } shouldRetry(t, r, o) { return t.getRetryCount() + 1 < o && this.capacity >= this.getCapacityCost(r.errorType) && this.isRetryableError(r.errorType) } getCapacityCost(t) { return t === "TRANSIENT" ? 10 : 5 } isRetryableError(t) { return t === "THROTTLING" || t === "TRANSIENT" } } }); var Py, uJ = s(() => { wy(); ik(); ck(); Py = class { maxAttemptsProvider; rateLimiter; standardRetryStrategy; mode = yi.ADAPTIVE; constructor(t, r) { this.maxAttemptsProvider = t; let { rateLimiter: o } = r ?? {}; this.rateLimiter = o ?? new vy, this.standardRetryStrategy = new _u(t) } async acquireInitialRetryToken(t) { return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(t) } async refreshRetryTokenForRetry(t, r) { return this.rateLimiter.updateClientSendingRate(r), this.standardRetryStrategy.refreshRetryTokenForRetry(t, r) } recordSuccess(t) { this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(t) } } }); var mJ = s(() => { }); var lJ = s(() => { }); var jf = s(() => { uJ(); mJ(); ik(); ck(); wy(); sJ(); lJ() }); var dJ = s(() => { }); var fJ = s(() => { }); var hJ, gJ = s(() => { hJ = e => e instanceof Error ? e : e instanceof Object ? Object.assign(new Error, e) : typeof e == "string" ? new Error(e) : new Error(`AWS SDK error wrapper for ${e}`) }); var xJ = s(() => { }); var EJ = s(() => { }); var yJ, SJ, Oy, Dy, K9e, Q9e, ky, _J = s(() => { gt(); jf(); yJ = "AWS_MAX_ATTEMPTS", SJ = "max_attempts", Oy = { environmentVariableSelector: e => { let t = e[yJ]; if (!t) return; let r = parseInt(t); if (Number.isNaN(r)) throw new Error(`Environment variable ${yJ} mast be a number, got "${t}"`); return r }, configFileSelector: e => { let t = e[SJ]; if (!t) return; let r = parseInt(t); if (Number.isNaN(r)) throw new Error(`Shared config file entry ${SJ} mast be a number, got "${t}"`); return r }, default: yu }, Dy = e => { let { retryStrategy: t, retryMode: r, maxAttempts: o } = e, n = le(o ?? yu); return Object.assign(e, { maxAttempts: n, retryStrategy: async () => t || (await le(r)() === yi.ADAPTIVE ? new Py(n) : new _u(n)) }) }, K9e = "AWS_RETRY_MODE", Q9e = "retry_mode", ky = { environmentVariableSelector: e => e[K9e], configFileSelector: e => e[Q9e], default: Su } }); var CJ = s(() => { }); var Rc, aa, Cu, RJ, AJ, TJ = s(() => { Rc = (e, t) => { let r = []; if (e && r.push(e), t) for (let o of t) r.push(o); return r }, aa = (e, t) => `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`, Cu = () => { let e = [], t = [], r = !1, o = new Set, n = m => m.sort((f, h) => RJ[h.step] - RJ[f.step] || AJ[h.priority || "normal"] - AJ[f.priority || "normal"]), i = m => { let f = !1, h = E => { let S = Rc(E.name, E.aliases); if (S.includes(m)) { f = !0; for (let y of S) o.delete(y); return !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, a = m => { let f = !1, h = E => { if (E.middleware === m) { f = !0; for (let S of Rc(E.name, E.aliases)) o.delete(S); return !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, c = m => (e.forEach(f => { m.add(f.middleware, { ...f }) }), t.forEach(f => { m.addRelativeTo(f.middleware, { ...f }) }), m.identifyOnResolve?.(l.identifyOnResolve()), m), p = m => { let f = []; return m.before.forEach(h => { h.before.length === 0 && h.after.length === 0 ? f.push(h) : f.push(...p(h)) }), f.push(m), m.after.reverse().forEach(h => { h.before.length === 0 && h.after.length === 0 ? f.push(h) : f.push(...p(h)) }), f }, u = (m = !1) => { let f = [], h = [], E = {}; return e.forEach(y => { let C = { ...y, before: [], after: [] }; for (let b of Rc(C.name, C.aliases)) E[b] = C; f.push(C) }), t.forEach(y => { let C = { ...y, before: [], after: [] }; for (let b of Rc(C.name, C.aliases)) E[b] = C; h.push(C) }), h.forEach(y => { if (y.toMiddleware) { let C = E[y.toMiddleware]; if (C === void 0) { if (m) return; throw new Error(`${y.toMiddleware} is not found when adding ${aa(y.name, y.aliases)} middleware ${y.relation} ${y.toMiddleware}`) } y.relation === "after" && C.after.push(y), y.relation === "before" && C.before.push(y) } }), n(f).map(p).reduce((y, C) => (y.push(...C), y), []) }, l = { add: (m, f = {}) => { let { name: h, override: E, aliases: S } = f, y = { step: "initialize", priority: "normal", middleware: m, ...f }, C = Rc(h, S); if (C.length > 0) { if (C.some(b => o.has(b))) { if (!E) throw new Error(`Duplicate middleware name '${aa(h, S)}'`); for (let b of C) { let L = e.findIndex(j => j.name === b || j.aliases?.some(re => re === b)); if (L === -1) continue; let N = e[L]; if (N.step !== y.step || y.priority !== N.priority) throw new Error(`"${aa(N.name, N.aliases)}" middleware with ${N.priority} priority in ${N.step} step cannot be overridden by "${aa(h, S)}" middleware with ${y.priority} priority in ${y.step} step.`); e.splice(L, 1) } } for (let b of C) o.add(b) } e.push(y) }, addRelativeTo: (m, f) => { let { name: h, override: E, aliases: S } = f, y = { middleware: m, ...f }, C = Rc(h, S); if (C.length > 0) { if (C.some(b => o.has(b))) { if (!E) throw new Error(`Duplicate middleware name '${aa(h, S)}'`); for (let b of C) { let L = t.findIndex(j => j.name === b || j.aliases?.some(re => re === b)); if (L === -1) continue; let N = t[L]; if (N.toMiddleware !== y.toMiddleware || N.relation !== y.relation) throw new Error(`"${aa(N.name, N.aliases)}" middleware ${N.relation} "${N.toMiddleware}" middleware cannot be overridden by "${aa(h, S)}" middleware ${y.relation} "${y.toMiddleware}" middleware.`); t.splice(L, 1) } } for (let b of C) o.add(b) } t.push(y) }, clone: () => c(Cu()), use: m => { m.applyToStack(l) }, remove: m => typeof m == "string" ? i(m) : a(m), removeByTag: m => { let f = !1, h = E => { let { tags: S, name: y, aliases: C } = E; if (S && S.includes(m)) { let b = Rc(y, C); for (let L of b) o.delete(L); return f = !0, !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, concat: m => { let f = c(Cu()); return f.use(m), f.identifyOnResolve(r || f.identifyOnResolve() || (m.identifyOnResolve?.() ?? !1)), f }, applyToStack: c, identify: () => u(!0).map(m => { let f = m.step ?? m.relation + " " + m.toMiddleware; return aa(m.name, m.aliases) + " - " + f }), identifyOnResolve(m) { return typeof m == "boolean" && (r = m), r }, resolve: (m, f) => { for (let h of u().map(E => E.middleware).reverse()) m = h(m, f); return r && console.log(l.identify()), m } }; return l }, RJ = { initialize: 5, serialize: 4, build: 3, finalizeRequest: 2, deserialize: 1 }, AJ = { high: 3, normal: 2, low: 1 } }); var pk = s(() => { TJ() }); var Ru, wJ = s(() => { pk(); Ru = class { config; middlewareStack = Cu(); initConfig; handlers; constructor(t) { this.config = t; let { protocol: r, protocolSettings: o } = t; o && typeof r == "function" && (t.protocol = new r(o)) } send(t, r, o) { let n = typeof r != "function" ? r : void 0, i = typeof r == "function" ? r : o, a = n === void 0 && this.config.cacheMiddleware === !0, c; if (a) { this.handlers || (this.handlers = new WeakMap); let p = this.handlers; p.has(t.constructor) ? c = p.get(t.constructor) : (c = t.resolveMiddleware(this.middlewareStack, this.config, n), p.set(t.constructor, c)) } else delete this.handlers, c = t.resolveMiddleware(this.middlewareStack, this.config, n); if (i) c(t).then(p => i(null, p.output), p => i(p)).catch(() => { }); else return c(t).then(p => p.output) } destroy() { this.config?.requestHandler?.destroy?.(), delete this.handlers } } }); var bJ = s(() => { }); function Ny(e, t) { if (t == null) return t; let r = ue.of(e); if (r.getMergedTraits().sensitive) return uk; if (r.isListSchema()) { if (!!r.getValueSchema().getMergedTraits().sensitive) return uk } else if (r.isMapSchema()) { if (!!r.getKeySchema().getMergedTraits().sensitive || !!r.getValueSchema().getMergedTraits().sensitive) return uk } else if (r.isStructSchema() && typeof t == "object") { let o = t, n = {}; for (let [i, a] of r.structIterator()) o[i] != null && (n[i] = Ny(a, o[i])); return n } return t } var uk, IJ = s(() => { Oe(); uk = "***SensitiveInformation***" }); var $, mk, vJ = s(() => { pk(); Lp(); IJ(); $ = class { middlewareStack = Cu(); schema; static classBuilder() { return new mk } resolveMiddlewareWithContext(t, r, o, { middlewareFn: n, clientName: i, commandName: a, inputFilterSensitiveLog: c, outputFilterSensitiveLog: p, smithyContext: u, additionalContext: l, CommandCtor: m }) { for (let y of n.bind(this)(m, t, r, o)) this.middlewareStack.use(y); let f = t.concat(this.middlewareStack), { logger: h } = r, E = { logger: h, clientName: i, commandName: a, inputFilterSensitiveLog: c, outputFilterSensitiveLog: p, [cW]: { commandInstance: this, ...u }, ...l }, { requestHandler: S } = r; return f.resolve(y => S.handle(y.request, o || {}), E) } }, mk = class { _init = () => { }; _ep = {}; _middlewareFn = () => []; _commandName = ""; _clientName = ""; _additionalContext = {}; _smithyContext = {}; _inputFilterSensitiveLog = void 0; _outputFilterSensitiveLog = void 0; _serializer = null; _deserializer = null; _operationSchema; init(t) { this._init = t } ep(t) { return this._ep = t, this } m(t) { return this._middlewareFn = t, this } s(t, r, o = {}) { return this._smithyContext = { service: t, operation: r, ...o }, this } c(t = {}) { return this._additionalContext = t, this } n(t, r) { return this._clientName = t, this._commandName = r, this } f(t = o => o, r = o => o) { return this._inputFilterSensitiveLog = t, this._outputFilterSensitiveLog = r, this } ser(t) { return this._serializer = t, this } de(t) { return this._deserializer = t, this } sc(t) { return this._operationSchema = t, this._smithyContext.operationSchema = t, this } build() { let t = this, r; return r = class extends $ { input; static getEndpointParameterInstructions() { return t._ep } constructor(...[o]) { super(), this.input = o ?? {}, t._init(this), this.schema = t._operationSchema } resolveMiddleware(o, n, i) { let a = t._operationSchema, c = a?.[4] ?? a?.input, p = a?.[5] ?? a?.output; return this.resolveMiddlewareWithContext(o, n, i, { CommandCtor: r, middlewareFn: t._middlewareFn, clientName: t._clientName, commandName: t._commandName, inputFilterSensitiveLog: t._inputFilterSensitiveLog ?? (a ? Ny.bind(null, c) : u => u), outputFilterSensitiveLog: t._outputFilterSensitiveLog ?? (a ? Ny.bind(null, p) : u => u), smithyContext: t._smithyContext, additionalContext: t._additionalContext }) } serialize = t._serializer; deserialize = t._deserializer } } } }); var PJ = s(() => { }); var By, OJ = s(() => { By = (e, t) => { for (let r of Object.keys(e)) { let o = e[r], n = async function (a, c, p) { let u = new o(a); if (typeof c == "function") this.send(u, c); else if (typeof p == "function") { if (typeof c != "object") throw new Error(`Expected http options but got ${typeof c}`); this.send(u, c || {}, p) } else return this.send(u, c) }, i = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, ""); t.prototype[i] = n } } }); var Au, DJ = s(() => { Au = class e extends Error { $fault; $response; $retryable; $metadata; constructor(t) { super(t.message), Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = t.name, this.$fault = t.$fault, this.$metadata = t.$metadata } static isInstance(t) { if (!t) return !1; let r = t; return e.prototype.isPrototypeOf(r) || !!r.$fault && !!r.$metadata && (r.$fault === "client" || r.$fault === "server") } static [Symbol.hasInstance](t) { if (!t) return !1; let r = t; return this === e ? e.isInstance(t) : e.isInstance(t) ? r.name && this.name ? this.prototype.isPrototypeOf(t) || r.name === this.name : this.prototype.isPrototypeOf(t) : !1 } } }); var kJ = s(() => { }); var Ly, NJ = s(() => { Ly = e => { switch (e) { case "standard": return { retryMode: "standard", connectionTimeout: 3100 }; case "in-region": return { retryMode: "standard", connectionTimeout: 1100 }; case "cross-region": return { retryMode: "standard", connectionTimeout: 3100 }; case "mobile": return { retryMode: "standard", connectionTimeout: 3e4 }; default: return {} } } }); var BJ, My, LJ = s(() => { BJ = !1, My = e => { e && !BJ && parseInt(e.substring(1, e.indexOf("."))) < 16 && (BJ = !0) } }); var MJ = s(() => { }); var $J, FJ, UJ = s(() => { Lp(); $J = e => { let t = []; for (let r in Bp) { let o = Bp[r]; e[o] !== void 0 && t.push({ algorithmId: () => o, checksumConstructor: () => e[o] }) } return { addChecksumAlgorithm(r) { t.push(r) }, checksumAlgorithms() { return t } } }, FJ = e => { let t = {}; return e.checksumAlgorithms().forEach(r => { t[r.algorithmId()] = r.checksumConstructor() }), t } }); var HJ, GJ, jJ = s(() => { HJ = e => ({ setRetryStrategy(t) { e.retryStrategy = t }, retryStrategy() { return e.retryStrategy } }), GJ = e => { let t = {}; return t.retryStrategy = e.retryStrategy(), t } }); var $y, Fy, qJ = s(() => { UJ(); jJ(); $y = e => Object.assign($J(e), HJ(e)), Fy = e => Object.assign(FJ(e), GJ(e)) }); var VJ = s(() => { qJ() }); var zJ = s(() => { }); var WJ = s(() => { }); var KJ = s(() => { }); var ca, QJ = s(() => { ca = class { trace() { } debug() { } info() { } warn() { } error() { } } }); var YJ = s(() => { }); var XJ = s(() => { }); var JJ = s(() => { }); var ZJ = s(() => { }); var ae = s(() => { wJ(); bJ(); vJ(); PJ(); OJ(); kJ(); NJ(); LJ(); DJ(); MJ(); VJ(); zJ(); WJ(); KJ(); QJ(); YJ(); XJ(); JJ(); ZJ(); Pr() }); import { Readable as Y9e } from "stream"; var eZ, tZ = s(() => { eZ = e => e?.body instanceof Y9e || typeof ReadableStream < "u" && e?.body instanceof ReadableStream }); var X9e, J9e, Z9e, eQe, tQe, Uy, rQe, rZ = s(() => { di(); sk(); ae(); jf(); Wp(); tZ(); gJ(); X9e = e => (t, r) => async o => { let n = await e.retryStrategy(), i = await e.maxAttempts(); if (J9e(n)) { n = n; let a = await n.acquireInitialRetryToken(r.partition_id), c = new Error, p = 0, u = 0, { request: l } = o, m = dn.isInstance(l); for (m && (l.headers[oJ] = ro()); ;)try { m && (l.headers[nJ] = `attempt=${p + 1}; max=${i}`); let { response: f, output: h } = await t(o); return n.recordSuccess(a), h.$metadata.attempts = p + 1, h.$metadata.totalRetryDelay = u, { response: f, output: h } } catch (f) { let h = Z9e(f); if (c = hJ(f), m && eZ(l)) throw (r.logger instanceof ca ? console : r.logger)?.warn("An error was encountered in a non-retryable streaming request."), c; try { a = await n.refreshRetryTokenForRetry(a, h) } catch { throw c.$metadata || (c.$metadata = {}), c.$metadata.attempts = p + 1, c.$metadata.totalRetryDelay = u, c } p = a.getRetryCount(); let E = a.getRetryDelay(); u += E, await new Promise(S => setTimeout(S, E)) } } else return n = n, n?.mode && (r.userAgent = [...r.userAgent || [], ["cfg/retry-mode", n.mode]]), n.retry(t, o) }, J9e = e => typeof e.acquireInitialRetryToken < "u" && typeof e.refreshRetryTokenForRetry < "u" && typeof e.recordSuccess < "u", Z9e = e => { let t = { error: e, errorType: eQe(e) }, r = rQe(e.$response); return r && (t.retryAfterHint = r), t }, eQe = e => by(e) ? "THROTTLING" : Iy(e) ? "TRANSIENT" : rJ(e) ? "SERVER_ERROR" : "CLIENT_ERROR", tQe = { name: "retryMiddleware", tags: ["RETRY"], step: "finalizeRequest", priority: "high", override: !0 }, Uy = e => ({ applyToStack: t => { t.add(X9e(e), tQe) } }), rQe = e => { if (!Mp.isInstance(e)) return; let t = Object.keys(e.headers).find(i => i.toLowerCase() === "retry-after"); if (!t) return; let r = e.headers[t], o = Number(r); return Number.isNaN(o) ? new Date(r) : new Date(o * 1e3) } }); var qf = s(() => { EJ(); xJ(); _J(); dJ(); CJ(); fJ(); rZ() }); function oQe(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "dynamodb", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } var oZ, nZ, sZ, lk = s(() => { Ye(); gt(); oZ = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }); nZ = e => { let t = []; switch (e.operation) { default: t.push(oQe(e)) }return t }, sZ = e => { let t = qr(e); return Object.assign(t, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var iZ, q, fe = s(() => { iZ = e => Object.assign(e, { useDualstackEndpoint: e.useDualstackEndpoint ?? !1, useFipsEndpoint: e.useFipsEndpoint ?? !1, defaultSigningName: "dynamodb" }), q = { UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, AccountId: { type: "builtInParams", name: "accountId" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }, AccountIdEndpointMode: { type: "builtInParams", name: "accountIdEndpointMode" } } }); var Me, dk = s(() => { ae(); Me = class e extends Au { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var Hy, Gy, jy, qy, Vy, zy, Wy, Ky, Qy, Yy, Xy, Jy, Zy, eS, tS, rS, oS, nS, sS, iS, aS, cS, pS, uS, mS, lS, dS, fS, hS, gS, xS, ES, yS, SS, _S, fk = s(() => { dk(); Hy = class e extends Me { name = "BackupInUseException"; $fault = "client"; constructor(t) { super({ name: "BackupInUseException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Gy = class e extends Me { name = "BackupNotFoundException"; $fault = "client"; constructor(t) { super({ name: "BackupNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, jy = class e extends Me { name = "InternalServerError"; $fault = "server"; constructor(t) { super({ name: "InternalServerError", $fault: "server", ...t }), Object.setPrototypeOf(this, e.prototype) } }, qy = class e extends Me { name = "RequestLimitExceeded"; $fault = "client"; ThrottlingReasons; constructor(t) { super({ name: "RequestLimitExceeded", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.ThrottlingReasons = t.ThrottlingReasons } }, Vy = class e extends Me { name = "ThrottlingException"; $fault = "client"; throttlingReasons; constructor(t) { super({ name: "ThrottlingException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.throttlingReasons = t.throttlingReasons } }, zy = class e extends Me { name = "InvalidEndpointException"; $fault = "client"; Message; constructor(t) { super({ name: "InvalidEndpointException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.Message = t.Message } }, Wy = class e extends Me { name = "ProvisionedThroughputExceededException"; $fault = "client"; ThrottlingReasons; constructor(t) { super({ name: "ProvisionedThroughputExceededException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.ThrottlingReasons = t.ThrottlingReasons } }, Ky = class e extends Me { name = "ResourceNotFoundException"; $fault = "client"; constructor(t) { super({ name: "ResourceNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Qy = class e extends Me { name = "ItemCollectionSizeLimitExceededException"; $fault = "client"; constructor(t) { super({ name: "ItemCollectionSizeLimitExceededException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Yy = class e extends Me { name = "ReplicatedWriteConflictException"; $fault = "client"; $retryable = {}; constructor(t) { super({ name: "ReplicatedWriteConflictException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Xy = class e extends Me { name = "ContinuousBackupsUnavailableException"; $fault = "client"; constructor(t) { super({ name: "ContinuousBackupsUnavailableException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Jy = class e extends Me { name = "LimitExceededException"; $fault = "client"; constructor(t) { super({ name: "LimitExceededException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Zy = class e extends Me { name = "TableInUseException"; $fault = "client"; constructor(t) { super({ name: "TableInUseException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, eS = class e extends Me { name = "TableNotFoundException"; $fault = "client"; constructor(t) { super({ name: "TableNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, tS = class e extends Me { name = "GlobalTableAlreadyExistsException"; $fault = "client"; constructor(t) { super({ name: "GlobalTableAlreadyExistsException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, rS = class e extends Me { name = "ResourceInUseException"; $fault = "client"; constructor(t) { super({ name: "ResourceInUseException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, oS = class e extends Me { name = "TransactionConflictException"; $fault = "client"; constructor(t) { super({ name: "TransactionConflictException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, nS = class e extends Me { name = "PolicyNotFoundException"; $fault = "client"; constructor(t) { super({ name: "PolicyNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, sS = class e extends Me { name = "ExportNotFoundException"; $fault = "client"; constructor(t) { super({ name: "ExportNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, iS = class e extends Me { name = "GlobalTableNotFoundException"; $fault = "client"; constructor(t) { super({ name: "GlobalTableNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, aS = class e extends Me { name = "ImportNotFoundException"; $fault = "client"; constructor(t) { super({ name: "ImportNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, cS = class e extends Me { name = "DuplicateItemException"; $fault = "client"; constructor(t) { super({ name: "DuplicateItemException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, pS = class e extends Me { name = "IdempotentParameterMismatchException"; $fault = "client"; Message; constructor(t) { super({ name: "IdempotentParameterMismatchException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.Message = t.Message } }, uS = class e extends Me { name = "TransactionInProgressException"; $fault = "client"; Message; constructor(t) { super({ name: "TransactionInProgressException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.Message = t.Message } }, mS = class e extends Me { name = "ExportConflictException"; $fault = "client"; constructor(t) { super({ name: "ExportConflictException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, lS = class e extends Me { name = "InvalidExportTimeException"; $fault = "client"; constructor(t) { super({ name: "InvalidExportTimeException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, dS = class e extends Me { name = "PointInTimeRecoveryUnavailableException"; $fault = "client"; constructor(t) { super({ name: "PointInTimeRecoveryUnavailableException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, fS = class e extends Me { name = "ImportConflictException"; $fault = "client"; constructor(t) { super({ name: "ImportConflictException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, hS = class e extends Me { name = "TableAlreadyExistsException"; $fault = "client"; constructor(t) { super({ name: "TableAlreadyExistsException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, gS = class e extends Me { name = "InvalidRestoreTimeException"; $fault = "client"; constructor(t) { super({ name: "InvalidRestoreTimeException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, xS = class e extends Me { name = "ReplicaAlreadyExistsException"; $fault = "client"; constructor(t) { super({ name: "ReplicaAlreadyExistsException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, ES = class e extends Me { name = "ReplicaNotFoundException"; $fault = "client"; constructor(t) { super({ name: "ReplicaNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, yS = class e extends Me { name = "IndexNotFoundException"; $fault = "client"; constructor(t) { super({ name: "IndexNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, SS = class e extends Me { name = "ConditionalCheckFailedException"; $fault = "client"; Item; constructor(t) { super({ name: "ConditionalCheckFailedException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.Item = t.Item } }, _S = class e extends Me { name = "TransactionCanceledException"; $fault = "client"; Message; CancellationReasons; constructor(t) { super({ name: "TransactionCanceledException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.Message = t.Message, this.CancellationReasons = t.CancellationReasons } } }); var nQe, sQe, hk, iQe, aQe, Vf, cQe, pQe, uQe, CS, mQe, cZ, pZ, lQe, dQe, fQe, uZ, hQe, gQe, xQe, EQe, yQe, RS, mZ, SQe, gk, _Qe, CQe, xk, RQe, zf, lZ, Ek, yk, dZ, AQe, TQe, wQe, bQe, IQe, vQe, PQe, OQe, DQe, Wf, fZ, hZ, Sk, kQe, NQe, gZ, xZ, BQe, LQe, MQe, $Qe, FQe, UQe, EZ, _k, HQe, GQe, jQe, qQe, VQe, yZ, zQe, Ck, WQe, KQe, QQe, YQe, Lo, XQe, JQe, SZ, _Z, Ac, ZQe, e7e, t7e, r7e, o7e, n7e, AS, s7e, i7e, Rk, CZ, RZ, Kf, a7e, c7e, Tu, p7e, u7e, m7e, l7e, AZ, d7e, f7e, TS, h7e, g7e, x7e, TZ, wZ, E7e, y7e, bZ, wS, S7e, _7e, C7e, R7e, A7e, T7e, w7e, b7e, I7e, v7e, P7e, O7e, D7e, k7e, N7e, B7e, L7e, M7e, $7e, F7e, U7e, H7e, G7e, j7e, q7e, V7e, z7e, W7e, K7e, Q7e, Y7e, X7e, J7e, Z7e, eYe, tYe, rYe, oYe, nYe, sYe, iYe, aYe, Ak, IZ, cYe, pYe, uYe, mYe, lYe, Tk, dYe, vZ, fYe, hYe, gYe, xYe, EYe, yYe, SYe, _Ye, CYe, RYe, AYe, TYe, wu, wYe, wk, bYe, _n, Si, IYe, vYe, PYe, OYe, bk, DYe, PZ, kYe, Ik, NYe, BYe, LYe, MYe, $Ye, OZ, DZ, FYe, UYe, HYe, kZ, GYe, jYe, qYe, VYe, NZ, vk, zYe, WYe, KYe, QYe, YYe, XYe, BZ, JYe, Pk, ZYe, LZ, MZ, eXe, Ok, tXe, $Z, rXe, FZ, UZ, HZ, GZ, oXe, nXe, sXe, iXe, aXe, cXe, Ps, pXe, uXe, mXe, lXe, dXe, fXe, jZ, hXe, gXe, qZ, xXe, EXe, yXe, SXe, _Xe, CXe, bS, VZ, RXe, AXe, _i, TXe, wXe, bXe, IXe, vXe, PXe, OXe, DXe, kXe, NXe, BXe, LXe, MXe, Ci, Dk, zZ, Qf, $Xe, FXe, UXe, bu, HXe, GXe, jXe, WZ, qXe, VXe, kk, zXe, Nk, Bk, WXe, KXe, Yt, QXe, YXe, XXe, JXe, ZXe, eJe, Lk, KZ, tJe, QZ, rJe, YZ, oJe, Mk, nJe, sJe, $k, Os, iJe, XZ, aJe, JZ, cJe, pJe, uJe, IS, Cn, mJe, lJe, dJe, fJe, hJe, Iu, gJe, xJe, EJe, yJe, SJe, _Je, CJe, RJe, AJe, TJe, wJe, bJe, IJe, Fk, vJe, PJe, OJe, DJe, kJe, NJe, BJe, LJe, MJe, $Je, FJe, Yf, UJe, HJe, GJe, jJe, ZZ, qJe, VJe, zJe, WJe, KJe, QJe, YJe, XJe, eee, JJe, ZJe, vu, eZe, tee, ree, oee, nee, see, tZe, rZe, oZe, nZe, sZe, iZe, Ds, aZe, ns, ua, Uk, Xf, cZe, pZe, uZe, mZe, lZe, iee, dZe, fZe, aee, hZe, cee, gZe, xZe, EZe, pee, uee, yZe, SZe, mee, _Ze, CZe, RZe, AZe, TZe, wZe, bZe, IZe, ss, vZe, PZe, ma, OZe, lee, DZe, dee, fee, hee, la, gee, kZe, NZe, BZe, LZe, vS, Pu, MZe, $Ze, FZe, UZe, HZe, GZe, Jo, Jf, jZe, qZe, xee, Hk, VZe, zZe, WZe, KZe, QZe, YZe, XZe, JZe, ZZe, eet, tet, Eee, ret, oet, net, set, yee, Zf, iet, aet, cet, Gk, pet, uet, _o, met, det, fet, See, _ee, het, get, Cee, Ree, xet, Aee, Eet, yet, _et, Cet, Tee, Ret, jk, wee, Aet, bee, Tet, wet, bet, Iet, vet, Pet, Oet, Det, qk, Vk, zk, ks, ket, Net, Iee, Bet, eh, Wk, Let, Kk, PS, vee, Met, $et, Fet, Uet, Het, Pee, Get, jet, qet, Vet, Oee, zet, Wet, Dee, OS, kee, Qk, DS, Nee, Bee, Lee, Ket, Yk, Mee, $ee, Fee, Qet, Yet, Xet, Jet, Uee, Zet, Xk, Jk, Hee, Ri, ett, Zk, eN, ttt, rtt, ott, Gee, tN, jee, Ou, ntt, stt, itt, att, ctt, ptt, th, utt, mtt, qee, ltt, dtt, ftt, htt, De, gtt, xtt, Vee, Ett, ytt, Stt, _tt, Ctt, Rtt, Att, zee, Wee, Ttt, rN, wtt, oN, Kee, Qee, Yee, btt, Itt, vtt, Ptt, Ott, Dtt, nN, ktt, kS, Ntt, Btt, Ltt, Mtt, $tt, Ftt, Xee, Utt, Htt, Gtt, jtt, qtt, Vtt, ztt, Wtt, Ktt, Qtt, Ytt, Xtt, sN, Jtt, Ztt, ert, trt, rrt, ort, nrt, srt, irt, art, crt, prt, urt, mrt, lrt, drt, iN, NS, frt, hrt, grt, Ns, aN, xrt, et, Xe, Jee, Ert, ft, yrt, Srt, _rt, Zee, Crt, Rrt, x, Art, Trt, wrt, brt, Irt, pa, da, vrt, Prt, ete, tte, Ort, Drt, krt, Nrt, Brt, Lrt, Mrt, $rt, Frt, Urt, Hrt, Grt, rte, jrt, ote, nte, qrt, Vrt, fa, ste, zrt, Wrt, Krt, Qrt, Yrt, Xrt, Jrt, Zrt, eot, tot, rot, oot, not, sot, iot, aot, cot, pot, uot, mot, lot, dot, fot, hot, got, xot, Eot, yot, Sot, _ot, Cot, Rot, Aot, Tot, wot, bot, Iot, vot, Pot, Oot, Dot, kot, Not, Bot, Lot, Mot, $ot, Fot, Uot, Hot, Got, jot, qot, Vot, ite, zot, Wot, Kot, Qot, Yot, Xot, Jot, ate, Zot, ent, tnt, rnt, ont, nnt, snt, int, ant, cnt, pnt, unt, mnt, lnt, dnt, cte, fnt, hnt, cN, gnt, xnt, Ent, ynt, Snt, _nt, Cnt, Rnt, pte, Ant, Tnt, ute, wnt, mte, bnt, Int, vnt, Pnt, BS, Ont, Dnt, knt, Nnt, Bnt, lte, dte, Lnt, Mnt, $nt, Fnt, Unt, Hnt, Gnt, jnt, qnt, Vnt, znt, Wnt, Knt, Qnt, Ynt, Xnt, Jnt, Znt, Rn, rh, est, tst, rst, ost, nst, Tc, Bs, fte, sst, oh, ist, ast, cst, pst, ust, mst, lst, dst, fst, hst, gst, xst, Est, yst, Sst, _st, Cst, Rst, Ast, Tst, wst, bst, Ist, vst, Pst, Ost, Dst, kst, Nst, Bst, Lst, Mst, $st, pN, Fst, Ust, Hst, Gst, hte, nh, LS, jst, gte, uN, xte, Du, qst, Vst, Ete, zst, Wst, Kst, Qst, yte, Ste, Yst, Xst, Jst, Zst, eit, tit, rit, oit, nit, sit, iit, ait, cit, pit, uit, mit, lit, dit, fit, hit, git, xit, _te, Eit, yit, Sit, _it, Cit, Rit, Ait, Tit, wit, sh, bit, Cte, Iit, MS, Rte, vit, Pit, Oit, ku, Dit, kit, Nit, Bit, Lit, Mit, $S, $it, Fit, Uit, Hit, Git, jit, qit, FS, Ate, Vit, is, zit, Wit, Kit, Qit, mN, Yit, Xit, Jit, lN, Zit, eat, Tte, tat, rat, oat, wte, nat, sat, bte, Ite, iat, aat, cat, dN, fN, pat, uat, mat, Ls, lat, vte, dat, Pte, hN, Ai, Ote, fat, Dte, Mo, hat, gat, gN, aZ, as, kte, Nte, Bte, Lte, Mte, $te, Fte, Ute, Hte, Gte, jte, qte, Vte, zte, Wte, Kte, Qte, Yte, Xte, Jte, Zte, ere, tre, rre, ore, nre, sre, ire, are, cre, pre, ure, mre, lre, dre, fre, hre, gre, xre, Ere, yre, Sre, _re, Cre, Rre, Are, Tre, wre, bre, Ire, vre, Pre, Ore, Dre, kre, Nre, Bre, he = s(() => { Oe(); dk(); fk(); nQe = "Action", sQe = "ArchivalBackupArn", hk = "ApproximateCreationDateTimePrecision", iQe = "AttributeDefinition", aQe = "ArchivalDateTime", Vf = "AttributeDefinitions", cQe = "AttributeMap", pQe = "AccountMaxReadCapacityUnits", uQe = "AccountMaxWriteCapacityUnits", CS = "AttributeName", mQe = "ArchivalReason", cZ = "ArchivalSummary", pZ = "AutoScalingDisabled", lQe = "AutoScalingPolicyDescription", dQe = "AutoScalingPolicyDescriptionList", fQe = "AutoScalingPolicyUpdate", uZ = "AutoScalingRoleArn", hQe = "AutoScalingSettingsDescription", gQe = "AutoScalingSettingsUpdate", xQe = "AutoScalingTargetTrackingScalingPolicyConfigurationDescription", EQe = "AutoScalingTargetTrackingScalingPolicyConfigurationUpdate", yQe = "AttributeType", RS = "AttributesToGet", mZ = "AttributeUpdates", SQe = "AttributeValue", gk = "AttributeValueList", _Qe = "AttributeValueUpdate", CQe = "Address", xk = "Attributes", RQe = "Backfilling", zf = "BackupArn", lZ = "BackupCreationDateTime", Ek = "BackupDescription", yk = "BackupDetails", dZ = "BackupExpiryDateTime", AQe = "BatchExecuteStatement", TQe = "BatchExecuteStatementInput", wQe = "BatchExecuteStatementOutput", bQe = "BatchGetItem", IQe = "BatchGetItemInput", vQe = "BatchGetItemOutput", PQe = "BatchGetResponseMap", OQe = "BatchGetRequestMap", DQe = "BackupInUseException", Wf = "BillingMode", fZ = "BillingModeOverride", hZ = "BillingModeSummary", Sk = "BackupName", kQe = "BackupNotFoundException", NQe = "BOOL", gZ = "BackupStatus", xZ = "BackupSizeBytes", BQe = "BilledSizeBytes", LQe = "BatchStatementError", MQe = "BatchStatementRequest", $Qe = "BatchStatementResponse", FQe = "BS", UQe = "BackupSummary", EZ = "BackupSummaries", _k = "BackupType", HQe = "BatchWriteItem", GQe = "BatchWriteItemInput", jQe = "BatchWriteItemOutput", qQe = "BatchWriteItemRequestMap", VQe = "B", yZ = "Code", zQe = "CreateBackup", Ck = "ContinuousBackupsDescription", WQe = "CreateBackupInput", KQe = "CreateBackupOutput", QQe = "ContinuousBackupsStatus", YQe = "ContinuousBackupsUnavailableException", Lo = "ConsumedCapacity", XQe = "ConditionalCheckFailedException", JQe = "ConsumedCapacityMultiple", SZ = "ConditionCheck", _Z = "CreationDateTime", Ac = "ConditionExpression", ZQe = "CreateGlobalSecondaryIndexAction", e7e = "CreateGlobalTable", t7e = "CreateGlobalTableInput", r7e = "CreateGlobalTableOutput", o7e = "CreateGlobalTableWitnessGroupMemberAction", n7e = "ContributorInsightsAction", AS = "ContributorInsightsMode", s7e = "ContributorInsightsRuleList", i7e = "ContributorInsightsSummary", Rk = "ContributorInsightsStatus", CZ = "ContributorInsightsSummaries", RZ = "ComparisonOperator", Kf = "ConditionalOperator", a7e = "CsvOptions", c7e = "CachePeriodInMinutes", Tu = "ConsistentRead", p7e = "CreateReplicaAction", u7e = "CreateReplicationGroupMemberAction", m7e = "CancellationReasonList", l7e = "ConfirmRemoveSelfResourceAccess", AZ = "ClientRequestToken", d7e = "CancellationReason", f7e = "CancellationReasons", TS = "ClientToken", h7e = "CreateTableInput", g7e = "CreateTableOutput", x7e = "CreateTable", TZ = "CapacityUnits", wZ = "CloudWatchLogGroupArn", E7e = "Capacity", y7e = "Condition", bZ = "Count", wS = "Create", S7e = "Csv", _7e = "Delimiter", C7e = "DeleteBackup", R7e = "DeleteBackupInput", A7e = "DescribeBackupInput", T7e = "DeleteBackupOutput", w7e = "DescribeBackupOutput", b7e = "DescribeBackup", I7e = "DescribeContinuousBackups", v7e = "DescribeContinuousBackupsInput", P7e = "DescribeContinuousBackupsOutput", O7e = "DescribeContributorInsights", D7e = "DescribeContributorInsightsInput", k7e = "DescribeContributorInsightsOutput", N7e = "DescribeEndpoints", B7e = "DescribeExportInput", L7e = "DescribeExportOutput", M7e = "DescribeEndpointsRequest", $7e = "DescribeEndpointsResponse", F7e = "DescribeExport", U7e = "DeleteGlobalSecondaryIndexAction", H7e = "DescribeGlobalTable", G7e = "DescribeGlobalTableInput", j7e = "DescribeGlobalTableOutput", q7e = "DescribeGlobalTableSettings", V7e = "DescribeGlobalTableSettingsInput", z7e = "DescribeGlobalTableSettingsOutput", W7e = "DeleteGlobalTableWitnessGroupMemberAction", K7e = "DeleteItem", Q7e = "DuplicateItemException", Y7e = "DeleteItemInput", X7e = "DescribeImportInput", J7e = "DeleteItemOutput", Z7e = "DescribeImportOutput", eYe = "DescribeImport", tYe = "DescribeKinesisStreamingDestination", rYe = "DescribeKinesisStreamingDestinationInput", oYe = "DescribeKinesisStreamingDestinationOutput", nYe = "DisableKinesisStreamingDestination", sYe = "DescribeLimits", iYe = "DescribeLimitsInput", aYe = "DescribeLimitsOutput", Ak = "DeletionProtectionEnabled", IZ = "DeleteRequest", cYe = "DeleteReplicaAction", pYe = "DeleteReplicationGroupMemberAction", uYe = "DeleteResourcePolicy", mYe = "DeleteResourcePolicyInput", lYe = "DeleteResourcePolicyOutput", Tk = "DestinationStatus", dYe = "DestinationStatusDescription", vZ = "DisableScaleIn", fYe = "DeleteTable", hYe = "DeleteTableInput", gYe = "DescribeTableInput", xYe = "DeleteTableOutput", EYe = "DescribeTableOutput", yYe = "DescribeTableReplicaAutoScaling", SYe = "DescribeTableReplicaAutoScalingInput", _Ye = "DescribeTableReplicaAutoScalingOutput", CYe = "DescribeTimeToLive", RYe = "DescribeTimeToLiveInput", AYe = "DescribeTimeToLiveOutput", TYe = "DescribeTable", wu = "Delete", wYe = "Error", wk = "ExportArn", bYe = "ExpectedAttributeMap", _n = "ExpressionAttributeNames", Si = "ExpressionAttributeValues", IYe = "ExpressionAttributeValueMap", vYe = "ExpectedAttributeValue", PYe = "ErrorCount", OYe = "ExportConflictException", bk = "ExportDescription", DYe = "ExceptionDescription", PZ = "ExportFormat", kYe = "ExportFromTime", Ik = "EnableKinesisStreamingConfiguration", NYe = "EnableKinesisStreamingDestination", BYe = "ExportManifest", LYe = "ExceptionName", MYe = "ExportNotFoundException", $Ye = "EarliestRestorableDateTime", OZ = "ExpectedRevisionId", DZ = "ExportStatus", FYe = "ExclusiveStartBackupArn", UYe = "ExclusiveStartGlobalTableName", HYe = "ExecuteStatementInput", kZ = "ExclusiveStartKey", GYe = "ExecuteStatementOutput", jYe = "ExclusiveStartTableName", qYe = "ExportSummary", VYe = "ExecuteStatement", NZ = "ExportSummaries", vk = "EndTime", zYe = "ExecuteTransactionInput", WYe = "ExecuteTransactionOutput", KYe = "ExportToTime", QYe = "ExportTableToPointInTime", YYe = "ExportTableToPointInTimeInput", XYe = "ExportTableToPointInTimeOutput", BZ = "ExportTime", JYe = "ExecuteTransaction", Pk = "ExportType", ZYe = "ExportViewType", LZ = "Endpoints", MZ = "Enabled", eXe = "Endpoint", Ok = "Expected", tXe = "Exists", $Z = "FailureCode", rXe = "FilterConditionMap", FZ = "FailureException", UZ = "FilterExpression", HZ = "FailureMessage", GZ = "Get", oXe = "GetItem", nXe = "GetItemInput", sXe = "GetItemOutput", iXe = "GetResourcePolicy", aXe = "GetResourcePolicyInput", cXe = "GetResourcePolicyOutput", Ps = "GlobalSecondaryIndexes", pXe = "GlobalSecondaryIndexAutoScalingUpdate", uXe = "GlobalSecondaryIndexAutoScalingUpdateList", mXe = "GlobalSecondaryIndexDescription", lXe = "GlobalSecondaryIndexDescriptionList", dXe = "GlobalSecondaryIndexInfo", fXe = "GlobalSecondaryIndexList", jZ = "GlobalSecondaryIndexOverride", hXe = "GlobalSecondaryIndexUpdate", gXe = "GlobalSecondaryIndexUpdateList", qZ = "GlobalSecondaryIndexUpdates", xXe = "GlobalSecondaryIndexWarmThroughputDescription", EXe = "GlobalSecondaryIndex", yXe = "GlobalTable", SXe = "GlobalTableArn", _Xe = "GlobalTableAlreadyExistsException", CXe = "GlobalTableBillingMode", bS = "GlobalTableDescription", VZ = "GlobalTableGlobalSecondaryIndexSettingsUpdate", RXe = "GlobalTableGlobalSecondaryIndexSettingsUpdateList", AXe = "GlobalTableList", _i = "GlobalTableName", TXe = "GlobalTableNotFoundException", wXe = "GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate", bXe = "GlobalTableProvisionedWriteCapacityUnits", IXe = "GlobalTableStatus", vXe = "GlobalTableVersion", PXe = "GlobalTableWitnesses", OXe = "GlobalTableWitnessDescription", DXe = "GlobalTableWitnessDescriptionList", kXe = "GlobalTableWitnessGroupUpdate", NXe = "GlobalTableWitnessGroupUpdateList", BXe = "GlobalTableWitnessUpdates", LXe = "GlobalTables", MXe = "HeaderList", Ci = "Item", Dk = "ImportArn", zZ = "IndexArn", Qf = "ItemCount", $Xe = "ImportConflictException", FXe = "ItemCollectionKey", UXe = "ItemCollectionKeyAttributeMap", bu = "ItemCollectionMetrics", HXe = "ItemCollectionMetricsMultiple", GXe = "ItemCollectionMetricsPerTable", jXe = "ItemCollectionSizeLimitExceededException", WZ = "InputCompressionType", qXe = "InaccessibleEncryptionDateTime", VXe = "InvalidEndpointException", kk = "IncrementalExportSpecification", zXe = "InvalidExportTimeException", Nk = "InputFormat", Bk = "InputFormatOptions", WXe = "ImportedItemCount", KXe = "ItemList", Yt = "IndexName", QXe = "ImportNotFoundException", YXe = "IndexNotFoundException", XXe = "IdempotentParameterMismatchException", JXe = "ItemResponse", ZXe = "ItemResponseList", eJe = "InvalidRestoreTimeException", Lk = "IndexStatus", KZ = "IndexSizeBytes", tJe = "InternalServerError", QZ = "ImportSummaryList", rJe = "ImportSummary", YZ = "ImportStatus", oJe = "ImportTable", Mk = "ImportTableDescription", nJe = "ImportTableInput", sJe = "ImportTableOutput", $k = "Items", Os = "Key", iJe = "KeysAndAttributes", XZ = "KeyConditions", aJe = "KeyConditionExpression", JZ = "KinesisDataStreamDestinations", cJe = "KinesisDataStreamDestination", pJe = "KeyList", uJe = "KMSMasterKeyArn", IS = "KMSMasterKeyId", Cn = "KeySchema", mJe = "KinesisStreamingDestinationInput", lJe = "KinesisStreamingDestinationOutput", dJe = "KeySchemaElement", fJe = "KeyType", hJe = "Keys", Iu = "Limit", gJe = "ListAttributeValue", xJe = "ListBackups", EJe = "ListBackupsInput", yJe = "ListBackupsOutput", SJe = "ListContributorInsights", _Je = "ListContributorInsightsInput", CJe = "ListContributorInsightsOutput", RJe = "LastDecreaseDateTime", AJe = "ListExports", TJe = "LastEvaluatedBackupArn", wJe = "LimitExceededException", bJe = "LastEvaluatedGlobalTableName", IJe = "ListExportsInput", Fk = "LastEvaluatedKey", vJe = "ListExportsOutput", PJe = "LastEvaluatedTableName", OJe = "ListGlobalTables", DJe = "ListGlobalTablesInput", kJe = "ListGlobalTablesOutput", NJe = "ListImports", BJe = "LastIncreaseDateTime", LJe = "ListImportsInput", MJe = "ListImportsOutput", $Je = "LatestRestorableDateTime", FJe = "LatestStreamArn", Yf = "LocalSecondaryIndexes", UJe = "LocalSecondaryIndexDescription", HJe = "LocalSecondaryIndexDescriptionList", GJe = "LocalSecondaryIndexInfo", jJe = "LocalSecondaryIndexList", ZZ = "LocalSecondaryIndexOverride", qJe = "LocalSecondaryIndex", VJe = "LatestStreamLabel", zJe = "ListTables", WJe = "ListTablesInput", KJe = "ListTablesOutput", QJe = "ListTagsOfResource", YJe = "ListTagsOfResourceInput", XJe = "ListTagsOfResourceOutput", eee = "LastUpdateDateTime", JJe = "LastUpdateToPayPerRequestDateTime", ZJe = "L", vu = "Message", eZe = "MapAttributeValue", tee = "MaxResults", ree = "MultiRegionConsistency", oee = "MaxReadRequestUnits", nee = "MinimumUnits", see = "MaximumUnits", tZe = "MaxWriteRequestUnits", rZe = "M", oZe = "N", nZe = "NonKeyAttributes", sZe = "NumberOfDecreasesToday", iZe = "NS", Ds = "NextToken", aZe = "NULL", ns = "OnDemandThroughput", ua = "OnDemandThroughputOverride", Uk = "Parameters", Xf = "ProjectionExpression", cZe = "PutItem", pZe = "ProcessedItemCount", uZe = "PutItemInput", mZe = "PutItemInputAttributeMap", lZe = "PutItemOutput", iee = "PointInTimeRecoveryDescription", dZe = "PointInTimeRecoveryEnabled", fZe = "PointInTimeRecoveryStatus", aee = "PointInTimeRecoverySpecification", hZe = "PointInTimeRecoveryUnavailableException", cee = "PolicyName", gZe = "PolicyNotFoundException", xZe = "PartiQLBatchRequest", EZe = "PartiQLBatchResponse", pee = "PutRequest", uee = "ProvisionedReadCapacityAutoScalingSettings", yZe = "ProvisionedReadCapacityAutoScalingSettingsUpdate", SZe = "ProvisionedReadCapacityAutoScalingUpdate", mee = "ProvisionedReadCapacityUnits", _Ze = "PutResourcePolicy", CZe = "PutResourcePolicyInput", RZe = "PutResourcePolicyOutput", AZe = "PageSize", TZe = "ProcessedSizeBytes", wZe = "PreparedStatementParameters", bZe = "ParameterizedStatement", IZe = "ParameterizedStatements", ss = "ProvisionedThroughput", vZe = "ProvisionedThroughputDescription", PZe = "ProvisionedThroughputExceededException", ma = "ProvisionedThroughputOverride", OZe = "ProjectionType", lee = "ProvisionedWriteCapacityAutoScalingSettings", DZe = "ProvisionedWriteCapacityAutoScalingSettingsUpdate", dee = "ProvisionedWriteCapacityAutoScalingUpdate", fee = "ProvisionedWriteCapacityUnits", hee = "Policy", la = "Projection", gee = "Put", kZe = "Query", NZe = "QueryFilter", BZe = "QueryInput", LZe = "QueryOutput", vS = "Responses", Pu = "ResourceArn", MZe = "ReplicaAlreadyExistsException", $Ze = "ReplicaAutoScalingDescription", FZe = "ReplicaAutoScalingDescriptionList", UZe = "ReplicaAutoScalingUpdate", HZe = "ReplicaAutoScalingUpdateList", GZe = "ReplicaBillingModeSummary", Jo = "ReturnConsumedCapacity", Jf = "ReadCapacityUnits", jZe = "ReplicaDescription", qZe = "ReplicaDescriptionList", xee = "RestoreDateTime", Hk = "ReplicationGroup", VZe = "ReplicaGlobalSecondaryIndex", zZe = "ReplicaGlobalSecondaryIndexAutoScalingDescription", WZe = "ReplicaGlobalSecondaryIndexAutoScalingDescriptionList", KZe = "ReplicaGlobalSecondaryIndexAutoScalingUpdate", QZe = "ReplicaGlobalSecondaryIndexAutoScalingUpdateList", YZe = "ReplicaGlobalSecondaryIndexDescription", XZe = "ReplicaGlobalSecondaryIndexDescriptionList", JZe = "ReplicaGlobalSecondaryIndexList", ZZe = "ReplicaGlobalSecondaryIndexSettings", eet = "ReplicaGlobalSecondaryIndexSettingsDescription", tet = "ReplicaGlobalSecondaryIndexSettingsDescriptionList", Eee = "ReplicaGlobalSecondaryIndexSettingsUpdate", ret = "ReplicaGlobalSecondaryIndexSettingsUpdateList", oet = "ReplicaGlobalSecondaryIndexUpdates", net = "ReplicationGroupUpdate", set = "ReplicationGroupUpdateList", yee = "RequestItems", Zf = "ReturnItemCollectionMetrics", iet = "ReplicaInaccessibleDateTime", aet = "RestoreInProgress", cet = "ResourceInUseException", Gk = "RevisionId", pet = "ReplicaList", uet = "RequestLimitExceeded", _o = "RegionName", met = "ReplicaNotFoundException", det = "ResourceNotFoundException", fet = "ResourcePolicy", See = "RecoveryPeriodInDays", _ee = "ReplicaProvisionedReadCapacityAutoScalingSettings", het = "ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate", get = "ReplicaProvisionedReadCapacityAutoScalingUpdate", Cee = "ReplicaProvisionedReadCapacityUnits", Ree = "ReplicaProvisionedWriteCapacityAutoScalingSettings", xet = "ReplicaProvisionedWriteCapacityUnits", Aee = "ReplicaSettings", Eet = "ReplicaStatusDescription", yet = "ReplicaSettingsDescriptionList", _et = "ReplicaSettingsDescription", Cet = "ReplicaStatusPercentProgress", Tee = "ReplicaSettingsUpdate", Ret = "ReplicaSettingsUpdateList", jk = "ReplicaStatus", wee = "RestoreSummary", Aet = "ReplicaTableClass", bee = "ReplicaTableClassSummary", Tet = "RestoreTableFromBackup", wet = "RestoreTableFromBackupInput", bet = "RestoreTableFromBackupOutput", Iet = "RestoreTableToPointInTime", vet = "RestoreTableToPointInTimeInput", Pet = "RestoreTableToPointInTimeOutput", Oet = "ReplicaUpdate", Det = "ReplicaUpdateList", qk = "ReadUnitsPerSecond", Vk = "ReplicaUpdates", zk = "ReturnValues", ks = "ReturnValuesOnConditionCheckFailure", ket = "ReplicatedWriteConflictException", Net = "Replica", Iee = "Replicas", Bet = "Statements", eh = "StreamArn", Wk = "S3Bucket", Let = "SourceBackupArn", Kk = "S3BucketOwner", PS = "S3BucketSource", vee = "ScannedCount", Met = "StreamDescription", $et = "StreamEnabled", Fet = "SizeEstimateRangeGB", Uet = "ScanFilter", Het = "ScanInput", Pee = "ScaleInCooldown", Get = "SecondaryIndexesCapacityMap", jet = "ScanIndexForward", qet = "S3KeyPrefix", Vet = "ScanOutput", Oee = "ScaleOutCooldown", zet = "ScalingPolicies", Wet = "ScalingPolicyUpdate", Dee = "S3Prefix", OS = "StreamSpecification", kee = "S3SseAlgorithm", Qk = "SSEDescription", DS = "SSESpecification", Nee = "SSESpecificationOverride", Bee = "SSEType", Lee = "S3SseKmsKeyId", Ket = "SS", Yk = "StartTime", Mee = "SourceTableArn", $ee = "SourceTableDetails", Fee = "SourceTableFeatureDetails", Qet = "SourceTableName", Yet = "StreamViewType", Xet = "S", Jet = "Scan", Uee = "Select", Zet = "Segment", Xk = "Statement", Jk = "Status", Hee = "Table", Ri = "TableArn", ett = "TableAlreadyExistsException", Zk = "TableAutoScalingDescription", eN = "TableClass", ttt = "TableCreationDateTime", rtt = "TransactionCanceledException", ott = "TransactionConflictException", Gee = "TableClassOverride", tN = "TableCreationParameters", jee = "TableClassSummary", Ou = "TableDescription", ntt = "ThrottlingException", stt = "TransactGetItem", itt = "TransactGetItemsInput", att = "TransactGetItemList", ctt = "TransactGetItemsOutput", ptt = "TransactGetItems", th = "TableId", utt = "TransactionInProgressException", mtt = "TableInUseException", qee = "TransactItems", ltt = "TagKeys", dtt = "TagList", ftt = "TableMaxReadCapacityUnits", htt = "TableMaxWriteCapacityUnits", De = "TableName", gtt = "TableNotFoundException", xtt = "TableNames", Vee = "ThrottlingReasons", Ett = "TagResourceInput", ytt = "ThrottlingReasonList", Stt = "TimeRangeLowerBound", _tt = "TimeRangeUpperBound", Ctt = "TagResource", Rtt = "ThrottlingReason", Att = "TransactStatements", zee = "TableSizeBytes", Wee = "TableStatus", Ttt = "TotalSegments", rN = "TimeToLiveDescription", wtt = "TimeToLiveStatus", oN = "TimeToLiveSpecification", Kee = "TargetTableName", Qee = "TargetTrackingScalingPolicyConfiguration", Yee = "TargetValue", btt = "TransactWriteItem", Itt = "TransactWriteItemsInput", vtt = "TransactWriteItemList", Ptt = "TransactWriteItemsOutput", Ott = "TransactWriteItems", Dtt = "TableWarmThroughputDescription", nN = "Tags", ktt = "Tag", kS = "Update", Ntt = "UpdateContinuousBackups", Btt = "UpdateContinuousBackupsInput", Ltt = "UpdateContinuousBackupsOutput", Mtt = "UpdateContributorInsights", $tt = "UpdateContributorInsightsInput", Ftt = "UpdateContributorInsightsOutput", Xee = "UpdateExpression", Utt = "UpdateGlobalSecondaryIndexAction", Htt = "UpdateGlobalTable", Gtt = "UpdateGlobalTableInput", jtt = "UpdateGlobalTableOutput", qtt = "UpdateGlobalTableSettings", Vtt = "UpdateGlobalTableSettingsInput", ztt = "UpdateGlobalTableSettingsOutput", Wtt = "UnprocessedItems", Ktt = "UpdateItemInput", Qtt = "UpdateItemOutput", Ytt = "UpdateItem", Xtt = "UnprocessedKeys", sN = "UpdateKinesisStreamingConfiguration", Jtt = "UpdateKinesisStreamingDestination", Ztt = "UpdateKinesisStreamingDestinationInput", ert = "UpdateKinesisStreamingDestinationOutput", trt = "UseLatestRestorableTime", rrt = "UntagResource", ort = "UpdateReplicationGroupMemberAction", nrt = "UntagResourceInput", srt = "UpdateTable", irt = "UpdateTableInput", art = "UpdateTableOutput", crt = "UpdateTableReplicaAutoScaling", prt = "UpdateTableReplicaAutoScalingInput", urt = "UpdateTableReplicaAutoScalingOutput", mrt = "UpdateTimeToLive", lrt = "UpdateTimeToLiveInput", drt = "UpdateTimeToLiveOutput", iN = "Value", NS = "WriteCapacityUnits", frt = "WriteRequest", hrt = "WriteRequests", grt = "WitnessStatus", Ns = "WarmThroughput", aN = "WriteUnitsPerSecond", xrt = "awsQueryError", et = "client", Xe = "error", Jee = "httpError", Ert = "httpHeader", ft = "message", yrt = "reason", Srt = "resource", _rt = "server", Zee = "smithy.ts.sdk.synthetic.com.amazonaws.dynamodb", Crt = "throttlingReasons", Rrt = "x-amz-confirm-remove-self-resource-access", x = "com.amazonaws.dynamodb", Art = [3, x, cZ, 0, [aQe, mQe, sQe], [4, 0, 0]], Trt = [3, x, iQe, 0, [CS, yQe], [0, 0]], wrt = [3, x, _Qe, 0, [iN, nQe], [() => as, 0]], brt = [3, x, lQe, 0, [cee, Qee], [0, () => vrt]], Irt = [3, x, fQe, 0, [cee, Qee], [0, () => Prt]], pa = [3, x, hQe, 0, [nee, see, pZ, uZ, zet], [1, 1, 2, 0, () => vit]], da = [3, x, gQe, 0, [nee, see, pZ, uZ, Wet], [1, 1, 2, 0, () => Irt]], vrt = [3, x, xQe, 0, [vZ, Pee, Oee, Yee], [2, 1, 1, 1]], Prt = [3, x, EQe, 0, [vZ, Pee, Oee, Yee], [2, 1, 1, 1]], ete = [3, x, Ek, 0, [yk, $ee, Fee], [() => tte, () => Hst, () => Gst]], tte = [3, x, yk, 0, [zf, Sk, xZ, gZ, _k, lZ, dZ], [0, 0, 1, 0, 0, 4, 4]], Ort = [-3, x, DQe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Ort, Hy); Drt = [-3, x, kQe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Drt, Gy); krt = [3, x, UQe, 0, [De, th, Ri, zf, Sk, lZ, dZ, gZ, _k, xZ], [0, 0, 0, 0, 0, 4, 4, 0, 0, 1]], Nrt = [3, x, TQe, 0, [Bet, Jo], [() => Xit, 0]], Brt = [3, x, wQe, 0, [vS, Lo], [() => Jit, () => ku]], Lrt = [3, x, IQe, 0, [yee, Jo], [() => vte, 0]], Mrt = [3, x, vQe, 0, [vS, Xtt, Lo], [() => dat, () => vte, () => ku]], $rt = [3, x, LQe, 0, [yZ, vu, Ci], [0, 0, () => Ls]], Frt = [3, x, MQe, 0, [Xk, Uk, Tu, ks], [0, () => lN, 2, 0]], Urt = [3, x, $Qe, 0, [wYe, De, Ci], [() => $rt, 0, () => Ls]], Hrt = [3, x, GQe, 0, [yee, Jo, Zf], [() => Pte, 0, 0]], Grt = [3, x, jQe, 0, [Wtt, bu, Lo], [() => Pte, () => Dte, () => ku]], rte = [3, x, hZ, 0, [Wf, JJe], [0, 4]], jrt = [3, x, d7e, 0, [Ci, yZ, vu], [() => Ls, 0, 0]], ote = [3, x, E7e, 0, [Jf, NS, TZ], [1, 1, 1]], nte = [3, x, y7e, 0, [gk, RZ], [() => Rte, 0]], qrt = [-3, x, XQe, { [Xe]: et }, [ft, Ci], [0, () => Ls]]; k.for(x).registerError(qrt, SS); Vrt = [3, x, SZ, 0, [Os, De, Ac, _n, Si, ks], [() => Mo, 0, 0, 128, () => Ai, 0]], fa = [3, x, Lo, 0, [De, TZ, Jf, NS, Hee, Yf, Ps], [0, 1, 1, 1, () => ote, () => aZ, () => aZ]], ste = [3, x, Ck, 0, [QQe, iee], [0, () => tst]], zrt = [-3, x, YQe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(zrt, Xy); Wrt = [3, x, i7e, 0, [De, Yt, Rk, AS], [0, 0, 0, 0]], Krt = [3, x, WQe, 0, [De, Sk], [0, 0]], Qrt = [3, x, KQe, 0, [yk], [() => tte]], Yrt = [3, x, ZQe, 0, [Yt, Cn, la, ss, ns, Ns], [0, () => is, () => Tc, () => Bs, () => Rn, () => sh]], Xrt = [3, x, t7e, 0, [_i, Hk], [0, () => bte]], Jrt = [3, x, r7e, 0, [bS], [() => cN]], Zrt = [3, x, o7e, 0, [_o], [0]], eot = [3, x, p7e, 0, [_o], [0]], tot = [3, x, u7e, 0, [_o, IS, ma, ua, Ps, Gee], [0, 0, () => oh, () => rh, () => wte, 0]], rot = [3, x, h7e, 0, [Vf, De, Cn, Yf, Ps, Wf, ss, OS, DS, nN, eN, Ak, Ns, fet, ns], [() => MS, 0, () => is, () => mN, () => $S, 0, () => Bs, () => LS, () => nh, () => dN, 0, 2, () => sh, 0, () => Rn]], oot = [3, x, g7e, 0, [Ou], [() => Du]], not = [3, x, a7e, 0, [_7e, MXe], [0, 64]], sot = [3, x, wu, 0, [Os, De, Ac, _n, Si, ks], [() => Mo, 0, 0, 128, () => Ai, 0]], iot = [3, x, R7e, 0, [zf], [0]], aot = [3, x, T7e, 0, [Ek], [() => ete]], cot = [3, x, U7e, 0, [Yt], [0]], pot = [3, x, W7e, 0, [_o], [0]], uot = [3, x, Y7e, 0, [De, Os, Ok, Kf, zk, Jo, Zf, Ac, _n, Si, ks], [0, () => Mo, () => hN, 0, 0, 0, 0, 0, 128, () => Ai, 0]], mot = [3, x, J7e, 0, [xk, Lo, bu], [() => Ls, () => fa, () => BS]], lot = [3, x, cYe, 0, [_o], [0]], dot = [3, x, pYe, 0, [_o], [0]], fot = [3, x, IZ, 0, [Os], [() => Mo]], hot = [3, x, mYe, 0, [Pu, OZ], [0, 0]], got = [3, x, lYe, 0, [Gk], [0]], xot = [3, x, hYe, 0, [De], [0]], Eot = [3, x, xYe, 0, [Ou], [() => Du]], yot = [3, x, A7e, 0, [zf], [0]], Sot = [3, x, w7e, 0, [Ek], [() => ete]], _ot = [3, x, v7e, 0, [De], [0]], Cot = [3, x, P7e, 0, [Ck], [() => ste]], Rot = [3, x, D7e, 0, [De, Yt], [0, 0]], Aot = [3, x, k7e, 0, [De, Yt, s7e, Rk, eee, FZ, AS], [0, 0, 64, 0, 4, () => ont, 0]], Tot = [3, x, M7e, 0, [], []], wot = [3, x, $7e, 0, [LZ], [() => kit]], bot = [3, x, B7e, 0, [wk], [0]], Iot = [3, x, L7e, 0, [bk], [() => ate]], vot = [3, x, G7e, 0, [_i], [0]], Pot = [3, x, j7e, 0, [bS], [() => cN]], Oot = [3, x, V7e, 0, [_i], [0]], Dot = [3, x, z7e, 0, [_i, Aee], [0, () => Ite]], kot = [3, x, X7e, 0, [Dk], [0]], Not = [3, x, Z7e, 0, [Mk], [() => pte]], Bot = [3, x, rYe, 0, [De], [0]], Lot = [3, x, oYe, 0, [De, JZ], [0, () => zit]], Mot = [3, x, iYe, 0, [], []], $ot = [3, x, aYe, 0, [pQe, uQe, ftt, htt], [1, 1, 1, 1]], Fot = [3, x, gYe, 0, [De], [0]], Uot = [3, x, EYe, 0, [Hee], [() => Du]], Hot = [3, x, SYe, 0, [De], [0]], Got = [3, x, _Ye, 0, [Zk], [() => gte]], jot = [3, x, RYe, 0, [De], [0]], qot = [3, x, AYe, 0, [rN], [() => yte]], Vot = [-3, x, Q7e, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Vot, cS); ite = [3, x, Ik, 0, [hk], [0]], zot = [3, x, eXe, 0, [CQe, c7e], [0, 1]], Wot = [3, x, HYe, 0, [Xk, Uk, Tu, Ds, Jo, Iu, ks], [0, () => lN, 2, 0, 0, 1, 0]], Kot = [3, x, GYe, 0, [$k, Ds, Lo, Fk], [() => FS, 0, () => fa, () => Mo]], Qot = [3, x, zYe, 0, [Att, AZ, Jo], [() => Yit, [0, 4], 0]], Yot = [3, x, WYe, 0, [vS, Lo], [() => Ate, () => ku]], Xot = [3, x, vYe, 0, [iN, tXe, RZ, gk], [() => as, 2, 0, () => Rte]], Jot = [-3, x, OYe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Jot, mS); ate = [3, x, bk, 0, [wk, DZ, Yk, vk, BYe, Ri, th, BZ, TS, Wk, Kk, Dee, kee, Lee, $Z, HZ, PZ, BQe, Qf, Pk, kk], [0, 0, 4, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, () => ute]], Zot = [-3, x, MYe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Zot, sS); ent = [3, x, qYe, 0, [wk, DZ, Pk], [0, 0, 0]], tnt = [3, x, YYe, 0, [Ri, BZ, TS, Wk, Kk, Dee, kee, Lee, PZ, Pk, kk], [0, 4, [0, 4], 0, 0, 0, 0, 0, 0, 0, () => ute]], rnt = [3, x, XYe, 0, [bk], [() => ate]], ont = [3, x, FZ, 0, [LYe, DYe], [0, 0]], nnt = [3, x, GZ, 0, [Os, De, Xf, _n], [() => Mo, 0, 0, 128]], snt = [3, x, nXe, 0, [De, Os, RS, Tu, Jo, Xf, _n], [0, () => Mo, 64, 2, 0, 0, 128]], int = [3, x, sXe, 0, [Ci, Lo], [() => Ls, () => fa]], ant = [3, x, aXe, 0, [Pu], [0]], cnt = [3, x, cXe, 0, [hee, Gk], [0, 0]], pnt = [3, x, EXe, 0, [Yt, Cn, la, ss, ns, Ns], [0, () => is, () => Tc, () => Bs, () => Rn, () => sh]], unt = [3, x, pXe, 0, [Yt, dee], [0, () => da]], mnt = [3, x, mXe, 0, [Yt, Cn, la, Lk, RQe, ss, KZ, Qf, zZ, ns, Ns], [0, () => is, () => Tc, 0, 2, () => fte, 1, 1, 0, () => Rn, () => cte]], lnt = [3, x, dXe, 0, [Yt, Cn, la, ss, ns], [0, () => is, () => Tc, () => Bs, () => Rn]], dnt = [3, x, hXe, 0, [kS, wS, wu], [() => mit, () => Yrt, () => cot]], cte = [3, x, xXe, 0, [qk, aN, Jk], [1, 1, 0]], fnt = [3, x, yXe, 0, [_i, Hk], [0, () => bte]], hnt = [-3, x, _Xe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(hnt, tS); cN = [3, x, bS, 0, [Hk, SXe, _Z, IXe, _i], [() => Tte, 0, 4, 0, 0]], gnt = [3, x, VZ, 0, [Yt, fee, DZe], [0, 1, () => da]], xnt = [-3, x, TXe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(xnt, iS); Ent = [3, x, OXe, 0, [_o, grt], [0, 0]], ynt = [3, x, kXe, 0, [wS, wu], [() => Zrt, () => pot]], Snt = [-3, x, XXe, { [Xe]: et }, [vu], [0]]; k.for(x).registerError(Snt, pS); _nt = [-3, x, $Xe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(_nt, fS); Cnt = [-3, x, QXe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Cnt, aS); Rnt = [3, x, rJe, 0, [Dk, YZ, Ri, PS, wZ, Nk, Yk, vk], [0, 0, 0, () => pN, 0, 0, 4, 4]], pte = [3, x, Mk, 0, [Dk, YZ, Ri, th, TS, PS, PYe, wZ, Nk, Bk, WZ, tN, Yk, vk, TZe, pZe, WXe, $Z, HZ], [0, 0, 0, 0, 0, () => pN, 1, 0, 0, () => mte, 0, () => xte, 4, 4, 1, 1, 1, 0, 0]], Ant = [3, x, nJe, 0, [TS, PS, Nk, Bk, WZ, tN], [[0, 4], () => pN, 0, () => mte, 0, () => xte]], Tnt = [3, x, sJe, 0, [Mk], [() => pte]], ute = [3, x, kk, 0, [kYe, KYe, ZYe], [4, 4, 0]], wnt = [-3, x, YXe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(wnt, yS); mte = [3, x, Bk, 0, [S7e], [() => not]], bnt = [-3, x, tJe, { [Xe]: _rt }, [ft], [0]]; k.for(x).registerError(bnt, jy); Int = [-3, x, VXe, { [Xe]: et, [Jee]: 421 }, [vu], [0]]; k.for(x).registerError(Int, zy); vnt = [-3, x, zXe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(vnt, lS); Pnt = [-3, x, eJe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Pnt, gS); BS = [3, x, bu, 0, [FXe, Fet], [() => fat, 65]], Ont = [-3, x, jXe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Ont, Qy); Dnt = [3, x, JXe, 0, [Ci], [() => Ls]], knt = [3, x, iJe, 0, [hJe, RS, Tu, Xf, _n], [() => Vit, 64, 2, 0, 128]], Nnt = [3, x, dJe, 0, [CS, fJe], [0, 0]], Bnt = [3, x, cJe, 0, [eh, Tk, dYe, hk], [0, 0, 0, 0]], lte = [3, x, mJe, 0, [De, eh, Ik], [0, 0, () => ite]], dte = [3, x, lJe, 0, [De, eh, Tk, Ik], [0, 0, 0, () => ite]], Lnt = [-3, x, wJe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Lnt, Jy); Mnt = [3, x, EJe, 0, [De, Iu, Stt, _tt, FYe, _k], [0, 1, 4, 4, 0, 0]], $nt = [3, x, yJe, 0, [EZ, TJe], [() => Pit, 0]], Fnt = [3, x, _Je, 0, [De, Ds, tee], [0, 0, 1]], Unt = [3, x, CJe, 0, [CZ, Ds], [() => Dit, 0]], Hnt = [3, x, IJe, 0, [Ri, tee, Ds], [0, 1, 0]], Gnt = [3, x, vJe, 0, [NZ, Ds], [() => Nit, 0]], jnt = [3, x, DJe, 0, [UYe, Iu, _o], [0, 1, 0]], qnt = [3, x, kJe, 0, [LXe, bJe], [() => Uit, 0]], Vnt = [3, x, LJe, 0, [Ri, AZe, Ds], [0, 1, 0]], znt = [3, x, MJe, 0, [QZ, Ds], [() => jit, 0]], Wnt = [3, x, WJe, 0, [jYe, Iu], [0, 1]], Knt = [3, x, KJe, 0, [xtt, PJe], [64, 0]], Qnt = [3, x, YJe, 0, [Pu, Ds], [0, 0]], Ynt = [3, x, XJe, 0, [nN, Ds], [() => dN, 0]], Xnt = [3, x, qJe, 0, [Yt, Cn, la], [0, () => is, () => Tc]], Jnt = [3, x, UJe, 0, [Yt, Cn, la, KZ, Qf, zZ], [0, () => is, () => Tc, 1, 1, 0]], Znt = [3, x, GJe, 0, [Yt, Cn, la], [0, () => is, () => Tc]], Rn = [3, x, ns, 0, [oee, tZe], [1, 1]], rh = [3, x, ua, 0, [oee], [1]], est = [3, x, bZe, 0, [Xk, Uk, ks], [0, () => lN, 0]], tst = [3, x, iee, 0, [fZe, See, $Ye, $Je], [0, 1, 4, 4]], rst = [3, x, aee, 0, [dZe, See], [2, 1]], ost = [-3, x, hZe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(ost, dS); nst = [-3, x, gZe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(nst, nS); Tc = [3, x, la, 0, [OZe, nZe], [0, 64]], Bs = [3, x, ss, 0, [Jf, NS], [1, 1]], fte = [3, x, vZe, 0, [BJe, RJe, sZe, Jf, NS], [4, 4, 1, 1, 1]], sst = [-3, x, PZe, { [Xe]: et }, [ft, Vee], [0, () => fN]]; k.for(x).registerError(sst, Wy); oh = [3, x, ma, 0, [Jf], [1]], ist = [3, x, gee, 0, [Ci, De, Ac, _n, Si, ks], [() => gN, 0, 0, 128, () => Ai, 0]], ast = [3, x, uZe, 0, [De, Ci, Ok, zk, Jo, Zf, Kf, Ac, _n, Si, ks], [0, () => gN, () => hN, 0, 0, 0, 0, 0, 128, () => Ai, 0]], cst = [3, x, lZe, 0, [xk, Lo, bu], [() => Ls, () => fa, () => BS]], pst = [3, x, pee, 0, [Ci], [() => gN]], ust = [3, x, CZe, 0, [Pu, hee, OZ, l7e], [0, 0, 0, [2, { [Ert]: Rrt }]]], mst = [3, x, RZe, 0, [Gk], [0]], lst = [3, x, BZe, 0, [De, Yt, Uee, RS, Iu, Tu, XZ, NZe, Kf, jet, kZ, Jo, Xf, UZ, aJe, _n, Si], [0, 0, 0, 64, 1, 2, () => hat, () => Ote, 0, 2, () => Mo, 0, 0, 0, 0, 128, () => Ai]], dst = [3, x, LZe, 0, [$k, bZ, vee, Fk, Lo], [() => FS, 1, 1, () => Mo, () => fa]], fst = [3, x, Net, 0, [_o], [0]], hst = [-3, x, MZe, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(hst, xS); gst = [3, x, $Ze, 0, [_o, Ps, _ee, Ree, jk], [0, () => tat, () => pa, () => pa, 0]], xst = [3, x, UZe, 0, [_o, oet, get], [0, () => rat, () => da]], Est = [3, x, jZe, 0, [_o, jk, Eet, Cet, IS, ma, ua, Ns, Ps, iet, bee], [0, 0, 0, 0, 0, () => oh, () => rh, () => Ete, () => oat, 4, () => uN]], yst = [3, x, VZe, 0, [Yt, ma, ua], [0, () => oh, () => rh]], Sst = [3, x, zZe, 0, [Yt, Lk, uee, lee], [0, 0, () => pa, () => pa]], _st = [3, x, KZe, 0, [Yt, SZe], [0, () => da]], Cst = [3, x, YZe, 0, [Yt, ma, ua, Ns], [0, () => oh, () => rh, () => cte]], Rst = [3, x, eet, 0, [Yt, Lk, mee, uee, fee, lee], [0, 0, 1, () => pa, 1, () => pa]], Ast = [3, x, Eee, 0, [Yt, mee, yZe], [0, 1, () => da]], Tst = [-3, x, met, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Tst, ES); wst = [3, x, _et, 0, [_o, jk, GZe, Cee, _ee, xet, Ree, ZZe, bee], [0, 0, () => rte, 1, () => pa, 1, () => pa, () => nat, () => uN]], bst = [3, x, Tee, 0, [_o, Cee, het, Eee, Aet], [0, 1, () => da, () => sat, 0]], Ist = [-3, x, ket, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Ist, Yy); vst = [3, x, net, 0, [wS, kS, wu], [() => tot, () => Sit, () => dot]], Pst = [3, x, Oet, 0, [wS, wu], [() => eot, () => lot]], Ost = [-3, x, uet, { [Xe]: et }, [ft, Vee], [0, () => fN]]; k.for(x).registerError(Ost, qy); Dst = [-3, x, cet, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Dst, rS); kst = [-3, x, det, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(kst, Ky); Nst = [3, x, wee, 0, [Let, Mee, xee, aet], [0, 0, 4, 2]], Bst = [3, x, wet, 0, [Kee, zf, fZ, jZ, ZZ, ma, ua, Nee], [0, 0, 0, () => $S, () => mN, () => Bs, () => Rn, () => nh]], Lst = [3, x, bet, 0, [Ou], [() => Du]], Mst = [3, x, vet, 0, [Mee, Qet, Kee, trt, xee, fZ, jZ, ZZ, ma, ua, Nee], [0, 0, 0, 2, 4, 0, () => $S, () => mN, () => Bs, () => Rn, () => nh]], $st = [3, x, Pet, 0, [Ou], [() => Du]], pN = [3, x, PS, 0, [Kk, Wk, qet], [0, 0, 0]], Fst = [3, x, Het, 0, [De, Yt, RS, Iu, Uee, Uet, Kf, kZ, Jo, Ttt, Zet, Xf, UZ, _n, Si, Tu], [0, 0, 64, 1, 0, () => Ote, 0, () => Mo, 0, 1, 1, 0, 0, 128, () => Ai, 2]], Ust = [3, x, Vet, 0, [$k, bZ, vee, Fk, Lo], [() => FS, 1, 1, () => Mo, () => fa]], Hst = [3, x, $ee, 0, [De, th, Ri, zee, Cn, ttt, ss, ns, Qf, Wf], [0, 0, 0, 1, () => is, 4, () => Bs, () => Rn, 1, 0]], Gst = [3, x, Fee, 0, [Yf, Ps, Met, rN, Qk], [() => Qit, () => Mit, () => LS, () => yte, () => hte]], hte = [3, x, Qk, 0, [Jk, Bee, uJe, qXe], [0, 0, 0, 4]], nh = [3, x, DS, 0, [MZ, Bee, IS], [2, 0, 0]], LS = [3, x, OS, 0, [$et, Yet], [2, 0]], jst = [-3, x, ett, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(jst, hS); gte = [3, x, Zk, 0, [De, Wee, Iee], [0, 0, () => Zit]], uN = [3, x, jee, 0, [eN, eee], [0, 4]], xte = [3, x, tN, 0, [De, Vf, Cn, Wf, ss, ns, DS, Ps], [0, () => MS, () => is, 0, () => Bs, () => Rn, () => nh, () => $S]], Du = [3, x, Ou, 0, [Vf, De, Cn, Wee, _Z, ss, zee, Qf, Ri, th, hZ, Yf, Ps, OS, VJe, FJe, vXe, Iee, PXe, wee, Qk, cZ, jee, Ak, ns, Ns, ree], [() => MS, 0, () => is, 0, 4, () => fte, 1, 1, 0, 0, () => rte, () => Kit, () => Lit, () => LS, 0, 0, 0, () => Tte, () => Hit, () => Nst, () => hte, () => Art, () => uN, 2, () => Rn, () => Ete, 0]], qst = [-3, x, mtt, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(qst, Zy); Vst = [-3, x, gtt, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(Vst, eS); Ete = [3, x, Dtt, 0, [qk, aN, Jk], [1, 1, 0]], zst = [3, x, ktt, 0, [Os, iN], [0, 0]], Wst = [3, x, Ett, 0, [Pu, nN], [0, () => dN]], Kst = [-3, x, ntt, { [xrt]: ["Throttling", 400], [Xe]: et, [Jee]: 400 }, [ft, Crt], [0, () => fN]]; k.for(x).registerError(Kst, Vy); Qst = [3, x, Rtt, 0, [yrt, Srt], [0, 0]], yte = [3, x, rN, 0, [wtt, CS], [0, 0]], Ste = [3, x, oN, 0, [MZ, CS], [2, 0]], Yst = [3, x, stt, 0, [GZ], [() => nnt]], Xst = [3, x, itt, 0, [qee, Jo], [() => pat, 0]], Jst = [3, x, ctt, 0, [Lo, vS], [() => ku, () => Ate]], Zst = [-3, x, rtt, { [Xe]: et }, [vu, f7e], [0, () => Oit]]; k.for(x).registerError(Zst, _S); eit = [-3, x, ott, { [Xe]: et }, [ft], [0]]; k.for(x).registerError(eit, oS); tit = [-3, x, utt, { [Xe]: et }, [vu], [0]]; k.for(x).registerError(tit, uS); rit = [3, x, btt, 0, [SZ, gee, wu, kS], [() => Vrt, () => ist, () => sot, () => iit]], oit = [3, x, Itt, 0, [qee, Jo, Zf, AZ], [() => uat, 0, 0, [0, 4]]], nit = [3, x, Ptt, 0, [Lo, bu], [() => ku, () => Dte]], sit = [3, x, nrt, 0, [Pu, ltt], [0, 64]], iit = [3, x, kS, 0, [Os, Xee, De, Ac, _n, Si, ks], [() => Mo, 0, 0, 0, 128, () => Ai, 0]], ait = [3, x, Btt, 0, [De, aee], [0, () => rst]], cit = [3, x, Ltt, 0, [Ck], [() => ste]], pit = [3, x, $tt, 0, [De, Yt, n7e, AS], [0, 0, 0, 0]], uit = [3, x, Ftt, 0, [De, Yt, Rk, AS], [0, 0, 0, 0]], mit = [3, x, Utt, 0, [Yt, ss, ns, Ns], [0, () => Bs, () => Rn, () => sh]], lit = [3, x, Gtt, 0, [_i, Vk], [0, () => cat]], dit = [3, x, jtt, 0, [bS], [() => cN]], fit = [3, x, Vtt, 0, [_i, CXe, bXe, wXe, VZ, Tee], [0, 0, 1, () => da, () => Fit, () => iat]], hit = [3, x, ztt, 0, [_i, Aee], [0, () => Ite]], git = [3, x, Ktt, 0, [De, Os, mZ, Ok, Kf, zk, Jo, Zf, Xee, Ac, _n, Si, ks], [0, () => Mo, () => lat, () => hN, 0, 0, 0, 0, 0, 0, 128, () => Ai, 0]], xit = [3, x, Qtt, 0, [xk, Lo, bu], [() => Ls, () => fa, () => BS]], _te = [3, x, sN, 0, [hk], [0]], Eit = [3, x, Ztt, 0, [De, eh, sN], [0, 0, () => _te]], yit = [3, x, ert, 0, [De, eh, Tk, sN], [0, 0, 0, () => _te]], Sit = [3, x, ort, 0, [_o, IS, ma, ua, Ps, Gee], [0, 0, () => oh, () => rh, () => wte, 0]], _it = [3, x, irt, 0, [Vf, De, Wf, ss, qZ, OS, DS, Vk, eN, Ak, ree, BXe, ns, Ns], [() => MS, 0, 0, () => Bs, () => $it, () => LS, () => nh, () => aat, 0, 2, 0, () => Git, () => Rn, () => sh]], Cit = [3, x, art, 0, [Ou], [() => Du]], Rit = [3, x, prt, 0, [qZ, De, dee, Vk], [() => Bit, 0, () => da, () => eat]], Ait = [3, x, urt, 0, [Zk], [() => gte]], Tit = [3, x, lrt, 0, [De, oN], [0, () => Ste]], wit = [3, x, drt, 0, [oN], [() => Ste]], sh = [3, x, Ns, 0, [qk, aN], [1, 1]], bit = [3, x, frt, 0, [pee, IZ], [() => pst, () => fot]], Cte = "unit", Iit = [-3, Zee, "DynamoDBServiceException", 0, [], []]; k.for(Zee).registerError(Iit, Me); MS = [1, x, Vf, 0, () => Trt], Rte = [1, x, gk, 0, () => as], vit = [1, x, dQe, 0, () => brt], Pit = [1, x, EZ, 0, () => krt], Oit = [1, x, m7e, 0, () => jrt], ku = [1, x, JQe, 0, () => fa], Dit = [1, x, CZ, 0, () => Wrt], kit = [1, x, LZ, 0, () => zot], Nit = [1, x, NZ, 0, () => ent], Bit = [1, x, uXe, 0, () => unt], Lit = [1, x, lXe, 0, () => mnt], Mit = [1, x, Ps, 0, () => lnt], $S = [1, x, fXe, 0, () => pnt], $it = [1, x, gXe, 0, () => dnt], Fit = [1, x, RXe, 0, () => gnt], Uit = [1, x, AXe, 0, () => fnt], Hit = [1, x, DXe, 0, () => Ent], Git = [1, x, NXe, 0, () => ynt], jit = [1, x, QZ, 0, () => Rnt], qit = [1, x, HXe, 0, () => BS], FS = [1, x, KXe, 0, () => Ls], Ate = [1, x, ZXe, 0, () => Dnt], Vit = [1, x, pJe, 0, () => Mo], is = [1, x, Cn, 0, () => Nnt], zit = [1, x, JZ, 0, () => Bnt], Wit = [1, x, gJe, 0, () => as], Kit = [1, x, HJe, 0, () => Jnt], Qit = [1, x, Yf, 0, () => Znt], mN = [1, x, jJe, 0, () => Xnt], Yit = [1, x, IZe, 0, () => est], Xit = [1, x, xZe, 0, () => Frt], Jit = [1, x, EZe, 0, () => Urt], lN = [1, x, wZe, 0, () => as], Zit = [1, x, FZe, 0, () => gst], eat = [1, x, HZe, 0, () => xst], Tte = [1, x, qZe, 0, () => Est], tat = [1, x, WZe, 0, () => Sst], rat = [1, x, QZe, 0, () => _st], oat = [1, x, XZe, 0, () => Cst], wte = [1, x, JZe, 0, () => yst], nat = [1, x, tet, 0, () => Rst], sat = [1, x, ret, 0, () => Ast], bte = [1, x, pet, 0, () => fst], Ite = [1, x, yet, 0, () => wst], iat = [1, x, Ret, 0, () => bst], aat = [1, x, set, 0, () => vst], cat = [1, x, Det, 0, () => Pst], dN = [1, x, dtt, 0, () => zst], fN = [1, x, ytt, 0, () => Qst], pat = [1, x, att, 0, () => Yst], uat = [1, x, vtt, 0, () => rit], mat = [1, x, hrt, 0, () => bit], Ls = [2, x, cQe, 0, 0, () => as], lat = [2, x, mZ, 0, 0, () => wrt], vte = [2, x, OQe, 0, 0, () => knt], dat = [2, x, PQe, 0, 0, () => FS], Pte = [2, x, qQe, 0, 0, () => mat], hN = [2, x, bYe, 0, 0, () => Xot], Ai = [2, x, IYe, 0, 0, () => as], Ote = [2, x, rXe, 0, 0, () => nte], fat = [2, x, UXe, 0, 0, () => as], Dte = [2, x, GXe, 0, 0, () => qit], Mo = [2, x, Os, 0, 0, () => as], hat = [2, x, XZ, 0, 0, () => nte], gat = [2, x, eZe, 0, 0, () => as], gN = [2, x, mZe, 0, 0, () => as], aZ = [2, x, Get, 0, 0, () => ote], as = [4, x, SQe, 0, [Xet, oZe, VQe, Ket, iZe, FQe, rZe, ZJe, aZe, NQe], [0, 0, 21, 64, 64, 85, () => gat, () => Wit, 2, 2]], kte = [9, x, AQe, 0, () => Nrt, () => Brt], Nte = [9, x, bQe, 0, () => Lrt, () => Mrt], Bte = [9, x, HQe, 0, () => Hrt, () => Grt], Lte = [9, x, zQe, 0, () => Krt, () => Qrt], Mte = [9, x, e7e, 0, () => Xrt, () => Jrt], $te = [9, x, x7e, 0, () => rot, () => oot], Fte = [9, x, C7e, 0, () => iot, () => aot], Ute = [9, x, K7e, 0, () => uot, () => mot], Hte = [9, x, uYe, 0, () => hot, () => got], Gte = [9, x, fYe, 0, () => xot, () => Eot], jte = [9, x, b7e, 0, () => yot, () => Sot], qte = [9, x, I7e, 0, () => _ot, () => Cot], Vte = [9, x, O7e, 0, () => Rot, () => Aot], zte = [9, x, N7e, 0, () => Tot, () => wot], Wte = [9, x, F7e, 0, () => bot, () => Iot], Kte = [9, x, H7e, 0, () => vot, () => Pot], Qte = [9, x, q7e, 0, () => Oot, () => Dot], Yte = [9, x, eYe, 0, () => kot, () => Not], Xte = [9, x, tYe, 0, () => Bot, () => Lot], Jte = [9, x, sYe, 0, () => Mot, () => $ot], Zte = [9, x, TYe, 0, () => Fot, () => Uot], ere = [9, x, yYe, 0, () => Hot, () => Got], tre = [9, x, CYe, 0, () => jot, () => qot], rre = [9, x, nYe, 0, () => lte, () => dte], ore = [9, x, NYe, 0, () => lte, () => dte], nre = [9, x, VYe, 0, () => Wot, () => Kot], sre = [9, x, JYe, 0, () => Qot, () => Yot], ire = [9, x, QYe, 0, () => tnt, () => rnt], are = [9, x, oXe, 0, () => snt, () => int], cre = [9, x, iXe, 0, () => ant, () => cnt], pre = [9, x, oJe, 0, () => Ant, () => Tnt], ure = [9, x, xJe, 0, () => Mnt, () => $nt], mre = [9, x, SJe, 0, () => Fnt, () => Unt], lre = [9, x, AJe, 0, () => Hnt, () => Gnt], dre = [9, x, OJe, 0, () => jnt, () => qnt], fre = [9, x, NJe, 0, () => Vnt, () => znt], hre = [9, x, zJe, 0, () => Wnt, () => Knt], gre = [9, x, QJe, 0, () => Qnt, () => Ynt], xre = [9, x, cZe, 0, () => ast, () => cst], Ere = [9, x, _Ze, 0, () => ust, () => mst], yre = [9, x, kZe, 0, () => lst, () => dst], Sre = [9, x, Tet, 0, () => Bst, () => Lst], _re = [9, x, Iet, 0, () => Mst, () => $st], Cre = [9, x, Jet, 0, () => Fst, () => Ust], Rre = [9, x, Ctt, 0, () => Wst, () => Cte], Are = [9, x, ptt, 0, () => Xst, () => Jst], Tre = [9, x, Ott, 0, () => oit, () => nit], wre = [9, x, rrt, 0, () => sit, () => Cte], bre = [9, x, Ntt, 0, () => ait, () => cit], Ire = [9, x, Mtt, 0, () => pit, () => uit], vre = [9, x, Htt, 0, () => lit, () => dit], Pre = [9, x, qtt, 0, () => fit, () => hit], Ore = [9, x, Ytt, 0, () => git, () => xit], Dre = [9, x, Jtt, 0, () => Eit, () => yit], kre = [9, x, srt, 0, () => _it, () => Cit], Nre = [9, x, crt, 0, () => Rit, () => Ait], Bre = [9, x, mrt, 0, () => Tit, () => wit] }); var Nu, US = s(() => { me(); ae(); fe(); he(); Nu = class extends $.classBuilder().ep(q).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeEndpoints", {}).n("DynamoDBClient", "DescribeEndpointsCommand").sc(zte).build() { } }); var Mre, Lre = s(() => { Mre = { name: "@aws-sdk/client-dynamodb", description: "AWS SDK for JavaScript Dynamodb Client for Node.js, Browser and React Native", version: "3.962.0", scripts: { build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs", "build:cjs": "node ../../scripts/compilation/inline client-dynamodb", "build:es": "tsc -p tsconfig.es.json", "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"', "build:types": "tsc -p tsconfig.types.json", "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4", clean: "rimraf ./dist-* && rimraf *.tsbuildinfo", "extract:docs": "api-extractor run --local", "generate:client": "node ../../scripts/generate-clients/single-service --solo dynamodb", "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts", "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts", "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs" }, main: "./dist-cjs/index.js", types: "./dist-types/index.d.ts", module: "./dist-es/index.js", sideEffects: !1, dependencies: { "@aws-crypto/sha256-browser": "5.2.0", "@aws-crypto/sha256-js": "5.2.0", "@aws-sdk/core": "3.957.0", "@aws-sdk/credential-provider-node": "3.962.0", "@aws-sdk/dynamodb-codec": "3.957.0", "@aws-sdk/middleware-endpoint-discovery": "3.957.0", "@aws-sdk/middleware-host-header": "3.957.0", "@aws-sdk/middleware-logger": "3.957.0", "@aws-sdk/middleware-recursion-detection": "3.957.0", "@aws-sdk/middleware-user-agent": "3.957.0", "@aws-sdk/region-config-resolver": "3.957.0", "@aws-sdk/types": "3.957.0", "@aws-sdk/util-endpoints": "3.957.0", "@aws-sdk/util-user-agent-browser": "3.957.0", "@aws-sdk/util-user-agent-node": "3.957.0", "@smithy/config-resolver": "^4.4.5", "@smithy/core": "^3.20.0", "@smithy/fetch-http-handler": "^5.3.8", "@smithy/hash-node": "^4.2.7", "@smithy/invalid-dependency": "^4.2.7", "@smithy/middleware-content-length": "^4.2.7", "@smithy/middleware-endpoint": "^4.4.1", "@smithy/middleware-retry": "^4.4.17", "@smithy/middleware-serde": "^4.2.8", "@smithy/middleware-stack": "^4.2.7", "@smithy/node-config-provider": "^4.3.7", "@smithy/node-http-handler": "^4.4.7", "@smithy/protocol-http": "^5.3.7", "@smithy/smithy-client": "^4.10.2", "@smithy/types": "^4.11.0", "@smithy/url-parser": "^4.2.7", "@smithy/util-base64": "^4.3.0", "@smithy/util-body-length-browser": "^4.2.0", "@smithy/util-body-length-node": "^4.2.1", "@smithy/util-defaults-mode-browser": "^4.3.16", "@smithy/util-defaults-mode-node": "^4.2.19", "@smithy/util-endpoints": "^3.2.7", "@smithy/util-middleware": "^4.2.7", "@smithy/util-retry": "^4.2.7", "@smithy/util-utf8": "^4.2.0", "@smithy/util-waiter": "^4.2.7", tslib: "^2.6.2" }, devDependencies: { "@tsconfig/node18": "18.2.4", "@types/node": "^18.19.69", concurrently: "7.0.0", "downlevel-dts": "0.10.1", rimraf: "3.0.2", typescript: "~5.8.3" }, engines: { node: ">=18.0.0" }, typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } }, files: ["dist-*/**"], author: { name: "AWS SDK for JavaScript Team", url: "https://aws.amazon.com/javascript/" }, license: "Apache-2.0", browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" }, "react-native": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native" }, homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-dynamodb", repository: { type: "git", url: "https://github.com/aws/aws-sdk-js-v3.git", directory: "clients/client-dynamodb" } } }); var HS, GS, $re, Fre, Ure, Hre, xN, Gre = s(() => { He(); Z(); HS = "AWS_ACCESS_KEY_ID", GS = "AWS_SECRET_ACCESS_KEY", $re = "AWS_SESSION_TOKEN", Fre = "AWS_CREDENTIAL_EXPIRATION", Ure = "AWS_CREDENTIAL_SCOPE", Hre = "AWS_ACCOUNT_ID", xN = e => async () => { e?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv"); let t = process.env[HS], r = process.env[GS], o = process.env[$re], n = process.env[Fre], i = process.env[Ure], a = process.env[Hre]; if (t && r) { let c = { accessKeyId: t, secretAccessKey: r, ...o && { sessionToken: o }, ...n && { expiration: new Date(n) }, ...i && { credentialScope: i }, ...a && { accountId: a } }; return ee(c, "CREDENTIALS_ENV_VARS", "g"), c } throw new I("Unable to find environment variable credentials.", { logger: e?.logger }) } }); var jre = {}; Qe(jre, { ENV_ACCOUNT_ID: () => Hre, ENV_CREDENTIAL_SCOPE: () => Ure, ENV_EXPIRATION: () => Fre, ENV_KEY: () => HS, ENV_SECRET: () => GS, ENV_SESSION: () => $re, fromEnv: () => xN }); var EN = s(() => { Gre() }); import { Buffer as Eat } from "buffer"; import { request as yat } from "http"; function ha(e) { return new Promise((t, r) => { let o = yat({ method: "GET", ...e, hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1") }); o.on("error", n => { r(Object.assign(new kt("Unable to connect to instance metadata service"), n)), o.destroy() }), o.on("timeout", () => { r(new kt("TimeoutError from instance metadata service")), o.destroy() }), o.on("response", n => { let { statusCode: i = 400 } = n; (i < 200 || 300 <= i) && (r(Object.assign(new kt("Error response received from instance metadata service"), { statusCode: i })), o.destroy()); let a = []; n.on("data", c => { a.push(c) }), n.on("end", () => { t(Eat.concat(a)), o.destroy() }) }), o.end() }) } var jS = s(() => { Z() }); var qS, VS, yN = s(() => { qS = e => !!e && typeof e == "object" && typeof e.AccessKeyId == "string" && typeof e.SecretAccessKey == "string" && typeof e.Token == "string" && typeof e.Expiration == "string", VS = e => ({ accessKeyId: e.AccessKeyId, secretAccessKey: e.SecretAccessKey, sessionToken: e.Token, expiration: new Date(e.Expiration), ...e.AccountId && { accountId: e.AccountId } }) }); var rur, our, ih, zS = s(() => { rur = 1e3, our = 0, ih = ({ maxRetries: e = 0, timeout: t = 1e3 }) => ({ maxRetries: e, timeout: t }) }); var ah, SN = s(() => { ah = (e, t) => { let r = e(); for (let o = 0; o < t; o++)r = r.catch(e); return r } }); import { parse as Sat } from "url"; var WS, KS, _N, _at, Cat, Rat, Aat, Tat, wat, qre = s(() => { Z(); jS(); yN(); zS(); SN(); WS = "AWS_CONTAINER_CREDENTIALS_FULL_URI", KS = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", _N = "AWS_CONTAINER_AUTHORIZATION_TOKEN", _at = (e = {}) => { let { timeout: t, maxRetries: r } = ih(e); return () => ah(async () => { let o = await wat({ logger: e.logger }), n = JSON.parse(await Cat(t, o)); if (!qS(n)) throw new I("Invalid response received from instance metadata service.", { logger: e.logger }); return VS(n) }, r) }, Cat = async (e, t) => (process.env[_N] && (t.headers = { ...t.headers, Authorization: process.env[_N] }), (await ha({ ...t, timeout: e })).toString()), Rat = "169.254.170.2", Aat = { localhost: !0, "127.0.0.1": !0 }, Tat = { "http:": !0, "https:": !0 }, wat = async ({ logger: e }) => { if (process.env[KS]) return { hostname: Rat, path: process.env[KS] }; if (process.env[WS]) { let t = Sat(process.env[WS]); if (!t.hostname || !(t.hostname in Aat)) throw new I(`${t.hostname} is not a valid container metadata service hostname`, { tryNextLink: !1, logger: e }); if (!t.protocol || !(t.protocol in Tat)) throw new I(`${t.protocol} is not a valid container metadata service protocol`, { tryNextLink: !1, logger: e }); return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 } } throw new I(`The container metadata credential provider cannot be used unless the ${KS} or ${WS} environment variable is set`, { tryNextLink: !1, logger: e }) } }); var QS, Vre = s(() => { Z(); QS = class e extends I { tryNextLink; name = "InstanceMetadataV1FallbackError"; constructor(t, r = !0) { super(t, r), this.tryNextLink = r, Object.setPrototypeOf(this, e.prototype) } } }); var wc, CN = s(() => { (function (e) { e.IPv4 = "http://169.254.169.254", e.IPv6 = "http://[fd00:ec2::254]" })(wc || (wc = {})) }); var bat, Iat, zre, Wre = s(() => { bat = "AWS_EC2_METADATA_SERVICE_ENDPOINT", Iat = "ec2_metadata_service_endpoint", zre = { environmentVariableSelector: e => e[bat], configFileSelector: e => e[Iat], default: void 0 } }); var ga, RN = s(() => { (function (e) { e.IPv4 = "IPv4", e.IPv6 = "IPv6" })(ga || (ga = {})) }); var vat, Pat, Kre, Qre = s(() => { RN(); vat = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE", Pat = "ec2_metadata_service_endpoint_mode", Kre = { environmentVariableSelector: e => e[vat], configFileSelector: e => e[Pat], default: ga.IPv4 } }); var YS, Oat, Dat, AN = s(() => { Cc(); Rf(); CN(); Wre(); RN(); Qre(); YS = async () => bs(await Oat() || await Dat()), Oat = async () => It(zre)(), Dat = async () => { let e = await It(Kre)(); switch (e) { case ga.IPv4: return wc.IPv4; case ga.IPv6: return wc.IPv6; default: throw new Error(`Unsupported endpoint mode: ${e}. Select from ${Object.values(ga)}`) } } }); var kat, TN, Yre = s(() => {
  kat = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html", TN = (e, t) => {
    let r = 300 + Math.floor(Math.random() * 300), o = new Date(Date.now() + r * 1e3); t.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: `+ kat); let n = e.originalExpiration ?? e.expiration; return { ...e, ...n ? { originalExpiration: n } : {}, expiration: o }
  }
}); var Xre, Jre = s(() => { Yre(); Xre = (e, t = {}) => { let r = t?.logger || console, o; return async () => { let n; try { n = await e(), n.expiration && n.expiration.getTime() < Date.now() && (n = TN(n, r)) } catch (i) { if (o) r.warn("Credential renew failed: ", i), n = TN(o, r); else throw i } return o = n, n } } }); var toe, Nat, wN, Zre, eoe, Bat, Lat, Mat, $at, Fat, roe = s(() => { Cc(); Z(); Vre(); jS(); yN(); zS(); SN(); AN(); Jre(); toe = "/latest/meta-data/iam/security-credentials/", Nat = "/latest/api/token", wN = "AWS_EC2_METADATA_V1_DISABLED", Zre = "ec2_metadata_v1_disabled", eoe = "x-aws-ec2-metadata-token", Bat = (e = {}) => Xre(Lat(e), { logger: e.logger }), Lat = (e = {}) => { let t = !1, { logger: r, profile: o } = e, { timeout: n, maxRetries: i } = ih(e), a = async (c, p) => { if (t || p.headers?.[eoe] == null) { let m = !1, f = !1, h = await It({ environmentVariableSelector: E => { let S = E[wN]; if (f = !!S && S !== "false", S === void 0) throw new I(`${wN} not set in env, checking config file next.`, { logger: e.logger }); return f }, configFileSelector: E => { let S = E[Zre]; return m = !!S && S !== "false", m }, default: !1 }, { profile: o })(); if (e.ec2MetadataV1Disabled || h) { let E = []; throw e.ec2MetadataV1Disabled && E.push("credential provider initialization (runtime option ec2MetadataV1Disabled)"), m && E.push(`config file profile (${Zre})`), f && E.push(`process environment variable (${wN})`), new QS(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${E.join(", ")}].`) } } let l = (await ah(async () => { let m; try { m = await $at(p) } catch (f) { throw f.statusCode === 401 && (t = !1), f } return m }, c)).trim(); return ah(async () => { let m; try { m = await Fat(l, p, e) } catch (f) { throw f.statusCode === 401 && (t = !1), f } return m }, c) }; return async () => { let c = await YS(); if (t) return r?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)"), a(i, { ...c, timeout: n }); { let p; try { p = (await Mat({ ...c, timeout: n })).toString() } catch (u) { if (u?.statusCode === 400) throw Object.assign(u, { message: "EC2 Metadata token request returned error" }); return (u.message === "TimeoutError" || [403, 404, 405].includes(u.statusCode)) && (t = !0), r?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)"), a(i, { ...c, timeout: n }) } return a(i, { ...c, headers: { [eoe]: p }, timeout: n }) } } }, Mat = async e => ha({ ...e, path: Nat, method: "PUT", headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" } }), $at = async e => (await ha({ ...e, path: toe })).toString(), Fat = async (e, t, r) => { let o = JSON.parse((await ha({ ...t, path: toe + e })).toString()); if (!qS(o)) throw new I("Invalid response received from instance metadata service.", { logger: r.logger }); return VS(o) } }); var ooe = s(() => { }); var ch = {}; Qe(ch, { DEFAULT_MAX_RETRIES: () => our, DEFAULT_TIMEOUT: () => rur, ENV_CMDS_AUTH_TOKEN: () => _N, ENV_CMDS_FULL_URI: () => WS, ENV_CMDS_RELATIVE_URI: () => KS, Endpoint: () => wc, fromContainerMetadata: () => _at, fromInstanceMetadata: () => Bat, getInstanceMetadataEndpoint: () => YS, httpRequest: () => ha, providerConfigFromInit: () => ih }); var ph = s(() => { qre(); roe(); zS(); ooe(); jS(); AN(); CN() }); var noe = s(() => { }); var soe = s(() => { noe() }); var ioe = s(() => { }); var aoe = s(() => { }); var coe = s(() => { }); function Uat(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var XS, poe = s(() => { XS = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = Uat(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var JS, uoe = s(() => { JS = class { statusCode; reason; headers; body; constructor(t) { this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body } static isInstance(t) { if (!t) return !1; let r = t; return typeof r.statusCode == "number" && typeof r.headers == "object" } } }); var moe = s(() => { }); var loe = s(() => { }); var bN = s(() => { soe(); ioe(); aoe(); coe(); poe(); uoe(); moe(); loe() }); var ZS, Hat, doe = s(() => { ZS = e => encodeURIComponent(e).replace(/[!'()*]/g, Hat), Hat = e => `%${e.charCodeAt(0).toString(16).toUpperCase()}` }); var foe = s(() => { }); var hoe = s(() => { doe(); foe() }); function goe(e) { let t = []; for (let r of Object.keys(e).sort()) { let o = e[r]; if (r = ZS(r), Array.isArray(o)) for (let n = 0, i = o.length; n < i; n++)t.push(`${r}=${ZS(o[n])}`); else { let n = r; (o || typeof o == "string") && (n += `=${ZS(o)}`), t.push(n) } } return t.join("&") } var xoe = s(() => { hoe() }); var Eoe, yoe = s(() => { Eoe = ["ECONNRESET", "EPIPE", "ETIMEDOUT"] }); var Soe, _oe = s(() => { Soe = e => { let t = {}; for (let r of Object.keys(e)) { let o = e[r]; t[r] = Array.isArray(o) ? o.join(",") : o } return t } }); var ur, bc = s(() => { ur = { setTimeout: (e, t) => setTimeout(e, t), clearTimeout: e => clearTimeout(e) } }); var Coe, Roe, Aoe = s(() => { bc(); Coe = 1e3, Roe = (e, t, r = 0) => { if (!r) return -1; let o = n => { let i = ur.setTimeout(() => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${r} ms.`), { name: "TimeoutError" })) }, r - n), a = c => { c?.connecting ? c.on("connect", () => { ur.clearTimeout(i) }) : ur.clearTimeout(i) }; e.socket ? a(e.socket) : e.on("socket", a) }; return r < 2e3 ? (o(0), 0) : ur.setTimeout(o.bind(null, Coe), Coe) } }); var Toe, woe = s(() => { bc(); Toe = (e, t, r = 0, o, n) => r ? ur.setTimeout(() => { let i = `@smithy/node-http-handler - [${o ? "ERROR" : "WARN"}] a request has exceeded the configured ${r} ms requestTimeout.`; if (o) { let a = Object.assign(new Error(i), { name: "TimeoutError", code: "ETIMEDOUT" }); e.destroy(a), t(a) } else i += " Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.", n?.warn?.(i) }, r) : -1 }); var Gat, boe, Ioe = s(() => { bc(); Gat = 3e3, boe = (e, { keepAlive: t, keepAliveMsecs: r }, o = Gat) => { if (t !== !0) return -1; let n = () => { e.socket ? e.socket.setKeepAlive(t, r || 0) : e.on("socket", i => { i.setKeepAlive(t, r || 0) }) }; return o === 0 ? (n(), 0) : ur.setTimeout(n, o) } }); var voe, Poe, Ooe = s(() => { bc(); voe = 3e3, Poe = (e, t, r = 0) => { let o = n => { let i = r - n, a = () => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${r} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" })) }; e.socket ? (e.socket.setTimeout(i, a), e.on("close", () => e.socket?.removeListener("timeout", a))) : e.setTimeout(i, a) }; return 0 < r && r < 6e3 ? (o(0), 0) : ur.setTimeout(o.bind(null, r === 0 ? 0 : voe), voe) } }); import { Readable as jat } from "stream"; async function koe(e, t, r = Doe, o = !1) { let n = t.headers ?? {}, i = n.Expect || n.expect, a = -1, c = !0; !o && i === "100-continue" && (c = await Promise.race([new Promise(p => { a = Number(ur.setTimeout(() => p(!0), Math.max(Doe, r))) }), new Promise(p => { e.on("continue", () => { ur.clearTimeout(a), p(!0) }), e.on("response", () => { ur.clearTimeout(a), p(!1) }), e.on("error", () => { ur.clearTimeout(a), p(!1) }) })])), c && qat(e, t.body) } function qat(e, t) { if (t instanceof jat) { t.pipe(e); return } if (t) { if (Buffer.isBuffer(t) || typeof t == "string") { e.end(t); return } let r = t; if (typeof r == "object" && r.buffer && typeof r.byteOffset == "number" && typeof r.byteLength == "number") { e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength)); return } e.end(Buffer.from(t)); return } e.end() } var Doe, Noe = s(() => { bc(); Doe = 6e3 }); import { Agent as IN, request as Vat } from "http"; import { Agent as vN, request as zat } from "https"; var e_, Boe = s(() => {
  bN(); xoe(); yoe(); _oe(); Aoe(); woe(); Ioe(); Ooe(); bc(); Noe(); e_ = class e {
    config; configProvider; socketWarningTimestamp = 0; externalAgent = !1; metadata = { handlerProtocol: "http/1.1" }; static create(t) { return typeof t?.handle == "function" ? t : new e(t) } static checkSocketUsage(t, r, o = console) {
      let { sockets: n, requests: i, maxSockets: a } = t; if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r) return r; if (n && i) for (let p in n) {
        let u = n[p]?.length ?? 0, l = i[p]?.length ?? 0; if (u >= a && l >= 2 * a) return o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${u} and ${l} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`), Date.now()
      } return r
    } constructor(t) { this.configProvider = new Promise((r, o) => { typeof t == "function" ? t().then(n => { r(this.resolveDefaultConfig(n)) }).catch(o) : r(this.resolveDefaultConfig(t)) }) } resolveDefaultConfig(t) { let { requestTimeout: r, connectionTimeout: o, socketTimeout: n, socketAcquisitionWarningTimeout: i, httpAgent: a, httpsAgent: c, throwOnRequestTimeout: p } = t || {}, u = !0, l = 50; return { connectionTimeout: o, requestTimeout: r, socketTimeout: n, socketAcquisitionWarningTimeout: i, throwOnRequestTimeout: p, httpAgent: a instanceof IN || typeof a?.destroy == "function" ? (this.externalAgent = !0, a) : new IN({ keepAlive: u, maxSockets: l, ...a }), httpsAgent: c instanceof vN || typeof c?.destroy == "function" ? (this.externalAgent = !0, c) : new vN({ keepAlive: u, maxSockets: l, ...c }), logger: console } } destroy() { this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy() } async handle(t, { abortSignal: r, requestTimeout: o } = {}) { return this.config || (this.config = await this.configProvider), new Promise((n, i) => { let a = this.config, c, p = [], u = async O => { await c, p.forEach(ur.clearTimeout), n(O) }, l = async O => { await c, p.forEach(ur.clearTimeout), i(O) }; if (r?.aborted) { let O = new Error("Request aborted"); O.name = "AbortError", l(O); return } let m = t.protocol === "https:", f = t.headers ?? {}, h = (f.Expect ?? f.expect) === "100-continue", E = m ? a.httpsAgent : a.httpAgent; h && !this.externalAgent && (E = new (m ? vN : IN)({ keepAlive: !1, maxSockets: 1 / 0 })), p.push(ur.setTimeout(() => { this.socketWarningTimestamp = e.checkSocketUsage(E, this.socketWarningTimestamp, a.logger) }, a.socketAcquisitionWarningTimeout ?? (a.requestTimeout ?? 2e3) + (a.connectionTimeout ?? 1e3))); let S = goe(t.query || {}), y; if (t.username != null || t.password != null) { let O = t.username ?? "", ie = t.password ?? ""; y = `${O}:${ie}` } let C = t.path; S && (C += `?${S}`), t.fragment && (C += `#${t.fragment}`); let b = t.hostname ?? ""; b[0] === "[" && b.endsWith("]") ? b = t.hostname.slice(1, -1) : b = t.hostname; let L = { headers: t.headers, host: b, method: t.method, path: C, port: t.port, agent: E, auth: y }, j = (m ? zat : Vat)(L, O => { let ie = new JS({ statusCode: O.statusCode || -1, reason: O.statusMessage, headers: Soe(O.headers), body: O }); u({ response: ie }) }); if (j.on("error", O => { Eoe.includes(O.code) ? l(Object.assign(O, { name: "TimeoutError" })) : l(O) }), r) { let O = () => { j.destroy(); let ie = new Error("Request aborted"); ie.name = "AbortError", l(ie) }; if (typeof r.addEventListener == "function") { let ie = r; ie.addEventListener("abort", O, { once: !0 }), j.once("close", () => ie.removeEventListener("abort", O)) } else r.onabort = O } let re = o ?? a.requestTimeout; p.push(Roe(j, l, a.connectionTimeout)), p.push(Toe(j, l, re, a.throwOnRequestTimeout, a.logger ?? console)), p.push(Poe(j, l, a.socketTimeout)); let Ce = L.agent; typeof Ce == "object" && "keepAlive" in Ce && p.push(boe(j, { keepAlive: Ce.keepAlive, keepAliveMsecs: Ce.keepAliveMsecs })), c = koe(j, t, re, this.externalAgent).catch(O => (p.forEach(ur.clearTimeout), i(O))) }) } updateHttpClientConfig(t, r) { this.config = void 0, this.configProvider = this.configProvider.then(o => ({ ...o, [t]: r })) } httpHandlerConfigs() { return this.config ?? {} }
  }
}); var Loe = s(() => { }); import { Writable as Wat } from "stream"; var t_, Moe = s(() => { t_ = class extends Wat { bufferedBytes = []; _write(t, r, o) { this.bufferedBytes.push(t), o() } } }); async function Qat(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } var $oe, Kat, Foe = s(() => { Moe(); $oe = e => Kat(e) ? Qat(e) : new Promise((t, r) => { let o = new t_; e.pipe(o), e.on("error", n => { o.end(), r(n) }), o.on("error", r), o.on("finish", function () { let n = new Uint8Array(Buffer.concat(this.bufferedBytes)); t(n) }) }), Kat = e => typeof ReadableStream == "function" && e instanceof ReadableStream }); var PN = s(() => { Boe(); Loe(); Foe() }); var Yat, Xat, Jat, Uoe, Hoe = s(() => {
  Z(); Yat = "169.254.170.2", Xat = "169.254.170.23", Jat = "[fd00:ec2::23]", Uoe = (e, t) => {
    if (e.protocol !== "https:" && !(e.hostname === Yat || e.hostname === Xat || e.hostname === Jat)) {
      if (e.hostname.includes("[")) { if (e.hostname === "[::1]" || e.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") return } else { if (e.hostname === "localhost") return; let r = e.hostname.split("."), o = n => { let i = parseInt(n, 10); return 0 <= i && i <= 255 }; if (r[0] === "127" && o(r[1]) && o(r[2]) && o(r[3]) && r.length === 4) return } throw new I(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger: t })
    }
  }
}); var Goe = s(() => { }); var joe = s(() => { }); var qoe = s(() => { }); var Voe = s(() => { }); var zoe = s(() => { }); var Woe = s(() => { }); var Koe = s(() => { }); var Qoe = s(() => { }); var Yoe = s(() => { }); var Xoe = s(() => { }); var Joe = s(() => { }); var Zoe = s(() => { Joe() }); var ene = s(() => { }); var tne = s(() => { }); var rne = s(() => { }); var one = s(() => { }); var nne = s(() => { }); var sne = s(() => { }); var ine = s(() => { }); var ane = s(() => { }); var cne = s(() => { Goe(); joe(); qoe(); Voe(); zoe(); Koe(); Qoe(); Yoe(); Woe(); Xoe(); Zoe(); ene(); tne(); rne(); one(); nne(); sne(); ine(); ane(); Pr() }); import { Buffer as ON } from "buffer"; var Bu, r_, Lu = s(() => { cr(); Bu = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return ON.from(e, t, r) }, r_ = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? ON.from(e, t) : ON.from(e) } }); var Zat, pne, une = s(() => { Lu(); Zat = /^[A-Za-z0-9+/]*={0,2}$/, pne = e => { if (e.length * 3 % 4 !== 0) throw new TypeError("Incorrect padding on base64 string."); if (!Zat.exec(e)) throw new TypeError("Invalid base64 string."); let t = r_(e, "base64"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength) } }); var mne, lne = s(() => { Lu(); mne = e => { let t = r_(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var dne = s(() => { }); var fne, hne = s(() => { Lu(); fne = e => { if (typeof e == "string") return e; if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number") throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."); return Bu(e.buffer, e.byteOffset, e.byteLength).toString("utf8") } }); var DN = s(() => { lne(); dne(); hne() }); var gne, xne = s(() => { Lu(); DN(); gne = e => { let t; if (typeof e == "string" ? t = mne(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return Bu(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var kN = s(() => { une(); xne() }); var Ene = s(() => { }); var yne = s(() => { }); var NN, BN = s(() => { NN = e => typeof ReadableStream == "function" && (e?.constructor?.name === ReadableStream.name || e instanceof ReadableStream) }); var Sne = s(() => { }); var _ne = s(() => { }); var Cne = s(() => { }); var Rne = s(() => { }); var Ane = s(() => { }); async function ect(e) { let t = await rct(e), r = pne(t); return new Uint8Array(r) } async function tct(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } function rct(e) { return new Promise((t, r) => { let o = new FileReader; o.onloadend = () => { if (o.readyState !== 2) return r(new Error("Reader aborted too early")); let n = o.result ?? "", i = n.indexOf(","), a = i > -1 ? i + 1 : n.length; t(n.substring(a)) }, o.onabort = () => r(new Error("Read aborted")), o.onerror = () => r(o.error), o.readAsDataURL(e) }) } var Tne, wne = s(() => { kN(); Tne = async e => typeof Blob == "function" && e instanceof Blob || e.constructor?.name === "Blob" ? Blob.prototype.arrayBuffer !== void 0 ? new Uint8Array(await e.arrayBuffer()) : ect(e) : tct(e) }); var bne = s(() => { Ane(); wne() }); var Ine, Pne, vne, One = s(() => {
  bne(); kN(); Oo(); DN(); BN(); Ine = "The stream has already been transformed.", Pne = e => {
    if (!vne(e) && !NN(e)) { let n = e?.__proto__?.constructor?.name || e; throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${n}`) } let t = !1, r = async () => { if (t) throw new Error(Ine); return t = !0, await Tne(e) }, o = n => {
      if (typeof n.stream != "function") throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`); return n.stream()
    }; return Object.assign(e, { transformToByteArray: r, transformToString: async n => { let i = await r(); if (n === "base64") return gne(i); if (n === "hex") return it(i); if (n === void 0 || n === "utf8" || n === "utf-8") return fne(i); if (typeof TextDecoder == "function") return new TextDecoder(n).decode(i); throw new Error("TextDecoder is not available, please make sure polyfill is provided.") }, transformToWebStream: () => { if (t) throw new Error(Ine); if (t = !0, vne(e)) return o(e); if (NN(e)) return e; throw new Error(`Cannot transform payload to web stream, got ${e}`) } })
  }, vne = e => typeof Blob == "function" && e instanceof Blob
}); import { Readable as LN } from "stream"; var Dne, kne, Nne = s(() => { PN(); Lu(); One(); Dne = "The stream has already been transformed.", kne = e => { if (!(e instanceof LN)) try { return Pne(e) } catch { let n = e?.__proto__?.constructor?.name || e; throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${n}`) } let t = !1, r = async () => { if (t) throw new Error(Dne); return t = !0, await $oe(e) }; return Object.assign(e, { transformToByteArray: r, transformToString: async o => { let n = await r(); return o === void 0 || Buffer.isEncoding(o) ? Bu(n.buffer, n.byteOffset, n.byteLength).toString(o) : new TextDecoder(o).decode(n) }, transformToWebStream: () => { if (t) throw new Error(Dne); if (e.readableFlowing !== null) throw new Error("The stream has been consumed by other callbacks."); if (typeof LN.toWeb != "function") throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available."); return t = !0, LN.toWeb(e) } }) } }); var Bne = s(() => { }); var Lne = s(() => { Ene(); yne(); Sne(); _ne(); Cne(); Rne(); Nne(); Bne(); BN() }); function Mne(e) { return new XS({ protocol: e.protocol, hostname: e.hostname, port: Number(e.port), path: e.pathname, query: Array.from(e.searchParams.entries()).reduce((t, [r, o]) => (t[r] = o, t), {}), fragment: e.hash }) } async function $ne(e, t) { let o = await kne(e.body).transformToString(); if (e.statusCode === 200) { let n = JSON.parse(o); if (typeof n.AccessKeyId != "string" || typeof n.SecretAccessKey != "string" || typeof n.Token != "string" || typeof n.Expiration != "string") throw new I("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger: t }); return { accessKeyId: n.AccessKeyId, secretAccessKey: n.SecretAccessKey, sessionToken: n.Token, expiration: _8(n.Expiration) } } if (e.statusCode >= 400 && e.statusCode < 500) { let n = {}; try { n = JSON.parse(o) } catch { } throw Object.assign(new I(`Server responded with status: ${e.statusCode}`, { logger: t }), { Code: n.Code, Message: n.Message }) } throw new I(`Server responded with status: ${e.statusCode}`, { logger: t }) } var Fne = s(() => { Z(); bN(); cne(); Lne() }); var Une, Hne = s(() => { Une = (e, t, r) => async () => { for (let o = 0; o < t; ++o)try { return await e() } catch { await new Promise(i => setTimeout(i, r)) } return await e() } }); import oct from "fs/promises"; var nct, sct, ict, act, cct, Gne, jne = s(() => {
  He(); PN(); Z(); Hoe(); Fne(); Hne(); nct = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", sct = "http://169.254.170.2", ict = "AWS_CONTAINER_CREDENTIALS_FULL_URI", act = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE", cct = "AWS_CONTAINER_AUTHORIZATION_TOKEN", Gne = (e = {}) => {
    e.logger?.debug("@aws-sdk/credential-provider-http - fromHttp"); let t, r = e.awsContainerCredentialsRelativeUri ?? process.env[nct], o = e.awsContainerCredentialsFullUri ?? process.env[ict], n = e.awsContainerAuthorizationToken ?? process.env[cct], i = e.awsContainerAuthorizationTokenFile ?? process.env[act], a = e.logger?.constructor?.name === "NoOpLogger" || !e.logger?.warn ? console.warn : e.logger.warn.bind(e.logger); if (r && o && (a("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."), a("awsContainerCredentialsFullUri will take precedence.")), n && i && (a("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."), a("awsContainerAuthorizationToken will take precedence.")), o) t = o; else if (r) t = `${sct}${r}`; else throw new I(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: e.logger }); let c = new URL(t); Uoe(c, e.logger); let p = e_.create({ requestTimeout: e.timeout ?? 1e3, connectionTimeout: e.timeout ?? 1e3 }); return Une(async () => { let u = Mne(c); n ? u.headers.Authorization = n : i && (u.headers.Authorization = (await oct.readFile(i)).toString()); try { let l = await p.handle(u); return $ne(l.response).then(m => ee(m, "CREDENTIALS_HTTP", "z")) } catch (l) { throw new I(String(l), { logger: e.logger }) } }, e.maxRetries ?? 3, e.timeout ?? 1e3)
  }
}); var Ic = {}; Qe(Ic, { fromHttp: () => Gne }); var vc = s(() => { jne() }); var qne, Vne, zne = s(() => { Z(); qne = "AWS_EC2_METADATA_DISABLED", Vne = async e => { let { ENV_CMDS_FULL_URI: t, ENV_CMDS_RELATIVE_URI: r, fromContainerMetadata: o, fromInstanceMetadata: n } = await Promise.resolve().then(() => (ph(), ch)); if (process.env[r] || process.env[t]) { e.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata"); let { fromHttp: i } = await Promise.resolve().then(() => (vc(), Ic)); return sr(i(e), o(e)) } return process.env[qne] && process.env[qne] !== "false" ? async () => { throw new I("EC2 Instance Metadata Service access disabled", { logger: e.logger }) } : (e.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"), n(e)) } }); function Wne(e, t) { let r = pct(e), o, n, i, a = async c => { if (c?.forceRefresh) return await r(c); if (i?.expiration && i?.expiration?.getTime() < Date.now() && (i = void 0), o) await o; else if (!i || t?.(i)) if (i) n || (n = r(c).then(p => { i = p, n = void 0 })); else return o = r(c).then(p => { i = p, o = void 0 }), a(c); return i }; return a } var pct, Kne = s(() => { pct = e => async t => { let r; for (let o of e) try { return await o(t) } catch (n) { if (r = n, n?.tryNextLink) continue; throw n } throw r } }); var MN, $N = s(() => { MN = e => e && (typeof e.sso_start_url == "string" || typeof e.sso_account_id == "string" || typeof e.sso_session == "string" || typeof e.sso_region == "string" || typeof e.sso_role_name == "string") }); var Qne = s(() => { }); var Mu, o_ = s(() => { Mu = "To refresh this SSO session run 'aws sso login' with the corresponding profile." }); var $u, Fu, Yne = s(() => { $u = e => ({ setHttpHandler(t) { e.httpHandler = t }, httpHandler() { return e.httpHandler }, updateHttpClientConfig(t, r) { e.httpHandler?.updateHttpClientConfig(t, r) }, httpHandlerConfigs() { return e.httpHandler.httpHandlerConfigs() } }), Fu = e => ({ httpHandler: e.httpHandler() }) }); var Xne = s(() => { Yne() }); var Jne = s(() => { }); var Zne, ese = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Zne || (Zne = {})) }); var tse, rse = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(tse || (tse = {})) }); var ose = s(() => { }); var nse = s(() => { }); var sse = s(() => { }); var ise = s(() => { }); var ase = s(() => { ese(); rse(); ose(); nse(); sse(); ise() }); var cse = s(() => { }); var pse = s(() => { }); var use = s(() => { }); var mse = s(() => { }); var lse = s(() => { }); var dse = s(() => { }); var fse = s(() => { }); var hse = s(() => { lse(); dse(); fse() }); var gse = s(() => { }); var xse = s(() => { }); var Ese, yse = s(() => { (function (e) { e.HTTP = "http", e.HTTPS = "https" })(Ese || (Ese = {})) }); var Sse = s(() => { }); var _se = s(() => { }); var Cse = s(() => { }); var Rse = s(() => { }); var Ase = s(() => { }); var Tse = s(() => { Sse(); _se(); Cse(); Rse(); Ase() }); var wse = s(() => { }); var Uu, bse = s(() => { (function (e) { e.MD5 = "md5", e.CRC32 = "crc32", e.CRC32C = "crc32c", e.SHA1 = "sha1", e.SHA256 = "sha256" })(Uu || (Uu = {})) }); var Ise = s(() => { }); var vse = s(() => { }); var Pse = s(() => { Ise(); vse(); bse() }); var Ose = s(() => { }); var Dse, kse = s(() => { (function (e) { e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER" })(Dse || (Dse = {})) }); var Nse = s(() => { }); var Bse = s(() => { }); var Lse = s(() => { }); var Mse = s(() => { }); var $se = s(() => { }); var Fse = s(() => { Bse(); Lse(); Mse(); $se() }); var Use = s(() => { }); var Hse, Gse = s(() => { Hse = "__smithy_context" }); var jse = s(() => { }); var Pc, qse = s(() => { (function (e) { e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services" })(Pc || (Pc = {})) }); var Vse = s(() => { }); var zse = s(() => { }); var Wse = s(() => { }); var Kse = s(() => { }); var Qse = s(() => { }); var Yse = s(() => { }); var Xse = s(() => { }); var Jse = s(() => { }); var Zse = s(() => { }); var eie = s(() => { }); var tie = s(() => { }); var rie = s(() => { }); var oie = s(() => { }); var nie = s(() => { }); var sie, iie = s(() => { (function (e) { e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0" })(sie || (sie = {})) }); var aie = s(() => { }); var cie = s(() => { }); var pie = s(() => { }); var uie = s(() => { }); var mie = s(() => { }); var lie = s(() => { }); var die = s(() => { }); var uh = s(() => { Jne(); ase(); cse(); pse(); use(); mse(); hse(); gse(); xse(); yse(); Tse(); wse(); Pse(); Ose(); kse(); Nse(); Fse(); Use(); Gse(); jse(); qse(); Vse(); zse(); Wse(); Kse(); Qse(); Yse(); Xse(); Jse(); Zse(); eie(); tie(); rie(); oie(); nie(); iie(); aie(); cie(); pie(); uie(); mie(); lie(); die() }); var fie = s(() => { }); var hie = s(() => { }); var gie = s(() => { }); function uct(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var An, xie = s(() => { An = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = uct(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var Hu, Eie = s(() => { Hu = class { statusCode; reason; headers; body; constructor(t) { this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body } static isInstance(t) { if (!t) return !1; let r = t; return typeof r.statusCode == "number" && typeof r.headers == "object" } } }); var yie = s(() => { }); var Sie = s(() => { }); var Ms = s(() => { Xne(); fie(); hie(); gie(); xie(); Eie(); yie(); Sie() }); var mct, lct, Gu, n_ = s(() => { Ms(); mct = e => t => async r => { if (!An.isInstance(r.request)) return t(r); let { request: o } = r, { handlerProtocol: n = "" } = e.requestHandler.metadata || {}; if (n.indexOf("h2") >= 0 && !o.headers[":authority"]) delete o.headers.host, o.headers[":authority"] = o.hostname + (o.port ? ":" + o.port : ""); else if (!o.headers.host) { let i = o.hostname; o.port != null && (i += `:${o.port}`), o.headers.host = i } return t(r) }, lct = { name: "hostHeaderMiddleware", step: "build", priority: "low", tags: ["HOST"], override: !0 }, Gu = e => ({ applyToStack: t => { t.add(mct(e), lct) } }) }); var dct, fct, ju, _ie = s(() => { dct = () => (e, t) => async r => { try { let o = await e(r), { clientName: n, commandName: i, logger: a, dynamoDbDocumentClientOptions: c = {} } = t, { overrideInputFilterSensitiveLog: p, overrideOutputFilterSensitiveLog: u } = c, l = p ?? t.inputFilterSensitiveLog, m = u ?? t.outputFilterSensitiveLog, { $metadata: f, ...h } = o.output; return a?.info?.({ clientName: n, commandName: i, input: l(r.input), output: m(h), metadata: f }), o } catch (o) { let { clientName: n, commandName: i, logger: a, dynamoDbDocumentClientOptions: c = {} } = t, { overrideInputFilterSensitiveLog: p } = c, u = p ?? t.inputFilterSensitiveLog; throw a?.error?.({ clientName: n, commandName: i, input: u(r.input), error: o, metadata: o.$metadata }), o } }, fct = { name: "loggerMiddleware", tags: ["LOGGER"], step: "initialize", override: !0 }, ju = e => ({ applyToStack: t => { t.add(dct(), fct) } }) }); var s_ = s(() => { _ie() }); var Cie, Rie = s(() => { Cie = { step: "build", tags: ["RECURSION_DETECTION"], name: "recursionDetectionMiddleware", override: !0, priority: "low" } }); var FN, hct, gct, Aie, UN = s(() => { xf(); Ms(); FN = "X-Amzn-Trace-Id", hct = "AWS_LAMBDA_FUNCTION_NAME", gct = "_X_AMZN_TRACE_ID", Aie = () => e => async t => { let { request: r } = t; if (!An.isInstance(r)) return e(t); let o = Object.keys(r.headers ?? {}).find(l => l.toLowerCase() === FN.toLowerCase()) ?? FN; if (r.headers.hasOwnProperty(o)) return e(t); let n = process.env[hct], i = process.env[gct], p = (await Cs.getInstanceAsync())?.getXRayTraceId() ?? i, u = l => typeof l == "string" && l.length > 0; return u(n) && u(p) && (r.headers[FN] = p), e({ ...t, request: r }) } }); var qu, Tie = s(() => { Rie(); UN(); qu = e => ({ applyToStack: t => { t.add(Aie(), Cie) } }) }); var i_ = s(() => { Tie(); UN() }); function xct(e) { return e === void 0 ? !0 : typeof e == "string" && e.length <= 50 } function Vu(e) { let t = yo(e.userAgentAppId ?? HN), { customUserAgent: r } = e; return Object.assign(e, { customUserAgent: typeof r == "string" ? [[r]] : r, userAgentAppId: async () => { let o = await t(); if (!xct(o)) { let n = e.logger?.constructor?.name === "NoOpLogger" || !e.logger ? console : e.logger; typeof o != "string" ? n?.warn("userAgentAppId must be a string or undefined.") : o.length > 50 && n?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.") } return o } }) } var HN, wie = s(() => { Ie(); HN = void 0 }); var GN = s(() => { Ft() }); var jN, bie = s(() => { Ft(); GN(); jN = (e, t = !1) => { if (t) { for (let r of e.split(".")) if (!jN(r)) return !1; return !0 } return !(!Or(e) || e.length < 3 || e.length > 63 || e !== e.toLowerCase() || No(e)) } }); var Iie, Ect, vie, Pie = s(() => { Iie = ":", Ect = "/", vie = e => { let t = e.split(Iie); if (t.length < 6) return null; let [r, o, n, i, a, ...c] = t; if (r !== "arn" || o === "" || n === "" || c.join(Iie) === "") return null; let p = c.map(u => u.split(Ect)).flat(); return { partition: o, service: n, region: i, accountId: a, resourceId: p } } }); var Die, Oie = s(() => { Die = { partitions: [{ id: "aws", outputs: { dnsSuffix: "amazonaws.com", dualStackDnsSuffix: "api.aws", implicitGlobalRegion: "us-east-1", name: "aws", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$", regions: { "af-south-1": { description: "Africa (Cape Town)" }, "ap-east-1": { description: "Asia Pacific (Hong Kong)" }, "ap-east-2": { description: "Asia Pacific (Taipei)" }, "ap-northeast-1": { description: "Asia Pacific (Tokyo)" }, "ap-northeast-2": { description: "Asia Pacific (Seoul)" }, "ap-northeast-3": { description: "Asia Pacific (Osaka)" }, "ap-south-1": { description: "Asia Pacific (Mumbai)" }, "ap-south-2": { description: "Asia Pacific (Hyderabad)" }, "ap-southeast-1": { description: "Asia Pacific (Singapore)" }, "ap-southeast-2": { description: "Asia Pacific (Sydney)" }, "ap-southeast-3": { description: "Asia Pacific (Jakarta)" }, "ap-southeast-4": { description: "Asia Pacific (Melbourne)" }, "ap-southeast-5": { description: "Asia Pacific (Malaysia)" }, "ap-southeast-6": { description: "Asia Pacific (New Zealand)" }, "ap-southeast-7": { description: "Asia Pacific (Thailand)" }, "aws-global": { description: "aws global region" }, "ca-central-1": { description: "Canada (Central)" }, "ca-west-1": { description: "Canada West (Calgary)" }, "eu-central-1": { description: "Europe (Frankfurt)" }, "eu-central-2": { description: "Europe (Zurich)" }, "eu-north-1": { description: "Europe (Stockholm)" }, "eu-south-1": { description: "Europe (Milan)" }, "eu-south-2": { description: "Europe (Spain)" }, "eu-west-1": { description: "Europe (Ireland)" }, "eu-west-2": { description: "Europe (London)" }, "eu-west-3": { description: "Europe (Paris)" }, "il-central-1": { description: "Israel (Tel Aviv)" }, "me-central-1": { description: "Middle East (UAE)" }, "me-south-1": { description: "Middle East (Bahrain)" }, "mx-central-1": { description: "Mexico (Central)" }, "sa-east-1": { description: "South America (Sao Paulo)" }, "us-east-1": { description: "US East (N. Virginia)" }, "us-east-2": { description: "US East (Ohio)" }, "us-west-1": { description: "US West (N. California)" }, "us-west-2": { description: "US West (Oregon)" } } }, { id: "aws-cn", outputs: { dnsSuffix: "amazonaws.com.cn", dualStackDnsSuffix: "api.amazonwebservices.com.cn", implicitGlobalRegion: "cn-northwest-1", name: "aws-cn", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^cn\\-\\w+\\-\\d+$", regions: { "aws-cn-global": { description: "aws-cn global region" }, "cn-north-1": { description: "China (Beijing)" }, "cn-northwest-1": { description: "China (Ningxia)" } } }, { id: "aws-eusc", outputs: { dnsSuffix: "amazonaws.eu", dualStackDnsSuffix: "api.amazonwebservices.eu", implicitGlobalRegion: "eusc-de-east-1", name: "aws-eusc", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$", regions: { "eusc-de-east-1": { description: "EU (Germany)" } } }, { id: "aws-iso", outputs: { dnsSuffix: "c2s.ic.gov", dualStackDnsSuffix: "api.aws.ic.gov", implicitGlobalRegion: "us-iso-east-1", name: "aws-iso", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-iso\\-\\w+\\-\\d+$", regions: { "aws-iso-global": { description: "aws-iso global region" }, "us-iso-east-1": { description: "US ISO East" }, "us-iso-west-1": { description: "US ISO WEST" } } }, { id: "aws-iso-b", outputs: { dnsSuffix: "sc2s.sgov.gov", dualStackDnsSuffix: "api.aws.scloud", implicitGlobalRegion: "us-isob-east-1", name: "aws-iso-b", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-isob\\-\\w+\\-\\d+$", regions: { "aws-iso-b-global": { description: "aws-iso-b global region" }, "us-isob-east-1": { description: "US ISOB East (Ohio)" }, "us-isob-west-1": { description: "US ISOB West" } } }, { id: "aws-iso-e", outputs: { dnsSuffix: "cloud.adc-e.uk", dualStackDnsSuffix: "api.cloud-aws.adc-e.uk", implicitGlobalRegion: "eu-isoe-west-1", name: "aws-iso-e", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$", regions: { "aws-iso-e-global": { description: "aws-iso-e global region" }, "eu-isoe-west-1": { description: "EU ISOE West" } } }, { id: "aws-iso-f", outputs: { dnsSuffix: "csp.hci.ic.gov", dualStackDnsSuffix: "api.aws.hci.ic.gov", implicitGlobalRegion: "us-isof-south-1", name: "aws-iso-f", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-isof\\-\\w+\\-\\d+$", regions: { "aws-iso-f-global": { description: "aws-iso-f global region" }, "us-isof-east-1": { description: "US ISOF EAST" }, "us-isof-south-1": { description: "US ISOF SOUTH" } } }, { id: "aws-us-gov", outputs: { dnsSuffix: "amazonaws.com", dualStackDnsSuffix: "api.aws", implicitGlobalRegion: "us-gov-west-1", name: "aws-us-gov", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-gov\\-\\w+\\-\\d+$", regions: { "aws-us-gov-global": { description: "aws-us-gov global region" }, "us-gov-east-1": { description: "AWS GovCloud (US-East)" }, "us-gov-west-1": { description: "AWS GovCloud (US-West)" } } }], version: "1.1" } }); var Sct, _ct, kie, Nie, qN = s(() => { Oie(); Sct = Die, _ct = "", kie = e => { let { partitions: t } = Sct; for (let o of t) { let { regions: n, outputs: i } = o; for (let [a, c] of Object.entries(n)) if (a === e) return { ...i, ...c } } for (let o of t) { let { regionRegex: n, outputs: i } = o; if (new RegExp(n).test(e)) return { ...i } } let r = t.find(o => o.id === "aws"); if (!r) throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."); return { ...r.outputs } }, Nie = () => _ct }); var Oc, Bie = s(() => { Ft(); bie(); Pie(); qN(); Oc = { isVirtualHostableS3Bucket: jN, parseArn: vie, partition: kie }; Rt.aws = Oc }); function Lie(e) { let t = {}; if (e = e.replace(/^\?/, ""), e) for (let r of e.split("&")) { let [o, n = null] = r.split("="); o = decodeURIComponent(o), n && (n = decodeURIComponent(n)), o in t ? Array.isArray(t[o]) ? t[o].push(n) : t[o] = [t[o], n] : t[o] = n } return t } var Mie = s(() => { }); var Tn, zu = s(() => { Mie(); Tn = e => { if (typeof e == "string") return Tn(new URL(e)); let { hostname: t, pathname: r, port: o, protocol: n, search: i } = e, a; return i && (a = Lie(i)), { hostname: t, port: o ? parseInt(o) : void 0, protocol: n, path: r, query: a } } }); var $ie = s(() => { }); var Fie = s(() => { }); var Uie = s(() => { }); var Hie = s(() => { }); var Gie = s(() => { }); var jie = s(() => { }); var qie = s(() => { }); var Vie = s(() => { }); var zie = s(() => { Uie(); Hie(); Gie(); jie(); qie(); Vie() }); var mh = s(() => { Bie(); qN(); GN(); $ie(); Fie(); zie() }); async function Wie(e, t, r) { if (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" && ye(e, "PROTOCOL_RPC_V2_CBOR", "M"), typeof t.retryStrategy == "function") { let i = await t.retryStrategy(); typeof i.acquireInitialRetryToken == "function" ? i.constructor?.name?.includes("Adaptive") ? ye(e, "RETRY_MODE_ADAPTIVE", "F") : ye(e, "RETRY_MODE_STANDARD", "E") : ye(e, "RETRY_MODE_LEGACY", "D") } if (typeof t.accountIdEndpointMode == "function") { let i = e.endpointV2; switch (String(i?.url?.hostname).match(Cct) && ye(e, "ACCOUNT_ID_ENDPOINT", "O"), await t.accountIdEndpointMode?.()) { case "disabled": ye(e, "ACCOUNT_ID_MODE_DISABLED", "Q"); break; case "preferred": ye(e, "ACCOUNT_ID_MODE_PREFERRED", "P"); break; case "required": ye(e, "ACCOUNT_ID_MODE_REQUIRED", "R"); break } } let n = e.__smithy_context?.selectedHttpAuthScheme?.identity; if (n?.$source) { let i = n; i.accountId && ye(e, "RESOLVED_ACCOUNT_ID", "T"); for (let [a, c] of Object.entries(i.$source ?? {})) ye(e, a, c) } } var Cct, Kie = s(() => { Ye(); Cct = /\d{12}\.ddb/ }); var VN, a_, zN, c_, Qie, Yie, WN, Xie = s(() => { VN = "user-agent", a_ = "x-amz-user-agent", zN = " ", c_ = "/", Qie = /[^!$%&'*+\-.^_`|~\w]/g, Yie = /[^!$%&'*+\-.^_`|~\w#]/g, WN = "-" }); function Jie(e) { let t = ""; for (let r in e) { let o = e[r]; if (t.length + o.length + 1 <= 1024) { t.length ? t += "," + o : t += o; continue } break } return t } var Zie = s(() => { }); var Rct, p_, Act, Wu, eae = s(() => { mh(); Ms(); Kie(); Xie(); Zie(); Rct = e => (t, r) => async o => { let { request: n } = o; if (!An.isInstance(n)) return t(o); let { headers: i } = n, a = r?.userAgent?.map(p_) || [], c = (await e.defaultUserAgentProvider()).map(p_); await Wie(r, e, o); let p = r; c.push(`m/${Jie(Object.assign({}, r.__smithy_context?.features, p.__aws_sdk_context?.features))}`); let u = e?.customUserAgent?.map(p_) || [], l = await e.userAgentAppId(); l && c.push(p_(["app", `${l}`])); let m = Nie(), f = (m ? [m] : []).concat([...c, ...a, ...u]).join(zN), h = [...c.filter(E => E.startsWith("aws-sdk-")), ...u].join(zN); return e.runtime !== "browser" ? (h && (i[a_] = i[a_] ? `${i[VN]} ${h}` : h), i[VN] = f) : i[a_] = f, t({ ...o, request: n }) }, p_ = e => { let t = e[0].split(c_).map(a => a.replace(Qie, WN)).join(c_), r = e[1]?.replace(Yie, WN), o = t.indexOf(c_), n = t.substring(0, o), i = t.substring(o + 1); return n === "api" && (i = i.toLowerCase()), [n, i, r].filter(a => a && a.length > 0).reduce((a, c, p) => { switch (p) { case 0: return c; case 1: return `${a}/${c}`; default: return `${a}#${c}` } }, "") }, Act = { name: "getUserAgentMiddleware", step: "build", priority: "low", tags: ["SET_USER_AGENT", "USER_AGENT"], override: !0 }, Wu = e => ({ applyToStack: t => { t.add(Rct(e), Act) } }) }); var lh = s(() => { wie(); eae() }); var Tct, wct, Ku, tae = s(() => { os(); Tct = "AWS_USE_DUALSTACK_ENDPOINT", wct = "use_dualstack_endpoint", Ku = { environmentVariableSelector: e => xt(e, Tct, ct.ENV), configFileSelector: e => xt(e, wct, ct.CONFIG), default: !1 } }); var bct, Ict, Qu, rae = s(() => { os(); bct = "AWS_USE_FIPS_ENDPOINT", Ict = "use_fips_endpoint", Qu = { environmentVariableSelector: e => xt(e, bct, ct.ENV), configFileSelector: e => xt(e, Ict, ct.CONFIG), default: !1 } }); var oae = s(() => { }); var nae = s(() => { }); var sae = s(() => { tae(); rae(); oae(); nae() }); var vct, Pct, xa, Yu, iae = s(() => { vct = "AWS_REGION", Pct = "region", xa = { environmentVariableSelector: e => e[vct], configFileSelector: e => e[Pct], default: () => { throw new Error("Region is missing") } }, Yu = { preferredFile: "credentials" } }); var aae, cae, pae = s(() => { Ft(); aae = new Set, cae = (e, t = Or) => { if (!aae.has(e) && !t(e)) if (e === "*") console.warn('@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.'); else throw new Error(`Region not accepted: region="${e}" is not a valid hostname component.`); else aae.add(e) } }); var u_, KN = s(() => { u_ = e => typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")) }); var uae, mae = s(() => { KN(); uae = e => u_(e) ? ["fips-aws-global", "aws-fips"].includes(e) ? "us-east-1" : e.replace(/fips-(dkr-|prod-)?|-fips/, "") : e }); var Xu, lae = s(() => { pae(); mae(); KN(); Xu = e => { let { region: t, useFipsEndpoint: r } = e; if (!t) throw new Error("Region is missing"); return Object.assign(e, { region: async () => { let o = typeof t == "function" ? await t() : t, n = uae(o); return cae(n), n }, useFipsEndpoint: async () => { let o = typeof t == "string" ? t : await t(); return u_(o) ? !0 : typeof r != "function" ? Promise.resolve(!!r) : r() } }) } }); var dae = s(() => { iae(); lae() }); var fae = s(() => { }); var hae = s(() => { }); var gae = s(() => { }); var xae = s(() => { fae(); hae(); gae() }); var Ea = s(() => { sae(); dae(); xae() }); function Oct(e) { return t => async r => { let o = r.request; if (An.isInstance(o)) { let { body: n, headers: i } = o; if (n && Object.keys(i).map(a => a.toLowerCase()).indexOf(Eae) === -1) try { let a = e(n); o.headers = { ...o.headers, [Eae]: String(a) } } catch { } } return t({ ...r, request: o }) } } var Eae, Dct, Ju, m_ = s(() => { Ms(); Eae = "content-length"; Dct = { step: "build", tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"], name: "contentLengthMiddleware", override: !0 }, Ju = e => ({ applyToStack: t => { t.add(Oct(e.bodyLengthChecker), Dct) } }) }); var yae, kct, Nct, Bct, Lct, Mct, Sae = s(() => { yae = async e => { let t = e?.Bucket || ""; if (typeof e.Bucket == "string" && (e.Bucket = t.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), Mct(t)) { if (e.ForcePathStyle === !0) throw new Error("Path-style addressing cannot be used with ARN buckets") } else (!Lct(t) || t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:") || t.toLowerCase() !== t || t.length < 3) && (e.ForcePathStyle = !0); return e.DisableMultiRegionAccessPoints && (e.disableMultiRegionAccessPoints = !0, e.DisableMRAP = !0), e }, kct = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, Nct = /(\d+\.){3}\d+/, Bct = /\.\./, Lct = e => kct.test(e) && !Nct.test(e) && !Bct.test(e), Mct = e => { let [t, r, o, , , n] = e.split(":"), i = t === "arn" && e.split(":").length >= 6, a = !!(i && r && o && n); if (i && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`); return a } }); var _ae = s(() => { Sae() }); var Cae, Rae = s(() => { Cae = (e, t, r, o = !1) => { let n = async () => { let i; return o ? i = r.clientContextParams?.[e] ?? r[e] ?? r[t] : i = r[e] ?? r[t], typeof i == "function" ? i() : i }; return e === "credentialScope" || t === "CredentialScope" ? async () => { let i = typeof r.credentials == "function" ? await r.credentials() : r.credentials; return i?.credentialScope ?? i?.CredentialScope } : e === "accountId" || t === "AccountId" ? async () => { let i = typeof r.credentials == "function" ? await r.credentials() : r.credentials; return i?.accountId ?? i?.AccountId } : e === "endpoint" || t === "endpoint" ? async () => { if (r.isCustomEndpoint === !1) return; let i = await n(); if (i && typeof i == "object") { if ("url" in i) return i.url.href; if ("hostname" in i) { let { protocol: a, hostname: c, port: p, path: u } = i; return `${a}//${c}${p ? ":" + p : ""}${u}` } } return i } : n } }); function l_(e) { try { let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? [])); return t.delete("CONFIG"), t.delete("CONFIG_PREFIX_SEPARATOR"), t.delete("ENV"), [...t].join(", ") } catch { return e } } var QN = s(() => { }); var Aae, Tae = s(() => { Z(); QN(); Aae = (e, t) => async () => { try { let r = e(process.env, t); if (r === void 0) throw new Error; return r } catch (r) { throw new I(r.message || `Not found in ENV: ${l_(e.toString())}`, { logger: t?.logger }) } } }); import { homedir as $ct } from "os"; import { sep as Fct } from "path"; var YN, Uct, Zu, dh = s(() => { YN = {}, Uct = () => process && process.geteuid ? `${process.geteuid()}` : "DEFAULT", Zu = () => { let { HOME: e, USERPROFILE: t, HOMEPATH: r, HOMEDRIVE: o = `C:${Fct}` } = process.env; if (e) return e; if (t) return t; if (r) return `${o}${r}`; let n = Uct(); return YN[n] || (YN[n] = $ct()), YN[n] } }); var Hct, Gct, wae, bae = s(() => { Hct = "AWS_PROFILE", Gct = "default", wae = e => e.profile || process.env[Hct] || Gct }); var Iae = s(() => { }); var $s, d_ = s(() => { $s = "." }); var vae, Pae = s(() => { uh(); d_(); vae = e => Object.entries(e).filter(([t]) => { let r = t.indexOf($s); return r === -1 ? !1 : Object.values(Pc).includes(t.substring(0, r)) }).reduce((t, [r, o]) => { let n = r.indexOf($s), i = r.substring(0, n) === Pc.PROFILE ? r.substring(n + 1) : r; return t[i] = o, t }, { ...e.default && { default: e.default } }) }); import { join as jct } from "path"; var qct, Oae, Dae = s(() => { dh(); qct = "AWS_CONFIG_FILE", Oae = () => process.env[qct] || jct(Zu(), ".aws", "config") }); import { join as Vct } from "path"; var zct, kae, Nae = s(() => { dh(); zct = "AWS_SHARED_CREDENTIALS_FILE", kae = () => process.env[zct] || Vct(Zu(), ".aws", "credentials") }); var Wct, Kct, XN, Bae = s(() => { uh(); d_(); Wct = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/, Kct = ["__proto__", "profile __proto__"], XN = e => { let t = {}, r, o; for (let n of e.split(/\r?\n/)) { let i = n.split(/(^|\s)[;#]/)[0].trim(); if (i[0] === "[" && i[i.length - 1] === "]") { r = void 0, o = void 0; let c = i.substring(1, i.length - 1), p = Wct.exec(c); if (p) { let [, u, , l] = p; Object.values(Pc).includes(u) && (r = [u, l].join($s)) } else r = c; if (Kct.includes(c)) throw new Error(`Found invalid profile name "${c}"`) } else if (r) { let c = i.indexOf("="); if (![0, -1].includes(c)) { let [p, u] = [i.substring(0, c).trim(), i.substring(c + 1).trim()]; if (u === "") o = p; else { o && n.trimStart() === n && (o = void 0), t[r] = t[r] || {}; let l = o ? [o, p].join($s) : p; t[r][l] = u } } } } return t } }); import { readFile as Qct } from "node:fs/promises"; var JN, Lae, ZN, Mae = s(() => { JN = {}, Lae = {}, ZN = (e, t) => Lae[e] !== void 0 ? Lae[e] : ((!JN[e] || t?.ignoreCache) && (JN[e] = Qct(e, "utf8")), JN[e]) }); import { join as $ae } from "path"; var Fae, Uae, Hae = s(() => { Pae(); Dae(); Nae(); dh(); Bae(); Mae(); d_(); Fae = () => ({}), Uae = async (e = {}) => { let { filepath: t = kae(), configFilepath: r = Oae() } = e, o = Zu(), n = "~/", i = t; t.startsWith(n) && (i = $ae(o, t.slice(2))); let a = r; r.startsWith(n) && (a = $ae(o, r.slice(2))); let c = await Promise.all([ZN(a, { ignoreCache: e.ignoreCache }).then(XN).then(vae).catch(Fae), ZN(i, { ignoreCache: e.ignoreCache }).then(XN).catch(Fae)]); return { configFile: c[0], credentialsFile: c[1] } } }); var Gae = s(() => { }); var jae = s(() => { }); var qae = s(() => { }); var eB = s(() => { dh(); bae(); Iae(); Hae(); Gae(); jae(); qae() }); var Vae, zae = s(() => { Z(); eB(); QN(); Vae = (e, { preferredFile: t = "config", ...r } = {}) => async () => { let o = wae(r), { configFile: n, credentialsFile: i } = await Uae(r), a = i[o] || {}, c = n[o] || {}, p = t === "config" ? { ...a, ...c } : { ...c, ...a }; try { let l = e(p, t === "config" ? n : i); if (l === void 0) throw new Error; return l } catch (u) { throw new I(u.message || `Not found in config files w/ profile [${o}]: ${l_(e.toString())}`, { logger: r.logger }) } } }); var Yct, Wae, Kae = s(() => { Z(); Yct = e => typeof e == "function", Wae = e => Yct(e) ? async () => await e() : Is(e) }); var tt, Qae = s(() => { Z(); Tae(); zae(); Kae(); tt = ({ environmentVariableSelector: e, configFileSelector: t, default: r }, o = {}) => { let { signingName: n, logger: i } = o; return jr(sr(Aae(e, { signingName: n, logger: i }), Vae(t, o), Wae(r))) } }); var ya = s(() => { Qae() }); var Yae, Xae, Jae, Zae = s(() => { eB(); Yae = "AWS_ENDPOINT_URL", Xae = "endpoint_url", Jae = e => ({ environmentVariableSelector: t => { let r = e.split(" ").map(i => i.toUpperCase()), o = t[[Yae, ...r].join("_")]; if (o) return o; let n = t[Yae]; if (n) return n }, configFileSelector: (t, r) => { if (r && t.services) { let n = r[["services", t.services].join($s)]; if (n) { let i = e.split(" ").map(c => c.toLowerCase()), a = n[[i.join("_"), Xae].join($s)]; if (a) return a } } let o = t[Xae]; if (o) return o }, default: void 0 }) }); var f_, tB = s(() => { ya(); Zae(); f_ = async e => tt(Jae(e ?? ""))() }); var h_, g_ = s(() => { zu(); h_ = e => typeof e == "object" ? "url" in e ? Tn(e.url) : e : Tn(e) }); var ece, Xct, rB = s(() => { _ae(); Rae(); tB(); g_(); ece = async (e, t, r, o) => { if (!r.isCustomEndpoint) { let a; r.serviceConfiguredEndpoint ? a = await r.serviceConfiguredEndpoint() : a = await f_(r.serviceId), a && (r.endpoint = () => Promise.resolve(h_(a)), r.isCustomEndpoint = !0) } let n = await Xct(e, t, r); if (typeof r.endpointProvider != "function") throw new Error("config.endpointProvider is not set."); return r.endpointProvider(n, o) }, Xct = async (e, t, r) => { let o = {}, n = t?.getEndpointParameterInstructions?.() || {}; for (let [i, a] of Object.entries(n)) switch (a.type) { case "staticContextParams": o[i] = a.value; break; case "contextParams": o[i] = e[a.name]; break; case "clientContextParams": case "builtInParams": o[i] = await Cae(a.name, i, r, a.type !== "builtInParams")(); break; case "operationContextParams": o[i] = a.get(e); break; default: throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(a)) }return Object.keys(n).length === 0 && Object.assign(o, r), String(r.serviceId).toLowerCase() === "s3" && await yae(o), o } }); var tce = s(() => { rB(); g_() }); var rce, oB = s(() => { Ie(); gt(); rB(); rce = ({ config: e, instructions: t }) => (r, o) => async n => { e.isCustomEndpoint && ea(o, "ENDPOINT_OVERRIDE", "N"); let i = await ece(n.input, { getEndpointParameterInstructions() { return t } }, { ...e }, o); o.endpointV2 = i, o.authSchemes = i.properties?.authSchemes; let a = o.authSchemes?.[0]; if (a) { o.signing_region = a.signingRegion, o.signing_service = a.signingName; let p = je(o)?.selectedHttpAuthScheme?.httpAuthOption; p && (p.signingProperties = Object.assign(p.signingProperties || {}, { signing_region: a.signingRegion, signingRegion: a.signingRegion, signing_service: a.signingName, signingName: a.signingName, signingRegionSet: a.signingRegionSet }, a.properties)) } return r({ ...n }) } }); var oce = s(() => { }); var nce = s(() => { }); var sce, ice = s(() => { sce = { name: "serializerMiddleware", step: "serialize", tags: ["SERIALIZER"], override: !0 } }); var ace = s(() => { oce(); ice(); nce() }); var Jct, Sa, cce = s(() => { ace(); oB(); Jct = { step: "serialize", tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"], name: "endpointV2Middleware", override: !0, relation: "before", toMiddleware: sce.name }, Sa = (e, t) => ({ applyToStack: r => { r.addRelativeTo(rce({ config: e, instructions: t }), Jct) } }) }); var em, pce = s(() => { gt(); tB(); g_(); em = e => { let t = e.tls ?? !0, { endpoint: r, useDualstackEndpoint: o, useFipsEndpoint: n } = e, i = r != null ? async () => h_(await le(r)()) : void 0, c = Object.assign(e, { endpoint: i, tls: t, isCustomEndpoint: !!r, useDualstackEndpoint: le(o ?? !1), useFipsEndpoint: le(n ?? !1) }), p; return c.serviceConfiguredEndpoint = async () => (e.serviceId && !p && (p = f_(e.serviceId)), p), c } }); var uce = s(() => { }); var mce = s(() => { }); var _a = s(() => { tce(); oB(); cce(); pce(); uce(); mce() }); var Ti, tm, Ca, x_ = s(() => { (function (e) { e.STANDARD = "standard", e.ADAPTIVE = "adaptive" })(Ti || (Ti = {})); tm = 3, Ca = Ti.STANDARD }); var lce, dce, fce, hce, gce, xce = s(() => { lce = ["BandwidthLimitExceeded", "EC2ThrottledException", "LimitExceededException", "PriorRequestNotComplete", "ProvisionedThroughputExceededException", "RequestLimitExceeded", "RequestThrottled", "RequestThrottledException", "SlowDown", "ThrottledException", "Throttling", "ThrottlingException", "TooManyRequestsException", "TransactionInProgressException"], dce = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], fce = [500, 502, 503, 504], hce = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], gce = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"] }); var Zct, ept, tpt, E_, y_, Ece, nB = s(() => { xce(); Zct = e => e?.$retryable !== void 0, ept = e => e.$metadata?.clockSkewCorrected, tpt = e => { let t = new Set(["Failed to fetch", "NetworkError when attempting to fetch resource", "The Internet connection appears to be offline", "Load failed", "Network request failed"]); return e && e instanceof TypeError ? t.has(e.message) : !1 }, E_ = e => e.$metadata?.httpStatusCode === 429 || lce.includes(e.name) || e.$retryable?.throttling == !0, y_ = (e, t = 0) => Zct(e) || ept(e) || dce.includes(e.name) || hce.includes(e?.code || "") || gce.includes(e?.code || "") || fce.includes(e.$metadata?.httpStatusCode || 0) || tpt(e) || e.cause !== void 0 && t <= 10 && y_(e.cause, t + 1), Ece = e => { if (e.$metadata?.httpStatusCode !== void 0) { let t = e.$metadata.httpStatusCode; return 500 <= t && t <= 599 && !y_(e) } return !1 } }); var S_, sB = s(() => { nB(); S_ = class e { static setTimeoutFn = setTimeout; beta; minCapacity; minFillRate; scaleConstant; smooth; currentCapacity = 0; enabled = !1; lastMaxRate = 0; measuredTxRate = 0; requestCount = 0; fillRate; lastThrottleTime; lastTimestamp = 0; lastTxRateBucket; maxCapacity; timeWindow = 0; constructor(t) { this.beta = t?.beta ?? .7, this.minCapacity = t?.minCapacity ?? 1, this.minFillRate = t?.minFillRate ?? .5, this.scaleConstant = t?.scaleConstant ?? .4, this.smooth = t?.smooth ?? .8; let r = this.getCurrentTimeInSeconds(); this.lastThrottleTime = r, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity } getCurrentTimeInSeconds() { return Date.now() / 1e3 } async getSendToken() { return this.acquireTokenBucket(1) } async acquireTokenBucket(t) { if (this.enabled) { if (this.refillTokenBucket(), t > this.currentCapacity) { let r = (t - this.currentCapacity) / this.fillRate * 1e3; await new Promise(o => e.setTimeoutFn(o, r)) } this.currentCapacity = this.currentCapacity - t } } refillTokenBucket() { let t = this.getCurrentTimeInSeconds(); if (!this.lastTimestamp) { this.lastTimestamp = t; return } let r = (t - this.lastTimestamp) * this.fillRate; this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + r), this.lastTimestamp = t } updateClientSendingRate(t) { let r; if (this.updateMeasuredRate(), E_(t)) { let n = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate; this.lastMaxRate = n, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), r = this.cubicThrottle(n), this.enableTokenBucket() } else this.calculateTimeWindow(), r = this.cubicSuccess(this.getCurrentTimeInSeconds()); let o = Math.min(r, 2 * this.measuredTxRate); this.updateTokenBucketRate(o) } calculateTimeWindow() { this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3)) } cubicThrottle(t) { return this.getPrecise(t * this.beta) } cubicSuccess(t) { return this.getPrecise(this.scaleConstant * Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate) } enableTokenBucket() { this.enabled = !0 } updateTokenBucketRate(t) { this.refillTokenBucket(), this.fillRate = Math.max(t, this.minFillRate), this.maxCapacity = Math.max(t, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity) } updateMeasuredRate() { let t = this.getCurrentTimeInSeconds(), r = Math.floor(t * 2) / 2; if (this.requestCount++, r > this.lastTxRateBucket) { let o = this.requestCount / (r - this.lastTxRateBucket); this.measuredTxRate = this.getPrecise(o * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = r } } getPrecise(t) { return parseFloat(t.toFixed(8)) } } }); var yce, Sce, _ce = s(() => { yce = "amz-sdk-invocation-id", Sce = "amz-sdk-request" }); var Rce, Ace = s(() => { Rce = () => { let e = 100; return { computeNextBackoffDelay: o => Math.floor(Math.min(2e4, Math.random() * 2 ** o * e)), setDelayBase: o => { e = o } } } }); var iB, Tce = s(() => { iB = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({ getRetryCount: () => t, getRetryDelay: () => Math.min(2e4, e), getRetryCost: () => r }) }); var rm, aB = s(() => { x_(); Ace(); Tce(); rm = class { maxAttempts; mode = Ti.STANDARD; capacity = 500; retryBackoffStrategy = Rce(); maxAttemptsProvider; constructor(t) { this.maxAttempts = t, this.maxAttemptsProvider = typeof t == "function" ? t : async () => t } async acquireInitialRetryToken(t) { return iB({ retryDelay: 100, retryCount: 0 }) } async refreshRetryTokenForRetry(t, r) { let o = await this.getMaxAttempts(); if (this.shouldRetry(t, r, o)) { let n = r.errorType; this.retryBackoffStrategy.setDelayBase(n === "THROTTLING" ? 500 : 100); let i = this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()), a = r.retryAfterHint ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i) : i, c = this.getCapacityCost(n); return this.capacity -= c, iB({ retryDelay: a, retryCount: t.getRetryCount() + 1, retryCost: c }) } throw new Error("No retry token available") } recordSuccess(t) { this.capacity = Math.max(500, this.capacity + (t.getRetryCost() ?? 1)) } getCapacity() { return this.capacity } async getMaxAttempts() { try { return await this.maxAttemptsProvider() } catch { return console.warn(`Max attempts provider could not resolve. Using default of ${tm}`), tm } } shouldRetry(t, r, o) { return t.getRetryCount() + 1 < o && this.capacity >= this.getCapacityCost(r.errorType) && this.isRetryableError(r.errorType) } getCapacityCost(t) { return t === "TRANSIENT" ? 10 : 5 } isRetryableError(t) { return t === "THROTTLING" || t === "TRANSIENT" } } }); var __, wce = s(() => { x_(); sB(); aB(); __ = class { maxAttemptsProvider; rateLimiter; standardRetryStrategy; mode = Ti.ADAPTIVE; constructor(t, r) { this.maxAttemptsProvider = t; let { rateLimiter: o } = r ?? {}; this.rateLimiter = o ?? new S_, this.standardRetryStrategy = new rm(t) } async acquireInitialRetryToken(t) { return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(t) } async refreshRetryTokenForRetry(t, r) { return this.rateLimiter.updateClientSendingRate(r), this.standardRetryStrategy.refreshRetryTokenForRetry(t, r) } recordSuccess(t) { this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(t) } } }); var bce = s(() => { }); var Ice = s(() => { }); var om = s(() => { wce(); bce(); sB(); aB(); x_(); _ce(); Ice() }); var vce = s(() => { }); var Pce = s(() => { }); var Oce, Dce = s(() => { Oce = e => e instanceof Error ? e : e instanceof Object ? Object.assign(new Error, e) : typeof e == "string" ? new Error(e) : new Error(`AWS SDK error wrapper for ${e}`) }); var kce = s(() => { }); var Nce = s(() => { }); var Bce, Lce, nm, sm, npt, spt, im, Mce = s(() => { gt(); om(); Bce = "AWS_MAX_ATTEMPTS", Lce = "max_attempts", nm = { environmentVariableSelector: e => { let t = e[Bce]; if (!t) return; let r = parseInt(t); if (Number.isNaN(r)) throw new Error(`Environment variable ${Bce} mast be a number, got "${t}"`); return r }, configFileSelector: e => { let t = e[Lce]; if (!t) return; let r = parseInt(t); if (Number.isNaN(r)) throw new Error(`Shared config file entry ${Lce} mast be a number, got "${t}"`); return r }, default: tm }, sm = e => { let { retryStrategy: t, retryMode: r, maxAttempts: o } = e, n = le(o ?? tm); return Object.assign(e, { maxAttempts: n, retryStrategy: async () => t || (await le(r)() === Ti.ADAPTIVE ? new __(n) : new rm(n)) }) }, npt = "AWS_RETRY_MODE", spt = "retry_mode", im = { environmentVariableSelector: e => e[npt], configFileSelector: e => e[spt], default: Ca } }); var $ce = s(() => { }); var Dc, Ra, am, Fce, Uce, Hce = s(() => { Dc = (e, t) => { let r = []; if (e && r.push(e), t) for (let o of t) r.push(o); return r }, Ra = (e, t) => `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`, am = () => { let e = [], t = [], r = !1, o = new Set, n = m => m.sort((f, h) => Fce[h.step] - Fce[f.step] || Uce[h.priority || "normal"] - Uce[f.priority || "normal"]), i = m => { let f = !1, h = E => { let S = Dc(E.name, E.aliases); if (S.includes(m)) { f = !0; for (let y of S) o.delete(y); return !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, a = m => { let f = !1, h = E => { if (E.middleware === m) { f = !0; for (let S of Dc(E.name, E.aliases)) o.delete(S); return !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, c = m => (e.forEach(f => { m.add(f.middleware, { ...f }) }), t.forEach(f => { m.addRelativeTo(f.middleware, { ...f }) }), m.identifyOnResolve?.(l.identifyOnResolve()), m), p = m => { let f = []; return m.before.forEach(h => { h.before.length === 0 && h.after.length === 0 ? f.push(h) : f.push(...p(h)) }), f.push(m), m.after.reverse().forEach(h => { h.before.length === 0 && h.after.length === 0 ? f.push(h) : f.push(...p(h)) }), f }, u = (m = !1) => { let f = [], h = [], E = {}; return e.forEach(y => { let C = { ...y, before: [], after: [] }; for (let b of Dc(C.name, C.aliases)) E[b] = C; f.push(C) }), t.forEach(y => { let C = { ...y, before: [], after: [] }; for (let b of Dc(C.name, C.aliases)) E[b] = C; h.push(C) }), h.forEach(y => { if (y.toMiddleware) { let C = E[y.toMiddleware]; if (C === void 0) { if (m) return; throw new Error(`${y.toMiddleware} is not found when adding ${Ra(y.name, y.aliases)} middleware ${y.relation} ${y.toMiddleware}`) } y.relation === "after" && C.after.push(y), y.relation === "before" && C.before.push(y) } }), n(f).map(p).reduce((y, C) => (y.push(...C), y), []) }, l = { add: (m, f = {}) => { let { name: h, override: E, aliases: S } = f, y = { step: "initialize", priority: "normal", middleware: m, ...f }, C = Dc(h, S); if (C.length > 0) { if (C.some(b => o.has(b))) { if (!E) throw new Error(`Duplicate middleware name '${Ra(h, S)}'`); for (let b of C) { let L = e.findIndex(j => j.name === b || j.aliases?.some(re => re === b)); if (L === -1) continue; let N = e[L]; if (N.step !== y.step || y.priority !== N.priority) throw new Error(`"${Ra(N.name, N.aliases)}" middleware with ${N.priority} priority in ${N.step} step cannot be overridden by "${Ra(h, S)}" middleware with ${y.priority} priority in ${y.step} step.`); e.splice(L, 1) } } for (let b of C) o.add(b) } e.push(y) }, addRelativeTo: (m, f) => { let { name: h, override: E, aliases: S } = f, y = { middleware: m, ...f }, C = Dc(h, S); if (C.length > 0) { if (C.some(b => o.has(b))) { if (!E) throw new Error(`Duplicate middleware name '${Ra(h, S)}'`); for (let b of C) { let L = t.findIndex(j => j.name === b || j.aliases?.some(re => re === b)); if (L === -1) continue; let N = t[L]; if (N.toMiddleware !== y.toMiddleware || N.relation !== y.relation) throw new Error(`"${Ra(N.name, N.aliases)}" middleware ${N.relation} "${N.toMiddleware}" middleware cannot be overridden by "${Ra(h, S)}" middleware ${y.relation} "${y.toMiddleware}" middleware.`); t.splice(L, 1) } } for (let b of C) o.add(b) } t.push(y) }, clone: () => c(am()), use: m => { m.applyToStack(l) }, remove: m => typeof m == "string" ? i(m) : a(m), removeByTag: m => { let f = !1, h = E => { let { tags: S, name: y, aliases: C } = E; if (S && S.includes(m)) { let b = Dc(y, C); for (let L of b) o.delete(L); return f = !0, !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, concat: m => { let f = c(am()); return f.use(m), f.identifyOnResolve(r || f.identifyOnResolve() || (m.identifyOnResolve?.() ?? !1)), f }, applyToStack: c, identify: () => u(!0).map(m => { let f = m.step ?? m.relation + " " + m.toMiddleware; return Ra(m.name, m.aliases) + " - " + f }), identifyOnResolve(m) { return typeof m == "boolean" && (r = m), r }, resolve: (m, f) => { for (let h of u().map(E => E.middleware).reverse()) m = h(m, f); return r && console.log(l.identify()), m } }; return l }, Fce = { initialize: 5, serialize: 4, build: 3, finalizeRequest: 2, deserialize: 1 }, Uce = { high: 3, normal: 2, low: 1 } }); var cB = s(() => { Hce() }); var cs, Gce = s(() => { cB(); cs = class { config; middlewareStack = am(); initConfig; handlers; constructor(t) { this.config = t; let { protocol: r, protocolSettings: o } = t; o && typeof r == "function" && (t.protocol = new r(o)) } send(t, r, o) { let n = typeof r != "function" ? r : void 0, i = typeof r == "function" ? r : o, a = n === void 0 && this.config.cacheMiddleware === !0, c; if (a) { this.handlers || (this.handlers = new WeakMap); let p = this.handlers; p.has(t.constructor) ? c = p.get(t.constructor) : (c = t.resolveMiddleware(this.middlewareStack, this.config, n), p.set(t.constructor, c)) } else delete this.handlers, c = t.resolveMiddleware(this.middlewareStack, this.config, n); if (i) c(t).then(p => i(null, p.output), p => i(p)).catch(() => { }); else return c(t).then(p => p.output) } destroy() { this.config?.requestHandler?.destroy?.(), delete this.handlers } } }); var jce = s(() => { }); function C_(e, t) { if (t == null) return t; let r = ue.of(e); if (r.getMergedTraits().sensitive) return pB; if (r.isListSchema()) { if (!!r.getValueSchema().getMergedTraits().sensitive) return pB } else if (r.isMapSchema()) { if (!!r.getKeySchema().getMergedTraits().sensitive || !!r.getValueSchema().getMergedTraits().sensitive) return pB } else if (r.isStructSchema() && typeof t == "object") { let o = t, n = {}; for (let [i, a] of r.structIterator()) o[i] != null && (n[i] = C_(a, o[i])); return n } return t } var pB, qce = s(() => { Oe(); pB = "***SensitiveInformation***" }); var $o, uB, Vce = s(() => { cB(); uh(); qce(); $o = class { middlewareStack = am(); schema; static classBuilder() { return new uB } resolveMiddlewareWithContext(t, r, o, { middlewareFn: n, clientName: i, commandName: a, inputFilterSensitiveLog: c, outputFilterSensitiveLog: p, smithyContext: u, additionalContext: l, CommandCtor: m }) { for (let y of n.bind(this)(m, t, r, o)) this.middlewareStack.use(y); let f = t.concat(this.middlewareStack), { logger: h } = r, E = { logger: h, clientName: i, commandName: a, inputFilterSensitiveLog: c, outputFilterSensitiveLog: p, [Hse]: { commandInstance: this, ...u }, ...l }, { requestHandler: S } = r; return f.resolve(y => S.handle(y.request, o || {}), E) } }, uB = class { _init = () => { }; _ep = {}; _middlewareFn = () => []; _commandName = ""; _clientName = ""; _additionalContext = {}; _smithyContext = {}; _inputFilterSensitiveLog = void 0; _outputFilterSensitiveLog = void 0; _serializer = null; _deserializer = null; _operationSchema; init(t) { this._init = t } ep(t) { return this._ep = t, this } m(t) { return this._middlewareFn = t, this } s(t, r, o = {}) { return this._smithyContext = { service: t, operation: r, ...o }, this } c(t = {}) { return this._additionalContext = t, this } n(t, r) { return this._clientName = t, this._commandName = r, this } f(t = o => o, r = o => o) { return this._inputFilterSensitiveLog = t, this._outputFilterSensitiveLog = r, this } ser(t) { return this._serializer = t, this } de(t) { return this._deserializer = t, this } sc(t) { return this._operationSchema = t, this._smithyContext.operationSchema = t, this } build() { let t = this, r; return r = class extends $o { input; static getEndpointParameterInstructions() { return t._ep } constructor(...[o]) { super(), this.input = o ?? {}, t._init(this), this.schema = t._operationSchema } resolveMiddleware(o, n, i) { let a = t._operationSchema, c = a?.[4] ?? a?.input, p = a?.[5] ?? a?.output; return this.resolveMiddlewareWithContext(o, n, i, { CommandCtor: r, middlewareFn: t._middlewareFn, clientName: t._clientName, commandName: t._commandName, inputFilterSensitiveLog: t._inputFilterSensitiveLog ?? (a ? C_.bind(null, c) : u => u), outputFilterSensitiveLog: t._outputFilterSensitiveLog ?? (a ? C_.bind(null, p) : u => u), smithyContext: t._smithyContext, additionalContext: t._additionalContext }) } serialize = t._serializer; deserialize = t._deserializer } } } }); var zce = s(() => { }); var cm, Wce = s(() => { cm = (e, t) => { for (let r of Object.keys(e)) { let o = e[r], n = async function (a, c, p) { let u = new o(a); if (typeof c == "function") this.send(u, c); else if (typeof p == "function") { if (typeof c != "object") throw new Error(`Expected http options but got ${typeof c}`); this.send(u, c || {}, p) } else return this.send(u, c) }, i = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, ""); t.prototype[i] = n } } }); var Aa, Kce = s(() => { Aa = class e extends Error { $fault; $response; $retryable; $metadata; constructor(t) { super(t.message), Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = t.name, this.$fault = t.$fault, this.$metadata = t.$metadata } static isInstance(t) { if (!t) return !1; let r = t; return e.prototype.isPrototypeOf(r) || !!r.$fault && !!r.$metadata && (r.$fault === "client" || r.$fault === "server") } static [Symbol.hasInstance](t) { if (!t) return !1; let r = t; return this === e ? e.isInstance(t) : e.isInstance(t) ? r.name && this.name ? this.prototype.isPrototypeOf(t) || r.name === this.name : this.prototype.isPrototypeOf(t) : !1 } } }); var Qce = s(() => { }); var pm, Yce = s(() => { pm = e => { switch (e) { case "standard": return { retryMode: "standard", connectionTimeout: 3100 }; case "in-region": return { retryMode: "standard", connectionTimeout: 1100 }; case "cross-region": return { retryMode: "standard", connectionTimeout: 3100 }; case "mobile": return { retryMode: "standard", connectionTimeout: 3e4 }; default: return {} } } }); var Xce, um, Jce = s(() => { Xce = !1, um = e => { e && !Xce && parseInt(e.substring(1, e.indexOf("."))) < 16 && (Xce = !0) } }); var Zce = s(() => { }); var epe, tpe, rpe = s(() => { uh(); epe = e => { let t = []; for (let r in Uu) { let o = Uu[r]; e[o] !== void 0 && t.push({ algorithmId: () => o, checksumConstructor: () => e[o] }) } return { addChecksumAlgorithm(r) { t.push(r) }, checksumAlgorithms() { return t } } }, tpe = e => { let t = {}; return e.checksumAlgorithms().forEach(r => { t[r.algorithmId()] = r.checksumConstructor() }), t } }); var ope, npe, spe = s(() => { ope = e => ({ setRetryStrategy(t) { e.retryStrategy = t }, retryStrategy() { return e.retryStrategy } }), npe = e => { let t = {}; return t.retryStrategy = e.retryStrategy(), t } }); var mm, lm, ipe = s(() => { rpe(); spe(); mm = e => Object.assign(epe(e), ope(e)), lm = e => Object.assign(tpe(e), npe(e)) }); var ape = s(() => { ipe() }); var cpe = s(() => { }); var ppe = s(() => { }); var upe = s(() => { }); var Fs, mpe = s(() => { Fs = class { trace() { } debug() { } info() { } warn() { } error() { } } }); var lpe = s(() => { }); var dpe = s(() => { }); var fpe = s(() => { }); var hpe = s(() => { }); var Xt = s(() => { Gce(); jce(); Vce(); zce(); Wce(); Qce(); Yce(); Jce(); Kce(); Zce(); ape(); cpe(); ppe(); upe(); mpe(); lpe(); dpe(); fpe(); hpe(); Pr() }); import { Readable as ipt } from "stream"; var gpe, xpe = s(() => { gpe = e => e?.body instanceof ipt || typeof ReadableStream < "u" && e?.body instanceof ReadableStream }); var apt, cpt, ppt, upt, mpt, dm, lpt, Epe = s(() => { Ms(); nB(); Xt(); om(); Wp(); xpe(); Dce(); apt = e => (t, r) => async o => { let n = await e.retryStrategy(), i = await e.maxAttempts(); if (cpt(n)) { n = n; let a = await n.acquireInitialRetryToken(r.partition_id), c = new Error, p = 0, u = 0, { request: l } = o, m = An.isInstance(l); for (m && (l.headers[yce] = ro()); ;)try { m && (l.headers[Sce] = `attempt=${p + 1}; max=${i}`); let { response: f, output: h } = await t(o); return n.recordSuccess(a), h.$metadata.attempts = p + 1, h.$metadata.totalRetryDelay = u, { response: f, output: h } } catch (f) { let h = ppt(f); if (c = Oce(f), m && gpe(l)) throw (r.logger instanceof Fs ? console : r.logger)?.warn("An error was encountered in a non-retryable streaming request."), c; try { a = await n.refreshRetryTokenForRetry(a, h) } catch { throw c.$metadata || (c.$metadata = {}), c.$metadata.attempts = p + 1, c.$metadata.totalRetryDelay = u, c } p = a.getRetryCount(); let E = a.getRetryDelay(); u += E, await new Promise(S => setTimeout(S, E)) } } else return n = n, n?.mode && (r.userAgent = [...r.userAgent || [], ["cfg/retry-mode", n.mode]]), n.retry(t, o) }, cpt = e => typeof e.acquireInitialRetryToken < "u" && typeof e.refreshRetryTokenForRetry < "u" && typeof e.recordSuccess < "u", ppt = e => { let t = { error: e, errorType: upt(e) }, r = lpt(e.$response); return r && (t.retryAfterHint = r), t }, upt = e => E_(e) ? "THROTTLING" : y_(e) ? "TRANSIENT" : Ece(e) ? "SERVER_ERROR" : "CLIENT_ERROR", mpt = { name: "retryMiddleware", tags: ["RETRY"], step: "finalizeRequest", priority: "high", override: !0 }, dm = e => ({ applyToStack: t => { t.add(apt(e), mpt) } }), lpt = e => { if (!Hu.isInstance(e)) return; let t = Object.keys(e.headers).find(i => i.toLowerCase() === "retry-after"); if (!t) return; let r = e.headers[t], o = Number(r); return Number.isNaN(o) ? new Date(r) : new Date(o * 1e3) } }); var kc = s(() => { Nce(); kce(); Mce(); vce(); $ce(); Pce(); Epe() }); function dpt(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "sso-oauth", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } function fpt(e) { return { schemeId: "smithy.api#noAuth" } } var ype, Spe, _pe, mB = s(() => { Ye(); gt(); ype = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }); Spe = e => { let t = []; switch (e.operation) { case "CreateToken": { t.push(fpt(e)); break } default: t.push(dpt(e)) }return t }, _pe = e => { let t = qr(e); return Object.assign(t, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var Cpe, Rpe, lB = s(() => { Cpe = e => Object.assign(e, { useDualstackEndpoint: e.useDualstackEndpoint ?? !1, useFipsEndpoint: e.useFipsEndpoint ?? !1, defaultSigningName: "sso-oauth" }), Rpe = { UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" } } }); var fm, R_ = s(() => { fm = { name: "@aws-sdk/nested-clients", version: "3.958.0", description: "Nested clients for AWS SDK packages.", main: "./dist-cjs/index.js", module: "./dist-es/index.js", types: "./dist-types/index.d.ts", scripts: { build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'", "build:cjs": "node ../../scripts/compilation/inline nested-clients", "build:es": "tsc -p tsconfig.es.json", "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"', "build:types": "tsc -p tsconfig.types.json", "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4", clean: "rimraf ./dist-* && rimraf *.tsbuildinfo", lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients", test: "yarn g:vitest run", "test:watch": "yarn g:vitest watch" }, engines: { node: ">=18.0.0" }, sideEffects: !1, author: { name: "AWS SDK for JavaScript Team", url: "https://aws.amazon.com/javascript/" }, license: "Apache-2.0", dependencies: { "@aws-crypto/sha256-browser": "5.2.0", "@aws-crypto/sha256-js": "5.2.0", "@aws-sdk/core": "3.957.0", "@aws-sdk/middleware-host-header": "3.957.0", "@aws-sdk/middleware-logger": "3.957.0", "@aws-sdk/middleware-recursion-detection": "3.957.0", "@aws-sdk/middleware-user-agent": "3.957.0", "@aws-sdk/region-config-resolver": "3.957.0", "@aws-sdk/types": "3.957.0", "@aws-sdk/util-endpoints": "3.957.0", "@aws-sdk/util-user-agent-browser": "3.957.0", "@aws-sdk/util-user-agent-node": "3.957.0", "@smithy/config-resolver": "^4.4.5", "@smithy/core": "^3.20.0", "@smithy/fetch-http-handler": "^5.3.8", "@smithy/hash-node": "^4.2.7", "@smithy/invalid-dependency": "^4.2.7", "@smithy/middleware-content-length": "^4.2.7", "@smithy/middleware-endpoint": "^4.4.1", "@smithy/middleware-retry": "^4.4.17", "@smithy/middleware-serde": "^4.2.8", "@smithy/middleware-stack": "^4.2.7", "@smithy/node-config-provider": "^4.3.7", "@smithy/node-http-handler": "^4.4.7", "@smithy/protocol-http": "^5.3.7", "@smithy/smithy-client": "^4.10.2", "@smithy/types": "^4.11.0", "@smithy/url-parser": "^4.2.7", "@smithy/util-base64": "^4.3.0", "@smithy/util-body-length-browser": "^4.2.0", "@smithy/util-body-length-node": "^4.2.1", "@smithy/util-defaults-mode-browser": "^4.3.16", "@smithy/util-defaults-mode-node": "^4.2.19", "@smithy/util-endpoints": "^3.2.7", "@smithy/util-middleware": "^4.2.7", "@smithy/util-retry": "^4.2.7", "@smithy/util-utf8": "^4.2.0", tslib: "^2.6.2" }, devDependencies: { concurrently: "7.0.0", "downlevel-dts": "0.10.1", rimraf: "3.0.2", typescript: "~5.8.3" }, typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } }, files: ["./signin.d.ts", "./signin.js", "./sso-oidc.d.ts", "./sso-oidc.js", "./sts.d.ts", "./sts.js", "dist-*/**"], browser: { "./dist-es/submodules/signin/runtimeConfig": "./dist-es/submodules/signin/runtimeConfig.browser", "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser", "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser" }, "react-native": {}, homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients", repository: { type: "git", url: "https://github.com/aws/aws-sdk-js-v3.git", directory: "packages/nested-clients" }, exports: { "./package.json": "./package.json", "./sso-oidc": { types: "./dist-types/submodules/sso-oidc/index.d.ts", module: "./dist-es/submodules/sso-oidc/index.js", node: "./dist-cjs/submodules/sso-oidc/index.js", import: "./dist-es/submodules/sso-oidc/index.js", require: "./dist-cjs/submodules/sso-oidc/index.js" }, "./sts": { types: "./dist-types/submodules/sts/index.d.ts", module: "./dist-es/submodules/sts/index.js", node: "./dist-cjs/submodules/sts/index.js", import: "./dist-es/submodules/sts/index.js", require: "./dist-cjs/submodules/sts/index.js" }, "./signin": { types: "./dist-types/submodules/signin/index.d.ts", module: "./dist-es/submodules/signin/index.js", node: "./dist-cjs/submodules/signin/index.js", import: "./dist-es/submodules/signin/index.js", require: "./dist-cjs/submodules/signin/index.js" } } } }); var Ape, Tpe = s(() => { Ape = { isCrtAvailable: !1 } }); var wpe, bpe = s(() => { Tpe(); wpe = () => Ape.isCrtAvailable ? ["md/crt-avail"] : null }); import { platform as gpt, release as xpt } from "os"; import { env as Ipe, versions as Ept } from "process"; var hm, vpe = s(() => { bpe(); hm = ({ serviceId: e, clientVersion: t }) => async r => { let o = [["aws-sdk-js", t], ["ua", "2.1"], [`os/${gpt()}`, xpt()], ["lang/js"], ["md/nodejs", `${Ept.node}`]], n = wpe(); n && o.push(n), e && o.push([`api/${e}`, t]), Ipe.AWS_EXECUTION_ENV && o.push([`exec-env/${Ipe.AWS_EXECUTION_ENV}`]); let i = await r?.userAgentAppId?.(); return i ? [...o, [`app/${i}`]] : [...o] } }); var ypt, Spt, _pt, gm, Ppe = s(() => { lh(); ypt = "AWS_SDK_UA_APP_ID", Spt = "sdk_ua_app_id", _pt = "sdk-ua-app-id", gm = { environmentVariableSelector: e => e[ypt], configFileSelector: e => e[Spt] ?? e[_pt], default: HN } }); var A_ = s(() => { vpe(); Ppe() }); import { Buffer as dB } from "buffer"; var fB, Ope, Dpe = s(() => { cr(); fB = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return dB.from(e, t, r) }, Ope = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? dB.from(e, t) : dB.from(e) } }); import { Buffer as hB } from "buffer"; var kpe, Npe, gB = s(() => { cr(); kpe = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return hB.from(e, t, r) }, Npe = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? hB.from(e, t) : hB.from(e) } }); var Us, xB = s(() => { gB(); Us = e => { let t = Npe(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var Bpe, Lpe = s(() => { xB(); Bpe = e => typeof e == "string" ? Us(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) }); var xm, Mpe = s(() => { gB(); xm = e => { if (typeof e == "string") return e; if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number") throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."); return kpe(e.buffer, e.byteOffset, e.byteLength).toString("utf8") } }); var Em = s(() => { xB(); Lpe(); Mpe() }); import { Buffer as Cpt } from "buffer"; import { createHash as Rpt, createHmac as Apt } from "crypto"; function $pe(e, t) { return Cpt.isBuffer(e) ? e : typeof e == "string" ? Ope(e, t) : ArrayBuffer.isView(e) ? fB(e.buffer, e.byteOffset, e.byteLength) : fB(e) } var Ta, T_ = s(() => { Dpe(); Em(); Ta = class { algorithmIdentifier; secret; hash; constructor(t, r) { this.algorithmIdentifier = t, this.secret = r, this.reset() } update(t, r) { this.hash.update(Bpe($pe(t, r))) } digest() { return Promise.resolve(this.hash.digest()) } reset() { this.hash = this.secret ? Apt(this.algorithmIdentifier, $pe(this.secret)) : Rpt(this.algorithmIdentifier) } } }); var w_, Tpt, Fpe = s(() => { w_ = e => encodeURIComponent(e).replace(/[!'()*]/g, Tpt), Tpt = e => `%${e.charCodeAt(0).toString(16).toUpperCase()}` }); var Upe = s(() => { }); var Hpe = s(() => { Fpe(); Upe() }); function Gpe(e) { let t = []; for (let r of Object.keys(e).sort()) { let o = e[r]; if (r = w_(r), Array.isArray(o)) for (let n = 0, i = o.length; n < i; n++)t.push(`${r}=${w_(o[n])}`); else { let n = r; (o || typeof o == "string") && (n += `=${w_(o)}`), t.push(n) } } return t.join("&") } var jpe = s(() => { Hpe() }); var qpe, Vpe = s(() => { qpe = ["ECONNRESET", "EPIPE", "ETIMEDOUT"] }); var zpe, Wpe = s(() => { zpe = e => { let t = {}; for (let r of Object.keys(e)) { let o = e[r]; t[r] = Array.isArray(o) ? o.join(",") : o } return t } }); var mr, Nc = s(() => { mr = { setTimeout: (e, t) => setTimeout(e, t), clearTimeout: e => clearTimeout(e) } }); var Kpe, Qpe, Ype = s(() => { Nc(); Kpe = 1e3, Qpe = (e, t, r = 0) => { if (!r) return -1; let o = n => { let i = mr.setTimeout(() => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${r} ms.`), { name: "TimeoutError" })) }, r - n), a = c => { c?.connecting ? c.on("connect", () => { mr.clearTimeout(i) }) : mr.clearTimeout(i) }; e.socket ? a(e.socket) : e.on("socket", a) }; return r < 2e3 ? (o(0), 0) : mr.setTimeout(o.bind(null, Kpe), Kpe) } }); var Xpe, Jpe = s(() => { Nc(); Xpe = (e, t, r = 0, o, n) => r ? mr.setTimeout(() => { let i = `@smithy/node-http-handler - [${o ? "ERROR" : "WARN"}] a request has exceeded the configured ${r} ms requestTimeout.`; if (o) { let a = Object.assign(new Error(i), { name: "TimeoutError", code: "ETIMEDOUT" }); e.destroy(a), t(a) } else i += " Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.", n?.warn?.(i) }, r) : -1 }); var wpt, Zpe, eue = s(() => { Nc(); wpt = 3e3, Zpe = (e, { keepAlive: t, keepAliveMsecs: r }, o = wpt) => { if (t !== !0) return -1; let n = () => { e.socket ? e.socket.setKeepAlive(t, r || 0) : e.on("socket", i => { i.setKeepAlive(t, r || 0) }) }; return o === 0 ? (n(), 0) : mr.setTimeout(n, o) } }); var tue, rue, oue = s(() => { Nc(); tue = 3e3, rue = (e, t, r = 0) => { let o = n => { let i = r - n, a = () => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${r} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" })) }; e.socket ? (e.socket.setTimeout(i, a), e.on("close", () => e.socket?.removeListener("timeout", a))) : e.setTimeout(i, a) }; return 0 < r && r < 6e3 ? (o(0), 0) : mr.setTimeout(o.bind(null, r === 0 ? 0 : tue), tue) } }); import { Readable as bpt } from "stream"; async function sue(e, t, r = nue, o = !1) { let n = t.headers ?? {}, i = n.Expect || n.expect, a = -1, c = !0; !o && i === "100-continue" && (c = await Promise.race([new Promise(p => { a = Number(mr.setTimeout(() => p(!0), Math.max(nue, r))) }), new Promise(p => { e.on("continue", () => { mr.clearTimeout(a), p(!0) }), e.on("response", () => { mr.clearTimeout(a), p(!1) }), e.on("error", () => { mr.clearTimeout(a), p(!1) }) })])), c && Ipt(e, t.body) } function Ipt(e, t) { if (t instanceof bpt) { t.pipe(e); return } if (t) { if (Buffer.isBuffer(t) || typeof t == "string") { e.end(t); return } let r = t; if (typeof r == "object" && r.buffer && typeof r.byteOffset == "number" && typeof r.byteLength == "number") { e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength)); return } e.end(Buffer.from(t)); return } e.end() } var nue, iue = s(() => { Nc(); nue = 6e3 }); import { Agent as EB, request as vpt } from "http"; import { Agent as yB, request as Ppt } from "https"; var wa, aue = s(() => {
  Ms(); jpe(); Vpe(); Wpe(); Ype(); Jpe(); eue(); oue(); Nc(); iue(); wa = class e {
    config; configProvider; socketWarningTimestamp = 0; externalAgent = !1; metadata = { handlerProtocol: "http/1.1" }; static create(t) { return typeof t?.handle == "function" ? t : new e(t) } static checkSocketUsage(t, r, o = console) {
      let { sockets: n, requests: i, maxSockets: a } = t; if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r) return r; if (n && i) for (let p in n) {
        let u = n[p]?.length ?? 0, l = i[p]?.length ?? 0; if (u >= a && l >= 2 * a) return o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${u} and ${l} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`), Date.now()
      } return r
    } constructor(t) { this.configProvider = new Promise((r, o) => { typeof t == "function" ? t().then(n => { r(this.resolveDefaultConfig(n)) }).catch(o) : r(this.resolveDefaultConfig(t)) }) } resolveDefaultConfig(t) { let { requestTimeout: r, connectionTimeout: o, socketTimeout: n, socketAcquisitionWarningTimeout: i, httpAgent: a, httpsAgent: c, throwOnRequestTimeout: p } = t || {}, u = !0, l = 50; return { connectionTimeout: o, requestTimeout: r, socketTimeout: n, socketAcquisitionWarningTimeout: i, throwOnRequestTimeout: p, httpAgent: a instanceof EB || typeof a?.destroy == "function" ? (this.externalAgent = !0, a) : new EB({ keepAlive: u, maxSockets: l, ...a }), httpsAgent: c instanceof yB || typeof c?.destroy == "function" ? (this.externalAgent = !0, c) : new yB({ keepAlive: u, maxSockets: l, ...c }), logger: console } } destroy() { this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy() } async handle(t, { abortSignal: r, requestTimeout: o } = {}) { return this.config || (this.config = await this.configProvider), new Promise((n, i) => { let a = this.config, c, p = [], u = async O => { await c, p.forEach(mr.clearTimeout), n(O) }, l = async O => { await c, p.forEach(mr.clearTimeout), i(O) }; if (r?.aborted) { let O = new Error("Request aborted"); O.name = "AbortError", l(O); return } let m = t.protocol === "https:", f = t.headers ?? {}, h = (f.Expect ?? f.expect) === "100-continue", E = m ? a.httpsAgent : a.httpAgent; h && !this.externalAgent && (E = new (m ? yB : EB)({ keepAlive: !1, maxSockets: 1 / 0 })), p.push(mr.setTimeout(() => { this.socketWarningTimestamp = e.checkSocketUsage(E, this.socketWarningTimestamp, a.logger) }, a.socketAcquisitionWarningTimeout ?? (a.requestTimeout ?? 2e3) + (a.connectionTimeout ?? 1e3))); let S = Gpe(t.query || {}), y; if (t.username != null || t.password != null) { let O = t.username ?? "", ie = t.password ?? ""; y = `${O}:${ie}` } let C = t.path; S && (C += `?${S}`), t.fragment && (C += `#${t.fragment}`); let b = t.hostname ?? ""; b[0] === "[" && b.endsWith("]") ? b = t.hostname.slice(1, -1) : b = t.hostname; let L = { headers: t.headers, host: b, method: t.method, path: C, port: t.port, agent: E, auth: y }, j = (m ? Ppt : vpt)(L, O => { let ie = new Hu({ statusCode: O.statusCode || -1, reason: O.statusMessage, headers: zpe(O.headers), body: O }); u({ response: ie }) }); if (j.on("error", O => { qpe.includes(O.code) ? l(Object.assign(O, { name: "TimeoutError" })) : l(O) }), r) { let O = () => { j.destroy(); let ie = new Error("Request aborted"); ie.name = "AbortError", l(ie) }; if (typeof r.addEventListener == "function") { let ie = r; ie.addEventListener("abort", O, { once: !0 }), j.once("close", () => ie.removeEventListener("abort", O)) } else r.onabort = O } let re = o ?? a.requestTimeout; p.push(Qpe(j, l, a.connectionTimeout)), p.push(Xpe(j, l, re, a.throwOnRequestTimeout, a.logger ?? console)), p.push(rue(j, l, a.socketTimeout)); let Ce = L.agent; typeof Ce == "object" && "keepAlive" in Ce && p.push(Zpe(j, { keepAlive: Ce.keepAlive, keepAliveMsecs: Ce.keepAliveMsecs })), c = sue(j, t, re, this.externalAgent).catch(O => (p.forEach(mr.clearTimeout), i(O))) }) } updateHttpClientConfig(t, r) { this.config = void 0, this.configProvider = this.configProvider.then(o => ({ ...o, [t]: r })) } httpHandlerConfigs() { return this.config ?? {} }
  }
}); var cue = s(() => { }); import { Writable as Opt } from "stream"; var b_, pue = s(() => { b_ = class extends Opt { bufferedBytes = []; _write(t, r, o) { this.bufferedBytes.push(t), o() } } }); async function kpt(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } var ym, Dpt, uue = s(() => { pue(); ym = e => Dpt(e) ? kpt(e) : new Promise((t, r) => { let o = new b_; e.pipe(o), e.on("error", n => { o.end(), r(n) }), o.on("error", r), o.on("finish", function () { let n = new Uint8Array(Buffer.concat(this.bufferedBytes)); t(n) }) }), Dpt = e => typeof ReadableStream == "function" && e instanceof ReadableStream }); var I_ = s(() => { aue(); cue(); uue() }); import { fstatSync as Npt, lstatSync as Bpt, ReadStream as Lpt } from "node:fs"; var Sm, mue = s(() => { Sm = e => { if (!e) return 0; if (typeof e == "string") return Buffer.byteLength(e); if (typeof e.byteLength == "number") return e.byteLength; if (typeof e.size == "number") return e.size; if (typeof e.start == "number" && typeof e.end == "number") return e.end + 1 - e.start; if (e instanceof Lpt) { if (e.path != null) return Bpt(e.path).size; if (typeof e.fd == "number") return Npt(e.fd).size } throw new Error(`Body Length computation failed for ${e}`) } }); var v_ = s(() => { mue() }); var lue, SB, _B, due, fue, hue, gue = s(() => { lue = "AWS_EXECUTION_ENV", SB = "AWS_REGION", _B = "AWS_DEFAULT_REGION", due = "AWS_EC2_METADATA_DISABLED", fue = ["in-region", "cross-region", "mobile", "standard", "legacy"], hue = "/latest/meta-data/placement/region" }); var Mpt, $pt, xue, Eue = s(() => { Mpt = "AWS_DEFAULTS_MODE", $pt = "defaults_mode", xue = { environmentVariableSelector: e => e[Mpt], configFileSelector: e => e[$pt], default: "legacy" } }); import { Buffer as Fpt } from "buffer"; import { request as Upt } from "http"; function ba(e) { return new Promise((t, r) => { let o = Upt({ method: "GET", ...e, hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1") }); o.on("error", n => { r(Object.assign(new kt("Unable to connect to instance metadata service"), n)), o.destroy() }), o.on("timeout", () => { r(new kt("TimeoutError from instance metadata service")), o.destroy() }), o.on("response", n => { let { statusCode: i = 400 } = n; (i < 200 || 300 <= i) && (r(Object.assign(new kt("Error response received from instance metadata service"), { statusCode: i })), o.destroy()); let a = []; n.on("data", c => { a.push(c) }), n.on("end", () => { t(Fpt.concat(a)), o.destroy() }) }), o.end() }) } var P_ = s(() => { Z() }); var O_, D_, CB = s(() => { O_ = e => !!e && typeof e == "object" && typeof e.AccessKeyId == "string" && typeof e.SecretAccessKey == "string" && typeof e.Token == "string" && typeof e.Expiration == "string", D_ = e => ({ accessKeyId: e.AccessKeyId, secretAccessKey: e.SecretAccessKey, sessionToken: e.Token, expiration: new Date(e.Expiration), ...e.AccountId && { accountId: e.AccountId } }) }); var TRr, wRr, fh, k_ = s(() => { TRr = 1e3, wRr = 0, fh = ({ maxRetries: e = 0, timeout: t = 1e3 }) => ({ maxRetries: e, timeout: t }) }); var hh, RB = s(() => { hh = (e, t) => { let r = e(); for (let o = 0; o < t; o++)r = r.catch(e); return r } }); import { parse as Hpt } from "url"; var N_, B_, AB, Gpt, jpt, qpt, Vpt, zpt, Wpt, yue = s(() => { Z(); P_(); CB(); k_(); RB(); N_ = "AWS_CONTAINER_CREDENTIALS_FULL_URI", B_ = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", AB = "AWS_CONTAINER_AUTHORIZATION_TOKEN", Gpt = (e = {}) => { let { timeout: t, maxRetries: r } = fh(e); return () => hh(async () => { let o = await Wpt({ logger: e.logger }), n = JSON.parse(await jpt(t, o)); if (!O_(n)) throw new I("Invalid response received from instance metadata service.", { logger: e.logger }); return D_(n) }, r) }, jpt = async (e, t) => (process.env[AB] && (t.headers = { ...t.headers, Authorization: process.env[AB] }), (await ba({ ...t, timeout: e })).toString()), qpt = "169.254.170.2", Vpt = { localhost: !0, "127.0.0.1": !0 }, zpt = { "http:": !0, "https:": !0 }, Wpt = async ({ logger: e }) => { if (process.env[B_]) return { hostname: qpt, path: process.env[B_] }; if (process.env[N_]) { let t = Hpt(process.env[N_]); if (!t.hostname || !(t.hostname in Vpt)) throw new I(`${t.hostname} is not a valid container metadata service hostname`, { tryNextLink: !1, logger: e }); if (!t.protocol || !(t.protocol in zpt)) throw new I(`${t.protocol} is not a valid container metadata service protocol`, { tryNextLink: !1, logger: e }); return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 } } throw new I(`The container metadata credential provider cannot be used unless the ${B_} or ${N_} environment variable is set`, { tryNextLink: !1, logger: e }) } }); var L_, Sue = s(() => { Z(); L_ = class e extends I { tryNextLink; name = "InstanceMetadataV1FallbackError"; constructor(t, r = !0) { super(t, r), this.tryNextLink = r, Object.setPrototypeOf(this, e.prototype) } } }); var Bc, TB = s(() => { (function (e) { e.IPv4 = "http://169.254.169.254", e.IPv6 = "http://[fd00:ec2::254]" })(Bc || (Bc = {})) }); var Kpt, Qpt, _ue, Cue = s(() => { Kpt = "AWS_EC2_METADATA_SERVICE_ENDPOINT", Qpt = "ec2_metadata_service_endpoint", _ue = { environmentVariableSelector: e => e[Kpt], configFileSelector: e => e[Qpt], default: void 0 } }); var Ia, wB = s(() => { (function (e) { e.IPv4 = "IPv4", e.IPv6 = "IPv6" })(Ia || (Ia = {})) }); var Ypt, Xpt, Rue, Aue = s(() => { wB(); Ypt = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE", Xpt = "ec2_metadata_service_endpoint_mode", Rue = { environmentVariableSelector: e => e[Ypt], configFileSelector: e => e[Xpt], default: Ia.IPv4 } }); var M_, Jpt, Zpt, bB = s(() => { ya(); zu(); TB(); Cue(); wB(); Aue(); M_ = async () => Tn(await Jpt() || await Zpt()), Jpt = async () => tt(_ue)(), Zpt = async () => { let e = await tt(Rue)(); switch (e) { case Ia.IPv4: return Bc.IPv4; case Ia.IPv6: return Bc.IPv6; default: throw new Error(`Unsupported endpoint mode: ${e}. Select from ${Object.values(Ia)}`) } } }); var eut, IB, Tue = s(() => {
  eut = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html", IB = (e, t) => {
    let r = 300 + Math.floor(Math.random() * 300), o = new Date(Date.now() + r * 1e3); t.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: `+ eut); let n = e.originalExpiration ?? e.expiration; return { ...e, ...n ? { originalExpiration: n } : {}, expiration: o }
  }
}); var wue, bue = s(() => { Tue(); wue = (e, t = {}) => { let r = t?.logger || console, o; return async () => { let n; try { n = await e(), n.expiration && n.expiration.getTime() < Date.now() && (n = IB(n, r)) } catch (i) { if (o) r.warn("Credential renew failed: ", i), n = IB(o, r); else throw i } return o = n, n } } }); var Pue, tut, vB, Iue, vue, rut, out, nut, sut, iut, Oue = s(() => { ya(); Z(); Sue(); P_(); CB(); k_(); RB(); bB(); bue(); Pue = "/latest/meta-data/iam/security-credentials/", tut = "/latest/api/token", vB = "AWS_EC2_METADATA_V1_DISABLED", Iue = "ec2_metadata_v1_disabled", vue = "x-aws-ec2-metadata-token", rut = (e = {}) => wue(out(e), { logger: e.logger }), out = (e = {}) => { let t = !1, { logger: r, profile: o } = e, { timeout: n, maxRetries: i } = fh(e), a = async (c, p) => { if (t || p.headers?.[vue] == null) { let m = !1, f = !1, h = await tt({ environmentVariableSelector: E => { let S = E[vB]; if (f = !!S && S !== "false", S === void 0) throw new I(`${vB} not set in env, checking config file next.`, { logger: e.logger }); return f }, configFileSelector: E => { let S = E[Iue]; return m = !!S && S !== "false", m }, default: !1 }, { profile: o })(); if (e.ec2MetadataV1Disabled || h) { let E = []; throw e.ec2MetadataV1Disabled && E.push("credential provider initialization (runtime option ec2MetadataV1Disabled)"), m && E.push(`config file profile (${Iue})`), f && E.push(`process environment variable (${vB})`), new L_(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${E.join(", ")}].`) } } let l = (await hh(async () => { let m; try { m = await sut(p) } catch (f) { throw f.statusCode === 401 && (t = !1), f } return m }, c)).trim(); return hh(async () => { let m; try { m = await iut(l, p, e) } catch (f) { throw f.statusCode === 401 && (t = !1), f } return m }, c) }; return async () => { let c = await M_(); if (t) return r?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)"), a(i, { ...c, timeout: n }); { let p; try { p = (await nut({ ...c, timeout: n })).toString() } catch (u) { if (u?.statusCode === 400) throw Object.assign(u, { message: "EC2 Metadata token request returned error" }); return (u.message === "TimeoutError" || [403, 404, 405].includes(u.statusCode)) && (t = !0), r?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)"), a(i, { ...c, timeout: n }) } return a(i, { ...c, headers: { [vue]: p }, timeout: n }) } } }, nut = async e => ba({ ...e, path: tut, method: "PUT", headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" } }), sut = async e => (await ba({ ...e, path: Pue })).toString(), iut = async (e, t, r) => { let o = JSON.parse((await ba({ ...t, path: Pue + e })).toString()); if (!O_(o)) throw new I("Invalid response received from instance metadata service.", { logger: r.logger }); return D_(o) } }); var Due = s(() => { }); var kue = {}; Qe(kue, { DEFAULT_MAX_RETRIES: () => wRr, DEFAULT_TIMEOUT: () => TRr, ENV_CMDS_AUTH_TOKEN: () => AB, ENV_CMDS_FULL_URI: () => N_, ENV_CMDS_RELATIVE_URI: () => B_, Endpoint: () => Bc, fromContainerMetadata: () => Gpt, fromInstanceMetadata: () => rut, getInstanceMetadataEndpoint: () => M_, httpRequest: () => ba, providerConfigFromInit: () => fh }); var Nue = s(() => { yue(); Oue(); k_(); Due(); P_(); bB(); TB() }); var _m, aut, cut, Bue = s(() => { Ea(); ya(); Z(); gue(); Eue(); _m = ({ region: e = tt(xa), defaultsMode: t = tt(xue) } = {}) => jr(async () => { let r = typeof t == "function" ? await t() : t; switch (r?.toLowerCase()) { case "auto": return aut(e); case "in-region": case "cross-region": case "mobile": case "standard": case "legacy": return Promise.resolve(r?.toLocaleLowerCase()); case void 0: return Promise.resolve("legacy"); default: throw new Error(`Invalid parameter for "defaultsMode", expect ${fue.join(", ")}, got ${r}`) } }), aut = async e => { if (e) { let t = typeof e == "function" ? await e() : e, r = await cut(); return r ? t === r ? "in-region" : "cross-region" : "standard" } return "standard" }, cut = async () => { if (process.env[lue] && (process.env[SB] || process.env[_B])) return process.env[SB] ?? process.env[_B]; if (!process.env[due]) try { let { getInstanceMetadataEndpoint: e, httpRequest: t } = await Promise.resolve().then(() => (Nue(), kue)), r = await e(); return (await t({ ...r, path: hue })).toString() } catch { } } }); var $_ = s(() => { Bue() }); import { Buffer as PB } from "buffer"; var Lue, Mue, OB = s(() => { cr(); Lue = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return PB.from(e, t, r) }, Mue = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? PB.from(e, t) : PB.from(e) } }); var put, Cm, $ue = s(() => { OB(); put = /^[A-Za-z0-9+/]*={0,2}$/, Cm = e => { if (e.length * 3 % 4 !== 0) throw new TypeError("Incorrect padding on base64 string."); if (!put.exec(e)) throw new TypeError("Invalid base64 string."); let t = Mue(e, "base64"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength) } }); var Rm, Fue = s(() => { OB(); Em(); Rm = e => { let t; if (typeof e == "string" ? t = Us(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return Lue(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var F_ = s(() => { $ue(); Fue() }); var Que, bn, In, wm, Uue, gh, Am, Tm, wi, DB, kB, Hue, Gue, jue, Yue, Xue, wn, que, Jue, Vue, zue, Wue, Kue, uut, Zue, eme = s(() => { Que = "required", bn = "fn", In = "argv", wm = "ref", Uue = "isSet", gh = "booleanEquals", Am = "error", Tm = "endpoint", wi = "tree", DB = "PartitionResult", kB = "getAttr", Hue = { [Que]: !1, type: "string" }, Gue = { [Que]: !0, default: !1, type: "boolean" }, jue = { [wm]: "Endpoint" }, Yue = { [bn]: gh, [In]: [{ [wm]: "UseFIPS" }, !0] }, Xue = { [bn]: gh, [In]: [{ [wm]: "UseDualStack" }, !0] }, wn = {}, que = { [bn]: kB, [In]: [{ [wm]: DB }, "supportsFIPS"] }, Jue = { [wm]: DB }, Vue = { [bn]: gh, [In]: [!0, { [bn]: kB, [In]: [Jue, "supportsDualStack"] }] }, zue = [Yue], Wue = [Xue], Kue = [{ [wm]: "Region" }], uut = { version: "1.0", parameters: { Region: Hue, UseDualStack: Gue, UseFIPS: Gue, Endpoint: Hue }, rules: [{ conditions: [{ [bn]: Uue, [In]: [jue] }], rules: [{ conditions: zue, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: Am }, { conditions: Wue, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: Am }, { endpoint: { url: jue, properties: wn, headers: wn }, type: Tm }], type: wi }, { conditions: [{ [bn]: Uue, [In]: Kue }], rules: [{ conditions: [{ [bn]: "aws.partition", [In]: Kue, assign: DB }], rules: [{ conditions: [Yue, Xue], rules: [{ conditions: [{ [bn]: gh, [In]: [!0, que] }, Vue], rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: wn, headers: wn }, type: Tm }], type: wi }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: Am }], type: wi }, { conditions: zue, rules: [{ conditions: [{ [bn]: gh, [In]: [que, !0] }], rules: [{ conditions: [{ [bn]: "stringEquals", [In]: [{ [bn]: kB, [In]: [Jue, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: wn, headers: wn }, type: Tm }, { endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: wn, headers: wn }, type: Tm }], type: wi }, { error: "FIPS is enabled but this partition does not support FIPS", type: Am }], type: wi }, { conditions: Wue, rules: [{ conditions: [Vue], rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: wn, headers: wn }, type: Tm }], type: wi }, { error: "DualStack is enabled but this partition does not support DualStack", type: Am }], type: wi }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: wn, headers: wn }, type: Tm }], type: wi }], type: wi }, { error: "Invalid Configuration: Missing Region", type: Am }] }, Zue = uut }); var mut, tme, rme = s(() => { mh(); Ft(); eme(); mut = new Rr({ size: 50, params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"] }), tme = (e, t = {}) => mut.get(e, () => Ur(Zue, { endpointParams: e, logger: t.logger })); Rt.aws = Oc }); var ome, nme = s(() => { Ye(); yn(); Ie(); Xt(); zu(); F_(); Em(); mB(); rme(); ome = e => ({ apiVersion: "2019-06-10", base64Decoder: e?.base64Decoder ?? Cm, base64Encoder: e?.base64Encoder ?? Rm, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? tme, extensions: e?.extensions ?? [], httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? Spe, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }, { schemeId: "smithy.api#noAuth", identityProvider: t => t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})), signer: new po }], logger: e?.logger ?? new Fs, protocol: e?.protocol ?? En, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.ssooidc", version: "2019-06-10", serviceTarget: "AWSSSOOIDCService" }, serviceId: e?.serviceId ?? "SSO OIDC", urlParser: e?.urlParser ?? Tn, utf8Decoder: e?.utf8Decoder ?? Us, utf8Encoder: e?.utf8Encoder ?? xm }) }); var sme, ime = s(() => { R_(); Ye(); A_(); Ea(); T_(); kc(); ya(); I_(); Xt(); v_(); $_(); om(); nme(); sme = e => { um(process.version); let t = _m(e), r = () => t().then(pm), o = ome(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, authSchemePreference: e?.authSchemePreference ?? tt(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? Sm, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? hm({ serviceId: o.serviceId, clientVersion: fm.version }), maxAttempts: e?.maxAttempts ?? tt(nm, e), region: e?.region ?? tt(xa, { ...Yu, ...n }), requestHandler: wa.create(e?.requestHandler ?? r), retryMode: e?.retryMode ?? tt({ ...im, default: async () => (await r()).retryMode || Ca }, e), sha256: e?.sha256 ?? Ta.bind(null, "sha256"), streamCollector: e?.streamCollector ?? ym, useDualstackEndpoint: e?.useDualstackEndpoint ?? tt(Ku, n), useFipsEndpoint: e?.useFipsEndpoint ?? tt(Qu, n), userAgentAppId: e?.userAgentAppId ?? tt(gm, n) } } }); var Vr, zr, ame = s(() => { Vr = e => ({ setRegion(t) { e.region = t }, region() { return e.region } }), zr = e => ({ region: e.region() }) }); var cme = s(() => { }); var pme = s(() => { }); var ume = s(() => { }); var mme = s(() => { }); var lme = s(() => { cme(); pme(); ume(); mme() }); var lut, dut, dme, fme, hme = s(() => { lut = "AWS_REGION", dut = "region", dme = { environmentVariableSelector: e => e[lut], configFileSelector: e => e[dut], default: () => { throw new Error("Region is missing") } }, fme = { preferredFile: "credentials" } }); var gme = s(() => { }); var xme = s(() => { hme(); gme() }); var Eme = s(() => { }); var yme = s(() => { }); var Sme = s(() => { }); var _me = s(() => { Eme(); yme(); Sme() }); var Cme = s(() => { lme(); xme(); _me() }); var Rme = s(() => { }); function U_(e) { try { let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? [])); return t.delete("CONFIG"), t.delete("CONFIG_PREFIX_SEPARATOR"), t.delete("ENV"), [...t].join(", ") } catch { return e } } var NB = s(() => { }); var Ame, Tme = s(() => { Z(); NB(); Ame = (e, t) => async () => { try { let r = e(process.env, t); if (r === void 0) throw new Error; return r } catch (r) { throw new I(r.message || `Not found in ENV: ${U_(e.toString())}`, { logger: t?.logger }) } } }); import { homedir as fut } from "os"; import { sep as hut } from "path"; var BB, gut, bm, xh = s(() => { BB = {}, gut = () => process && process.geteuid ? `${process.geteuid()}` : "DEFAULT", bm = () => { let { HOME: e, USERPROFILE: t, HOMEPATH: r, HOMEDRIVE: o = `C:${hut}` } = process.env; if (e) return e; if (t) return t; if (r) return `${o}${r}`; let n = gut(); return BB[n] || (BB[n] = fut()), BB[n] } }); var xut, Eut, wme, bme = s(() => { xut = "AWS_PROFILE", Eut = "default", wme = e => e.profile || process.env[xut] || Eut }); var Ime = s(() => { }); var vme = s(() => { }); var Pme, Ome = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Pme || (Pme = {})) }); var Dme, kme = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Dme || (Dme = {})) }); var Nme = s(() => { }); var Bme = s(() => { }); var Lme = s(() => { }); var Mme = s(() => { }); var $me = s(() => { Ome(); kme(); Nme(); Bme(); Lme(); Mme() }); var Fme = s(() => { }); var Ume = s(() => { }); var Hme = s(() => { }); var Gme = s(() => { }); var jme = s(() => { }); var qme = s(() => { }); var Vme = s(() => { }); var zme = s(() => { jme(); qme(); Vme() }); var Wme = s(() => { }); var Kme = s(() => { }); var Qme, Yme = s(() => { (function (e) { e.HTTP = "http", e.HTTPS = "https" })(Qme || (Qme = {})) }); var Xme = s(() => { }); var Jme = s(() => { }); var Zme = s(() => { }); var ele = s(() => { }); var tle = s(() => { }); var rle = s(() => { Xme(); Jme(); Zme(); ele(); tle() }); var ole = s(() => { }); var nle = s(() => { }); var sle = s(() => { }); var ile = s(() => { nle(); sle() }); var ale = s(() => { }); var cle, ple = s(() => { (function (e) { e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER" })(cle || (cle = {})) }); var ule = s(() => { }); var mle = s(() => { }); var lle = s(() => { }); var dle = s(() => { }); var fle = s(() => { }); var hle = s(() => { mle(); lle(); dle(); fle() }); var gle = s(() => { }); var xle = s(() => { }); var Ele = s(() => { }); var Lc, yle = s(() => { (function (e) { e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services" })(Lc || (Lc = {})) }); var Sle = s(() => { }); var _le = s(() => { }); var Cle = s(() => { }); var Rle = s(() => { }); var Ale = s(() => { }); var Tle = s(() => { }); var wle = s(() => { }); var ble = s(() => { }); var Ile = s(() => { }); var vle = s(() => { }); var Ple = s(() => { }); var Ole = s(() => { }); var Dle = s(() => { }); var kle = s(() => { }); var Nle, Ble = s(() => { (function (e) { e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0" })(Nle || (Nle = {})) }); var Lle = s(() => { }); var Mle = s(() => { }); var $le = s(() => { }); var Fle = s(() => { }); var Ule = s(() => { }); var Hle = s(() => { }); var Gle = s(() => { }); var LB = s(() => { vme(); $me(); Fme(); Ume(); Hme(); Gme(); zme(); Wme(); Kme(); Yme(); rle(); ole(); ile(); ale(); ple(); ule(); hle(); gle(); xle(); Ele(); yle(); Sle(); _le(); Cle(); Rle(); Ale(); Tle(); wle(); ble(); Ile(); vle(); Ple(); Ole(); Dle(); kle(); Ble(); Lle(); Mle(); $le(); Fle(); Ule(); Hle(); Gle() }); var Im, MB = s(() => { Im = "." }); var jle, qle = s(() => { LB(); MB(); jle = e => Object.entries(e).filter(([t]) => { let r = t.indexOf(Im); return r === -1 ? !1 : Object.values(Lc).includes(t.substring(0, r)) }).reduce((t, [r, o]) => { let n = r.indexOf(Im), i = r.substring(0, n) === Lc.PROFILE ? r.substring(n + 1) : r; return t[i] = o, t }, { ...e.default && { default: e.default } }) }); import { join as yut } from "path"; var Sut, Vle, zle = s(() => { xh(); Sut = "AWS_CONFIG_FILE", Vle = () => process.env[Sut] || yut(bm(), ".aws", "config") }); import { join as _ut } from "path"; var Cut, Wle, Kle = s(() => { xh(); Cut = "AWS_SHARED_CREDENTIALS_FILE", Wle = () => process.env[Cut] || _ut(bm(), ".aws", "credentials") }); var Rut, Aut, $B, Qle = s(() => { LB(); MB(); Rut = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/, Aut = ["__proto__", "profile __proto__"], $B = e => { let t = {}, r, o; for (let n of e.split(/\r?\n/)) { let i = n.split(/(^|\s)[;#]/)[0].trim(); if (i[0] === "[" && i[i.length - 1] === "]") { r = void 0, o = void 0; let c = i.substring(1, i.length - 1), p = Rut.exec(c); if (p) { let [, u, , l] = p; Object.values(Lc).includes(u) && (r = [u, l].join(Im)) } else r = c; if (Aut.includes(c)) throw new Error(`Found invalid profile name "${c}"`) } else if (r) { let c = i.indexOf("="); if (![0, -1].includes(c)) { let [p, u] = [i.substring(0, c).trim(), i.substring(c + 1).trim()]; if (u === "") o = p; else { o && n.trimStart() === n && (o = void 0), t[r] = t[r] || {}; let l = o ? [o, p].join(Im) : p; t[r][l] = u } } } } return t } }); import { readFile as Tut } from "node:fs/promises"; var FB, Yle, UB, Xle = s(() => { FB = {}, Yle = {}, UB = (e, t) => Yle[e] !== void 0 ? Yle[e] : ((!FB[e] || t?.ignoreCache) && (FB[e] = Tut(e, "utf8")), FB[e]) }); import { join as Jle } from "path"; var Zle, ede, tde = s(() => { qle(); zle(); Kle(); xh(); Qle(); Xle(); Zle = () => ({}), ede = async (e = {}) => { let { filepath: t = Wle(), configFilepath: r = Vle() } = e, o = bm(), n = "~/", i = t; t.startsWith(n) && (i = Jle(o, t.slice(2))); let a = r; r.startsWith(n) && (a = Jle(o, r.slice(2))); let c = await Promise.all([UB(a, { ignoreCache: e.ignoreCache }).then($B).then(jle).catch(Zle), UB(i, { ignoreCache: e.ignoreCache }).then($B).catch(Zle)]); return { configFile: c[0], credentialsFile: c[1] } } }); var rde = s(() => { }); var ode = s(() => { }); var nde = s(() => { }); var sde = s(() => { xh(); bme(); Ime(); tde(); rde(); ode(); nde() }); var ide, ade = s(() => { Z(); sde(); NB(); ide = (e, { preferredFile: t = "config", ...r } = {}) => async () => { let o = wme(r), { configFile: n, credentialsFile: i } = await ede(r), a = i[o] || {}, c = n[o] || {}, p = t === "config" ? { ...a, ...c } : { ...c, ...a }; try { let l = e(p, t === "config" ? n : i); if (l === void 0) throw new Error; return l } catch (u) { throw new I(u.message || `Not found in config files w/ profile [${o}]: ${U_(e.toString())}`, { logger: r.logger }) } } }); var wut, cde, pde = s(() => { Z(); wut = e => typeof e == "function", cde = e => wut(e) ? async () => await e() : Is(e) }); var ude, mde = s(() => { Z(); Tme(); ade(); pde(); ude = ({ environmentVariableSelector: e, configFileSelector: t, default: r }, o = {}) => { let { signingName: n, logger: i } = o; return jr(sr(Ame(e, { signingName: n, logger: i }), ide(t, o), cde(r))) } }); var lde = s(() => { mde() }); function dde(e = {}) { return ude({ ...dme, async default() { return but.silence || console.warn("@aws-sdk - WARN - default STS region of us-east-1 used. See @aws-sdk/credential-providers README and set a region explicitly."), "us-east-1" } }, { ...fme, ...e }) } var but, fde = s(() => { Cme(); lde(); but = { silence: !1 } }); var ps = s(() => { ame(); Rme(); fde() }); var hde, gde, xde = s(() => { hde = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, gde = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var Ede, yde = s(() => { ps(); Ms(); Xt(); xde(); Ede = (e, t) => { let r = Object.assign(Vr(e), mm(e), $u(e), hde(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), lm(r), Fu(r), gde(r)) } }); var Eh, HB = s(() => { n_(); s_(); i_(); lh(); Ea(); Ie(); Oe(); m_(); _a(); kc(); Xt(); mB(); lB(); ime(); yde(); Eh = class extends cs { config; constructor(...[t]) { let r = sme(t || {}); super(r), this.initConfig = r; let o = Cpe(r), n = Vu(o), i = sm(n), a = Xu(i), c = a, p = em(c), u = _pe(p), l = Ede(u, t?.extensions || []); this.config = l, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(Wu(this.config)), this.middlewareStack.use(dm(this.config)), this.middlewareStack.use(Ju(this.config)), this.middlewareStack.use(Gu(this.config)), this.middlewareStack.use(ju(this.config)), this.middlewareStack.use(qu(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: ype, identityProviderConfigProvider: async m => new Cr({ "aws.auth#sigv4": m.credentials }) })), this.middlewareStack.use($r(this.config)) } destroy() { super.destroy() } } }); var Wr, H_ = s(() => { Xt(); Wr = class e extends Aa { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var yh, Sh, _h, Ch, Rh, Ah, Th, wh, bh, Ih, vh, GB = s(() => { H_(); yh = class e extends Wr { name = "AccessDeniedException"; $fault = "client"; error; reason; error_description; constructor(t) { super({ name: "AccessDeniedException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.reason = t.reason, this.error_description = t.error_description } }, Sh = class e extends Wr { name = "AuthorizationPendingException"; $fault = "client"; error; error_description; constructor(t) { super({ name: "AuthorizationPendingException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } }, _h = class e extends Wr { name = "ExpiredTokenException"; $fault = "client"; error; error_description; constructor(t) { super({ name: "ExpiredTokenException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } }, Ch = class e extends Wr { name = "InternalServerException"; $fault = "server"; error; error_description; constructor(t) { super({ name: "InternalServerException", $fault: "server", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } }, Rh = class e extends Wr { name = "InvalidClientException"; $fault = "client"; error; error_description; constructor(t) { super({ name: "InvalidClientException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } }, Ah = class e extends Wr { name = "InvalidGrantException"; $fault = "client"; error; error_description; constructor(t) { super({ name: "InvalidGrantException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } }, Th = class e extends Wr { name = "InvalidRequestException"; $fault = "client"; error; reason; error_description; constructor(t) { super({ name: "InvalidRequestException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.reason = t.reason, this.error_description = t.error_description } }, wh = class e extends Wr { name = "InvalidScopeException"; $fault = "client"; error; error_description; constructor(t) { super({ name: "InvalidScopeException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } }, bh = class e extends Wr { name = "SlowDownException"; $fault = "client"; error; error_description; constructor(t) { super({ name: "SlowDownException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } }, Ih = class e extends Wr { name = "UnauthorizedClientException"; $fault = "client"; error; error_description; constructor(t) { super({ name: "UnauthorizedClientException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } }, vh = class e extends Wr { name = "UnsupportedGrantTypeException"; $fault = "client"; error; error_description; constructor(t) { super({ name: "UnsupportedGrantTypeException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error, this.error_description = t.error_description } } }); var Iut, vut, Put, Out, Dut, kut, Nut, But, Lut, Mut, $ut, Fut, Uut, Hut, Gut, jut, qut, Vut, zut, Wut, Hs, Kut, Qut, Yut, Xut, Jut, ir, Zut, us, emt, tmt, ms, rmt, _de, Cde, omt, nmt, smt, Rde, imt, Et, amt, cmt, pmt, umt, Ade, Tde, wde, bde, Ide, vde, Pde, Ode, Dde, kde, Nde, Bde, Lde, Mde, $de, jB, qB = s(() => { Oe(); GB(); H_(); Iut = "AccessDeniedException", vut = "AuthorizationPendingException", Put = "AccessToken", Out = "ClientSecret", Dut = "CreateToken", kut = "CreateTokenRequest", Nut = "CreateTokenResponse", But = "CodeVerifier", Lut = "ExpiredTokenException", Mut = "InvalidClientException", $ut = "InvalidGrantException", Fut = "InvalidRequestException", Uut = "InternalServerException", Hut = "InvalidScopeException", Gut = "IdToken", jut = "RefreshToken", qut = "SlowDownException", Vut = "UnauthorizedClientException", zut = "UnsupportedGrantTypeException", Wut = "accessToken", Hs = "client", Kut = "clientId", Qut = "clientSecret", Yut = "codeVerifier", Xut = "code", Jut = "deviceCode", ir = "error", Zut = "expiresIn", us = "error_description", emt = "grantType", tmt = "http", ms = "httpError", rmt = "idToken", _de = "reason", Cde = "refreshToken", omt = "redirectUri", nmt = "scope", smt = "server", Rde = "smithy.ts.sdk.synthetic.com.amazonaws.ssooidc", imt = "tokenType", Et = "com.amazonaws.ssooidc", amt = [0, Et, Put, 8, 0], cmt = [0, Et, Out, 8, 0], pmt = [0, Et, But, 8, 0], umt = [0, Et, Gut, 8, 0], Ade = [0, Et, jut, 8, 0], Tde = [-3, Et, Iut, { [ir]: Hs, [ms]: 400 }, [ir, _de, us], [0, 0, 0]]; k.for(Et).registerError(Tde, yh); wde = [-3, Et, vut, { [ir]: Hs, [ms]: 400 }, [ir, us], [0, 0]]; k.for(Et).registerError(wde, Sh); bde = [3, Et, kut, 0, [Kut, Qut, emt, Jut, Xut, Cde, nmt, omt, Yut], [0, [() => cmt, 0], 0, 0, 0, [() => Ade, 0], 64, 0, [() => pmt, 0]]], Ide = [3, Et, Nut, 0, [Wut, imt, Zut, Cde, rmt], [[() => amt, 0], 0, 1, [() => Ade, 0], [() => umt, 0]]], vde = [-3, Et, Lut, { [ir]: Hs, [ms]: 400 }, [ir, us], [0, 0]]; k.for(Et).registerError(vde, _h); Pde = [-3, Et, Uut, { [ir]: smt, [ms]: 500 }, [ir, us], [0, 0]]; k.for(Et).registerError(Pde, Ch); Ode = [-3, Et, Mut, { [ir]: Hs, [ms]: 401 }, [ir, us], [0, 0]]; k.for(Et).registerError(Ode, Rh); Dde = [-3, Et, $ut, { [ir]: Hs, [ms]: 400 }, [ir, us], [0, 0]]; k.for(Et).registerError(Dde, Ah); kde = [-3, Et, Fut, { [ir]: Hs, [ms]: 400 }, [ir, _de, us], [0, 0, 0]]; k.for(Et).registerError(kde, Th); Nde = [-3, Et, Hut, { [ir]: Hs, [ms]: 400 }, [ir, us], [0, 0]]; k.for(Et).registerError(Nde, wh); Bde = [-3, Et, qut, { [ir]: Hs, [ms]: 400 }, [ir, us], [0, 0]]; k.for(Et).registerError(Bde, bh); Lde = [-3, Et, Vut, { [ir]: Hs, [ms]: 400 }, [ir, us], [0, 0]]; k.for(Et).registerError(Lde, Ih); Mde = [-3, Et, zut, { [ir]: Hs, [ms]: 400 }, [ir, us], [0, 0]]; k.for(Et).registerError(Mde, vh); $de = [-3, Rde, "SSOOIDCServiceException", 0, [], []]; k.for(Rde).registerError($de, Wr); jB = [9, Et, Dut, { [tmt]: ["POST", "/token", 200] }, () => bde, () => Ide] }); var Ph, VB = s(() => { _a(); Xt(); lB(); qB(); Ph = class extends $o.classBuilder().ep(Rpe).m(function (t, r, o, n) { return [Sa(o, t.getEndpointParameterInstructions())] }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").sc(jB).build() { } }); var mmt, G_, Fde = s(() => { Xt(); VB(); HB(); mmt = { CreateTokenCommand: Ph }, G_ = class extends Eh { }; cm(mmt, G_) }); var Ude = s(() => { VB() }); var lmt, dmt, Hde = s(() => { lmt = { KMS_ACCESS_DENIED: "KMS_AccessDeniedException" }, dmt = { KMS_DISABLED_KEY: "KMS_DisabledException", KMS_INVALID_KEY_USAGE: "KMS_InvalidKeyUsageException", KMS_INVALID_STATE: "KMS_InvalidStateException", KMS_KEY_NOT_FOUND: "KMS_NotFoundException" } }); var Gde = s(() => { }); var Mc = {}; Qe(Mc, { $Command: () => $o, AccessDeniedException: () => yh, AccessDeniedException$: () => Tde, AccessDeniedExceptionReason: () => lmt, AuthorizationPendingException: () => Sh, AuthorizationPendingException$: () => wde, CreateToken$: () => jB, CreateTokenCommand: () => Ph, CreateTokenRequest$: () => bde, CreateTokenResponse$: () => Ide, ExpiredTokenException: () => _h, ExpiredTokenException$: () => vde, InternalServerException: () => Ch, InternalServerException$: () => Pde, InvalidClientException: () => Rh, InvalidClientException$: () => Ode, InvalidGrantException: () => Ah, InvalidGrantException$: () => Dde, InvalidRequestException: () => Th, InvalidRequestException$: () => kde, InvalidRequestExceptionReason: () => dmt, InvalidScopeException: () => wh, InvalidScopeException$: () => Nde, SSOOIDC: () => G_, SSOOIDCClient: () => Eh, SSOOIDCServiceException: () => Wr, SSOOIDCServiceException$: () => $de, SlowDownException: () => bh, SlowDownException$: () => Bde, UnauthorizedClientException: () => Ih, UnauthorizedClientException$: () => Lde, UnsupportedGrantTypeException: () => vh, UnsupportedGrantTypeException$: () => Mde, __Client: () => cs }); var $c = s(() => { HB(); Fde(); Ude(); qB(); Hde(); GB(); Gde(); H_() }); var jde, qde = s(() => { jde = async (e, t = {}, r) => { let { SSOOIDCClient: o } = await Promise.resolve().then(() => ($c(), Mc)), n = a => t.clientConfig?.[a] ?? t.parentClientConfig?.[a] ?? r?.[a]; return new o(Object.assign({}, t.clientConfig ?? {}, { region: e ?? t.clientConfig?.region, logger: n("logger"), userAgentAppId: n("userAgentAppId") })) } }); var Vde, zde = s(() => { qde(); Vde = async (e, t, r = {}, o) => { let { CreateTokenCommand: n } = await Promise.resolve().then(() => ($c(), Mc)); return (await jde(t, r, o)).send(new n({ clientId: e.clientId, clientSecret: e.clientSecret, refreshToken: e.refreshToken, grantType: "refresh_token" })) } }); var zB, Wde = s(() => { Z(); o_(); zB = e => { if (e.expiration && e.expiration.getTime() < Date.now()) throw new at(`Token is expired. ${Mu}`, !1) } }); var va, Kde = s(() => { Z(); o_(); va = (e, t, r = !1) => { if (typeof t > "u") throw new at(`Value not present for '${e}' in SSO Token${r ? ". Cannot refresh" : ""}. ${Mu}`, !1) } }); import { promises as fmt } from "fs"; var hmt, Qde, Yde = s(() => { Xo(); ({ writeFile: hmt } = fmt), Qde = (e, t) => { let r = hy(e), o = JSON.stringify(t, null, 2); return hmt(r, o) } }); var Xde, Jde, Zde = s(() => { Z(); Xo(); o_(); zde(); Wde(); Kde(); Yde(); Xde = new Date(0), Jde = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/token-providers - fromSso"); let r = await ia(e), o = Sn({ profile: e.profile ?? t?.profile }), n = r[o]; if (n) { if (!n.sso_session) throw new at(`Profile '${o}' is missing required property 'sso_session'.`) } else throw new at(`Profile '${o}' could not be found in shared credentials file.`, !1); let i = n.sso_session, c = (await _y(e))[i]; if (!c) throw new at(`Sso session '${i}' could not be found in shared credentials file.`, !1); for (let E of ["sso_start_url", "sso_region"]) if (!c[E]) throw new at(`Sso session '${i}' is missing required property '${E}'.`, !1); let p = c.sso_start_url, u = c.sso_region, l; try { l = await $f(i) } catch { throw new at(`The SSO session token associated with profile=${o} was not found or is invalid. ${Mu}`, !1) } va("accessToken", l.accessToken), va("expiresAt", l.expiresAt); let { accessToken: m, expiresAt: f } = l, h = { token: m, expiration: new Date(f) }; if (h.expiration.getTime() - Date.now() > 3e5) return h; if (Date.now() - Xde.getTime() < 30 * 1e3) return zB(h), h; va("clientId", l.clientId, !0), va("clientSecret", l.clientSecret, !0), va("refreshToken", l.refreshToken, !0); try { Xde.setTime(Date.now()); let E = await Vde(l, u, e, t); va("accessToken", E.accessToken), va("expiresIn", E.expiresIn); let S = new Date(Date.now() + E.expiresIn * 1e3); try { await Qde(i, { ...l, accessToken: E.accessToken, expiresAt: S.toISOString(), refreshToken: E.refreshToken }) } catch { } return { token: E.accessToken, expiration: S } } catch { return zB(h), h } } }); var efe = s(() => { }); var tfe = s(() => { }); var rfe = s(() => { Qne(); Zde(); efe(); tfe() }); function xmt(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "awsssoportal", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } function j_(e) { return { schemeId: "smithy.api#noAuth" } } var ofe, nfe, sfe, WB = s(() => { Ye(); gt(); ofe = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }); nfe = e => { let t = []; switch (e.operation) { case "GetRoleCredentials": { t.push(j_(e)); break } case "ListAccountRoles": { t.push(j_(e)); break } case "ListAccounts": { t.push(j_(e)); break } case "Logout": { t.push(j_(e)); break } default: t.push(xmt(e)) }return t }, sfe = e => { let t = qr(e); return Object.assign(t, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var ife, Pa, vm = s(() => { ife = e => Object.assign(e, { useDualstackEndpoint: e.useDualstackEndpoint ?? !1, useFipsEndpoint: e.useFipsEndpoint ?? !1, defaultSigningName: "awsssoportal" }), Pa = { UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" } } }); var cfe, afe = s(() => { cfe = { name: "@aws-sdk/client-sso", description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native", version: "3.958.0", scripts: { build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs", "build:cjs": "node ../../scripts/compilation/inline client-sso", "build:es": "tsc -p tsconfig.es.json", "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"', "build:types": "tsc -p tsconfig.types.json", "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4", clean: "rimraf ./dist-* && rimraf *.tsbuildinfo", "extract:docs": "api-extractor run --local", "generate:client": "node ../../scripts/generate-clients/single-service --solo sso", "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs" }, main: "./dist-cjs/index.js", types: "./dist-types/index.d.ts", module: "./dist-es/index.js", sideEffects: !1, dependencies: { "@aws-crypto/sha256-browser": "5.2.0", "@aws-crypto/sha256-js": "5.2.0", "@aws-sdk/core": "3.957.0", "@aws-sdk/middleware-host-header": "3.957.0", "@aws-sdk/middleware-logger": "3.957.0", "@aws-sdk/middleware-recursion-detection": "3.957.0", "@aws-sdk/middleware-user-agent": "3.957.0", "@aws-sdk/region-config-resolver": "3.957.0", "@aws-sdk/types": "3.957.0", "@aws-sdk/util-endpoints": "3.957.0", "@aws-sdk/util-user-agent-browser": "3.957.0", "@aws-sdk/util-user-agent-node": "3.957.0", "@smithy/config-resolver": "^4.4.5", "@smithy/core": "^3.20.0", "@smithy/fetch-http-handler": "^5.3.8", "@smithy/hash-node": "^4.2.7", "@smithy/invalid-dependency": "^4.2.7", "@smithy/middleware-content-length": "^4.2.7", "@smithy/middleware-endpoint": "^4.4.1", "@smithy/middleware-retry": "^4.4.17", "@smithy/middleware-serde": "^4.2.8", "@smithy/middleware-stack": "^4.2.7", "@smithy/node-config-provider": "^4.3.7", "@smithy/node-http-handler": "^4.4.7", "@smithy/protocol-http": "^5.3.7", "@smithy/smithy-client": "^4.10.2", "@smithy/types": "^4.11.0", "@smithy/url-parser": "^4.2.7", "@smithy/util-base64": "^4.3.0", "@smithy/util-body-length-browser": "^4.2.0", "@smithy/util-body-length-node": "^4.2.1", "@smithy/util-defaults-mode-browser": "^4.3.16", "@smithy/util-defaults-mode-node": "^4.2.19", "@smithy/util-endpoints": "^3.2.7", "@smithy/util-middleware": "^4.2.7", "@smithy/util-retry": "^4.2.7", "@smithy/util-utf8": "^4.2.0", tslib: "^2.6.2" }, devDependencies: { "@tsconfig/node18": "18.2.4", "@types/node": "^18.19.69", concurrently: "7.0.0", "downlevel-dts": "0.10.1", rimraf: "3.0.2", typescript: "~5.8.3" }, engines: { node: ">=18.0.0" }, typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } }, files: ["dist-*/**"], author: { name: "AWS SDK for JavaScript Team", url: "https://aws.amazon.com/javascript/" }, license: "Apache-2.0", browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" }, "react-native": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native" }, homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso", repository: { type: "git", url: "https://github.com/aws/aws-sdk-js-v3.git", directory: "clients/client-sso" } } }); var pfe, ufe = s(() => { pfe = { isCrtAvailable: !1 } }); var mfe, lfe = s(() => { ufe(); mfe = () => pfe.isCrtAvailable ? ["md/crt-avail"] : null }); import { platform as ymt, release as Smt } from "os"; import { env as dfe, versions as _mt } from "process"; var q_, ffe = s(() => { lfe(); q_ = ({ serviceId: e, clientVersion: t }) => async r => { let o = [["aws-sdk-js", t], ["ua", "2.1"], [`os/${ymt()}`, Smt()], ["lang/js"], ["md/nodejs", `${_mt.node}`]], n = mfe(); n && o.push(n), e && o.push([`api/${e}`, t]), dfe.AWS_EXECUTION_ENV && o.push([`exec-env/${dfe.AWS_EXECUTION_ENV}`]); let i = await r?.userAgentAppId?.(); return i ? [...o, [`app/${i}`]] : [...o] } }); var Cmt, Rmt, Amt, V_, hfe = s(() => { ay(); Cmt = "AWS_SDK_UA_APP_ID", Rmt = "sdk_ua_app_id", Amt = "sdk-ua-app-id", V_ = { environmentVariableSelector: e => e[Cmt], configFileSelector: e => e[Rmt] ?? e[Amt], default: GO } }); var KB = s(() => { ffe(); hfe() }); import { Buffer as QB } from "buffer"; var YB, gfe, xfe = s(() => { cr(); YB = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return QB.from(e, t, r) }, gfe = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? QB.from(e, t) : QB.from(e) } }); import { Buffer as XB } from "buffer"; var Efe, yfe, JB = s(() => { cr(); Efe = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return XB.from(e, t, r) }, yfe = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? XB.from(e, t) : XB.from(e) } }); var Oa, ZB = s(() => { JB(); Oa = e => { let t = yfe(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var Sfe, _fe = s(() => { ZB(); Sfe = e => typeof e == "string" ? Oa(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) }); var z_, Cfe = s(() => { JB(); z_ = e => { if (typeof e == "string") return e; if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number") throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."); return Efe(e.buffer, e.byteOffset, e.byteLength).toString("utf8") } }); var Oh = s(() => { ZB(); _fe(); Cfe() }); import { Buffer as Tmt } from "buffer"; import { createHash as wmt, createHmac as bmt } from "crypto"; function Rfe(e, t) { return Tmt.isBuffer(e) ? e : typeof e == "string" ? gfe(e, t) : ArrayBuffer.isView(e) ? YB(e.buffer, e.byteOffset, e.byteLength) : YB(e) } var Pm, eL = s(() => { xfe(); Oh(); Pm = class { algorithmIdentifier; secret; hash; constructor(t, r) { this.algorithmIdentifier = t, this.secret = r, this.reset() } update(t, r) { this.hash.update(Sfe(Rfe(t, r))) } digest() { return Promise.resolve(this.hash.digest()) } reset() { this.hash = this.secret ? bmt(this.algorithmIdentifier, Rfe(this.secret)) : wmt(this.algorithmIdentifier) } } }); var W_, Imt, Afe = s(() => { W_ = e => encodeURIComponent(e).replace(/[!'()*]/g, Imt), Imt = e => `%${e.charCodeAt(0).toString(16).toUpperCase()}` }); var Tfe = s(() => { }); var wfe = s(() => { Afe(); Tfe() }); function bfe(e) { let t = []; for (let r of Object.keys(e).sort()) { let o = e[r]; if (r = W_(r), Array.isArray(o)) for (let n = 0, i = o.length; n < i; n++)t.push(`${r}=${W_(o[n])}`); else { let n = r; (o || typeof o == "string") && (n += `=${W_(o)}`), t.push(n) } } return t.join("&") } var Ife = s(() => { wfe() }); var vfe, Pfe = s(() => { vfe = ["ECONNRESET", "EPIPE", "ETIMEDOUT"] }); var Ofe, Dfe = s(() => { Ofe = e => { let t = {}; for (let r of Object.keys(e)) { let o = e[r]; t[r] = Array.isArray(o) ? o.join(",") : o } return t } }); var lr, Fc = s(() => { lr = { setTimeout: (e, t) => setTimeout(e, t), clearTimeout: e => clearTimeout(e) } }); var kfe, Nfe, Bfe = s(() => { Fc(); kfe = 1e3, Nfe = (e, t, r = 0) => { if (!r) return -1; let o = n => { let i = lr.setTimeout(() => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${r} ms.`), { name: "TimeoutError" })) }, r - n), a = c => { c?.connecting ? c.on("connect", () => { lr.clearTimeout(i) }) : lr.clearTimeout(i) }; e.socket ? a(e.socket) : e.on("socket", a) }; return r < 2e3 ? (o(0), 0) : lr.setTimeout(o.bind(null, kfe), kfe) } }); var Lfe, Mfe = s(() => { Fc(); Lfe = (e, t, r = 0, o, n) => r ? lr.setTimeout(() => { let i = `@smithy/node-http-handler - [${o ? "ERROR" : "WARN"}] a request has exceeded the configured ${r} ms requestTimeout.`; if (o) { let a = Object.assign(new Error(i), { name: "TimeoutError", code: "ETIMEDOUT" }); e.destroy(a), t(a) } else i += " Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.", n?.warn?.(i) }, r) : -1 }); var vmt, $fe, Ffe = s(() => { Fc(); vmt = 3e3, $fe = (e, { keepAlive: t, keepAliveMsecs: r }, o = vmt) => { if (t !== !0) return -1; let n = () => { e.socket ? e.socket.setKeepAlive(t, r || 0) : e.on("socket", i => { i.setKeepAlive(t, r || 0) }) }; return o === 0 ? (n(), 0) : lr.setTimeout(n, o) } }); var Ufe, Hfe, Gfe = s(() => { Fc(); Ufe = 3e3, Hfe = (e, t, r = 0) => { let o = n => { let i = r - n, a = () => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${r} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" })) }; e.socket ? (e.socket.setTimeout(i, a), e.on("close", () => e.socket?.removeListener("timeout", a))) : e.setTimeout(i, a) }; return 0 < r && r < 6e3 ? (o(0), 0) : lr.setTimeout(o.bind(null, r === 0 ? 0 : Ufe), Ufe) } }); import { Readable as Pmt } from "stream"; async function qfe(e, t, r = jfe, o = !1) { let n = t.headers ?? {}, i = n.Expect || n.expect, a = -1, c = !0; !o && i === "100-continue" && (c = await Promise.race([new Promise(p => { a = Number(lr.setTimeout(() => p(!0), Math.max(jfe, r))) }), new Promise(p => { e.on("continue", () => { lr.clearTimeout(a), p(!0) }), e.on("response", () => { lr.clearTimeout(a), p(!1) }), e.on("error", () => { lr.clearTimeout(a), p(!1) }) })])), c && Omt(e, t.body) } function Omt(e, t) { if (t instanceof Pmt) { t.pipe(e); return } if (t) { if (Buffer.isBuffer(t) || typeof t == "string") { e.end(t); return } let r = t; if (typeof r == "object" && r.buffer && typeof r.byteOffset == "number" && typeof r.byteLength == "number") { e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength)); return } e.end(Buffer.from(t)); return } e.end() } var jfe, Vfe = s(() => { Fc(); jfe = 6e3 }); import { Agent as tL, request as Dmt } from "http"; import { Agent as rL, request as kmt } from "https"; var Om, zfe = s(() => {
  di(); Ife(); Pfe(); Dfe(); Bfe(); Mfe(); Ffe(); Gfe(); Fc(); Vfe(); Om = class e {
    config; configProvider; socketWarningTimestamp = 0; externalAgent = !1; metadata = { handlerProtocol: "http/1.1" }; static create(t) { return typeof t?.handle == "function" ? t : new e(t) } static checkSocketUsage(t, r, o = console) {
      let { sockets: n, requests: i, maxSockets: a } = t; if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r) return r; if (n && i) for (let p in n) {
        let u = n[p]?.length ?? 0, l = i[p]?.length ?? 0; if (u >= a && l >= 2 * a) return o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${u} and ${l} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`), Date.now()
      } return r
    } constructor(t) { this.configProvider = new Promise((r, o) => { typeof t == "function" ? t().then(n => { r(this.resolveDefaultConfig(n)) }).catch(o) : r(this.resolveDefaultConfig(t)) }) } resolveDefaultConfig(t) { let { requestTimeout: r, connectionTimeout: o, socketTimeout: n, socketAcquisitionWarningTimeout: i, httpAgent: a, httpsAgent: c, throwOnRequestTimeout: p } = t || {}, u = !0, l = 50; return { connectionTimeout: o, requestTimeout: r, socketTimeout: n, socketAcquisitionWarningTimeout: i, throwOnRequestTimeout: p, httpAgent: a instanceof tL || typeof a?.destroy == "function" ? (this.externalAgent = !0, a) : new tL({ keepAlive: u, maxSockets: l, ...a }), httpsAgent: c instanceof rL || typeof c?.destroy == "function" ? (this.externalAgent = !0, c) : new rL({ keepAlive: u, maxSockets: l, ...c }), logger: console } } destroy() { this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy() } async handle(t, { abortSignal: r, requestTimeout: o } = {}) { return this.config || (this.config = await this.configProvider), new Promise((n, i) => { let a = this.config, c, p = [], u = async O => { await c, p.forEach(lr.clearTimeout), n(O) }, l = async O => { await c, p.forEach(lr.clearTimeout), i(O) }; if (r?.aborted) { let O = new Error("Request aborted"); O.name = "AbortError", l(O); return } let m = t.protocol === "https:", f = t.headers ?? {}, h = (f.Expect ?? f.expect) === "100-continue", E = m ? a.httpsAgent : a.httpAgent; h && !this.externalAgent && (E = new (m ? rL : tL)({ keepAlive: !1, maxSockets: 1 / 0 })), p.push(lr.setTimeout(() => { this.socketWarningTimestamp = e.checkSocketUsage(E, this.socketWarningTimestamp, a.logger) }, a.socketAcquisitionWarningTimeout ?? (a.requestTimeout ?? 2e3) + (a.connectionTimeout ?? 1e3))); let S = bfe(t.query || {}), y; if (t.username != null || t.password != null) { let O = t.username ?? "", ie = t.password ?? ""; y = `${O}:${ie}` } let C = t.path; S && (C += `?${S}`), t.fragment && (C += `#${t.fragment}`); let b = t.hostname ?? ""; b[0] === "[" && b.endsWith("]") ? b = t.hostname.slice(1, -1) : b = t.hostname; let L = { headers: t.headers, host: b, method: t.method, path: C, port: t.port, agent: E, auth: y }, j = (m ? kmt : Dmt)(L, O => { let ie = new Mp({ statusCode: O.statusCode || -1, reason: O.statusMessage, headers: Ofe(O.headers), body: O }); u({ response: ie }) }); if (j.on("error", O => { vfe.includes(O.code) ? l(Object.assign(O, { name: "TimeoutError" })) : l(O) }), r) { let O = () => { j.destroy(); let ie = new Error("Request aborted"); ie.name = "AbortError", l(ie) }; if (typeof r.addEventListener == "function") { let ie = r; ie.addEventListener("abort", O, { once: !0 }), j.once("close", () => ie.removeEventListener("abort", O)) } else r.onabort = O } let re = o ?? a.requestTimeout; p.push(Nfe(j, l, a.connectionTimeout)), p.push(Lfe(j, l, re, a.throwOnRequestTimeout, a.logger ?? console)), p.push(Hfe(j, l, a.socketTimeout)); let Ce = L.agent; typeof Ce == "object" && "keepAlive" in Ce && p.push($fe(j, { keepAlive: Ce.keepAlive, keepAliveMsecs: Ce.keepAliveMsecs })), c = qfe(j, t, re, this.externalAgent).catch(O => (p.forEach(lr.clearTimeout), i(O))) }) } updateHttpClientConfig(t, r) { this.config = void 0, this.configProvider = this.configProvider.then(o => ({ ...o, [t]: r })) } httpHandlerConfigs() { return this.config ?? {} }
  }
}); var Wfe = s(() => { }); import { Writable as Nmt } from "stream"; var K_, Kfe = s(() => { K_ = class extends Nmt { bufferedBytes = []; _write(t, r, o) { this.bufferedBytes.push(t), o() } } }); async function Lmt(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } var Q_, Bmt, Qfe = s(() => { Kfe(); Q_ = e => Bmt(e) ? Lmt(e) : new Promise((t, r) => { let o = new K_; e.pipe(o), e.on("error", n => { o.end(), r(n) }), o.on("error", r), o.on("finish", function () { let n = new Uint8Array(Buffer.concat(this.bufferedBytes)); t(n) }) }), Bmt = e => typeof ReadableStream == "function" && e instanceof ReadableStream }); var oL = s(() => { zfe(); Wfe(); Qfe() }); import { fstatSync as Mmt, lstatSync as $mt, ReadStream as Fmt } from "node:fs"; var Y_, Yfe = s(() => { Y_ = e => { if (!e) return 0; if (typeof e == "string") return Buffer.byteLength(e); if (typeof e.byteLength == "number") return e.byteLength; if (typeof e.size == "number") return e.size; if (typeof e.start == "number" && typeof e.end == "number") return e.end + 1 - e.start; if (e instanceof Fmt) { if (e.path != null) return $mt(e.path).size; if (typeof e.fd == "number") return Mmt(e.fd).size } throw new Error(`Body Length computation failed for ${e}`) } }); var nL = s(() => { Yfe() }); var Xfe, sL, iL, Jfe, Zfe, ehe, the = s(() => { Xfe = "AWS_EXECUTION_ENV", sL = "AWS_REGION", iL = "AWS_DEFAULT_REGION", Jfe = "AWS_EC2_METADATA_DISABLED", Zfe = ["in-region", "cross-region", "mobile", "standard", "legacy"], ehe = "/latest/meta-data/placement/region" }); var Umt, Hmt, rhe, ohe = s(() => { Umt = "AWS_DEFAULTS_MODE", Hmt = "defaults_mode", rhe = { environmentVariableSelector: e => e[Umt], configFileSelector: e => e[Hmt], default: "legacy" } }); var X_, Gmt, jmt, nhe = s(() => { xu(); Cc(); Z(); the(); ohe(); X_ = ({ region: e = It(gu), defaultsMode: t = It(rhe) } = {}) => jr(async () => { let r = typeof t == "function" ? await t() : t; switch (r?.toLowerCase()) { case "auto": return Gmt(e); case "in-region": case "cross-region": case "mobile": case "standard": case "legacy": return Promise.resolve(r?.toLocaleLowerCase()); case void 0: return Promise.resolve("legacy"); default: throw new Error(`Invalid parameter for "defaultsMode", expect ${Zfe.join(", ")}, got ${r}`) } }), Gmt = async e => { if (e) { let t = typeof e == "function" ? await e() : e, r = await jmt(); return r ? t === r ? "in-region" : "cross-region" : "standard" } return "standard" }, jmt = async () => { if (process.env[Xfe] && (process.env[sL] || process.env[iL])) return process.env[sL] ?? process.env[iL]; if (!process.env[Jfe]) try { let { getInstanceMetadataEndpoint: e, httpRequest: t } = await Promise.resolve().then(() => (ph(), ch)), r = await e(); return (await t({ ...r, path: ehe })).toString() } catch { } } }); var aL = s(() => { nhe() }); import { Buffer as cL } from "buffer"; var she, ihe, pL = s(() => { cr(); she = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return cL.from(e, t, r) }, ihe = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? cL.from(e, t) : cL.from(e) } }); var qmt, J_, ahe = s(() => { pL(); qmt = /^[A-Za-z0-9+/]*={0,2}$/, J_ = e => { if (e.length * 3 % 4 !== 0) throw new TypeError("Incorrect padding on base64 string."); if (!qmt.exec(e)) throw new TypeError("Invalid base64 string."); let t = ihe(e, "base64"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength) } }); var Z_, che = s(() => { pL(); Oh(); Z_ = e => { let t; if (typeof e == "string" ? t = Oa(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return she(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var uL = s(() => { ahe(); che() }); var Ehe, Pn, On, Nm, phe, Dh, Dm, km, bi, mL, lL, uhe, mhe, lhe, yhe, She, vn, dhe, _he, fhe, hhe, ghe, xhe, Vmt, Che, Rhe = s(() => { Ehe = "required", Pn = "fn", On = "argv", Nm = "ref", phe = "isSet", Dh = "booleanEquals", Dm = "error", km = "endpoint", bi = "tree", mL = "PartitionResult", lL = "getAttr", uhe = { [Ehe]: !1, type: "string" }, mhe = { [Ehe]: !0, default: !1, type: "boolean" }, lhe = { [Nm]: "Endpoint" }, yhe = { [Pn]: Dh, [On]: [{ [Nm]: "UseFIPS" }, !0] }, She = { [Pn]: Dh, [On]: [{ [Nm]: "UseDualStack" }, !0] }, vn = {}, dhe = { [Pn]: lL, [On]: [{ [Nm]: mL }, "supportsFIPS"] }, _he = { [Nm]: mL }, fhe = { [Pn]: Dh, [On]: [!0, { [Pn]: lL, [On]: [_he, "supportsDualStack"] }] }, hhe = [yhe], ghe = [She], xhe = [{ [Nm]: "Region" }], Vmt = { version: "1.0", parameters: { Region: uhe, UseDualStack: mhe, UseFIPS: mhe, Endpoint: uhe }, rules: [{ conditions: [{ [Pn]: phe, [On]: [lhe] }], rules: [{ conditions: hhe, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: Dm }, { conditions: ghe, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: Dm }, { endpoint: { url: lhe, properties: vn, headers: vn }, type: km }], type: bi }, { conditions: [{ [Pn]: phe, [On]: xhe }], rules: [{ conditions: [{ [Pn]: "aws.partition", [On]: xhe, assign: mL }], rules: [{ conditions: [yhe, She], rules: [{ conditions: [{ [Pn]: Dh, [On]: [!0, dhe] }, fhe], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: vn, headers: vn }, type: km }], type: bi }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: Dm }], type: bi }, { conditions: hhe, rules: [{ conditions: [{ [Pn]: Dh, [On]: [dhe, !0] }], rules: [{ conditions: [{ [Pn]: "stringEquals", [On]: [{ [Pn]: lL, [On]: [_he, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: vn, headers: vn }, type: km }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: vn, headers: vn }, type: km }], type: bi }, { error: "FIPS is enabled but this partition does not support FIPS", type: Dm }], type: bi }, { conditions: ghe, rules: [{ conditions: [fhe], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: vn, headers: vn }, type: km }], type: bi }, { error: "DualStack is enabled but this partition does not support DualStack", type: Dm }], type: bi }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: vn, headers: vn }, type: km }], type: bi }], type: bi }, { error: "Invalid Configuration: Missing Region", type: Dm }] }, Che = Vmt }); var zmt, Ahe, The = s(() => { wE(); Ft(); Rhe(); zmt = new Rr({ size: 50, params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"] }), Ahe = (e, t = {}) => zmt.get(e, () => Ur(Che, { endpointParams: e, logger: t.logger })); Rt.aws = Cf }); var whe, bhe = s(() => { Ye(); yn(); Ie(); ae(); Rf(); uL(); Oh(); WB(); The(); whe = e => ({ apiVersion: "2019-06-10", base64Decoder: e?.base64Decoder ?? J_, base64Encoder: e?.base64Encoder ?? Z_, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? Ahe, extensions: e?.extensions ?? [], httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? nfe, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }, { schemeId: "smithy.api#noAuth", identityProvider: t => t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})), signer: new po }], logger: e?.logger ?? new ca, protocol: e?.protocol ?? En, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.sso", version: "2019-06-10", serviceTarget: "SWBPortalService" }, serviceId: e?.serviceId ?? "SSO", urlParser: e?.urlParser ?? bs, utf8Decoder: e?.utf8Decoder ?? Oa, utf8Encoder: e?.utf8Encoder ?? z_ }) }); var Ihe, vhe = s(() => { afe(); Ye(); KB(); xu(); eL(); qf(); Cc(); oL(); ae(); nL(); aL(); jf(); bhe(); Ihe = e => { My(process.version); let t = X_(e), r = () => t().then(Ly), o = whe(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, authSchemePreference: e?.authSchemePreference ?? It(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? Y_, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? q_({ serviceId: o.serviceId, clientVersion: cfe.version }), maxAttempts: e?.maxAttempts ?? It(Oy, e), region: e?.region ?? It(gu, { ...uy, ...n }), requestHandler: Om.create(e?.requestHandler ?? r), retryMode: e?.retryMode ?? It({ ...ky, default: async () => (await r()).retryMode || Su }, e), sha256: e?.sha256 ?? Pm.bind(null, "sha256"), streamCollector: e?.streamCollector ?? Q_, useDualstackEndpoint: e?.useDualstackEndpoint ?? It(cy, n), useFipsEndpoint: e?.useFipsEndpoint ?? It(py, n), userAgentAppId: e?.userAgentAppId ?? It(V_, n) } } }); var Phe, Ohe, Dhe = s(() => { Phe = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, Ohe = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var khe, Nhe = s(() => { ps(); di(); ae(); Dhe(); khe = (e, t) => { let r = Object.assign(Vr(e), $y(e), tE(e), Phe(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), Fy(r), rE(r), Ohe(r)) } }); var Gs, kh = s(() => { aO(); cO(); fO(); ay(); xu(); Ie(); Oe(); WD(); me(); qf(); ae(); WB(); vm(); vhe(); Nhe(); Gs = class extends Ru { config; constructor(...[t]) { let r = Ihe(t || {}); super(r), this.initConfig = r; let o = ife(r), n = SE(o), i = Dy(n), a = ly(i), c = a, p = Ty(c), u = sfe(p), l = khe(u, t?.extensions || []); this.config = l, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(iy(this.config)), this.middlewareStack.use(Uy(this.config)), this.middlewareStack.use(dy(this.config)), this.middlewareStack.use(oE(this.config)), this.middlewareStack.use(nE(this.config)), this.middlewareStack.use(iE(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: ofe, identityProviderConfigProvider: async m => new Cr({ "aws.auth#sigv4": m.credentials }) })), this.middlewareStack.use($r(this.config)) } destroy() { super.destroy() } } }); var Ii, dL = s(() => { ae(); Ii = class e extends Au { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var eC, tC, rC, oC, fL = s(() => { dL(); eC = class e extends Ii { name = "InvalidRequestException"; $fault = "client"; constructor(t) { super({ name: "InvalidRequestException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, tC = class e extends Ii { name = "ResourceNotFoundException"; $fault = "client"; constructor(t) { super({ name: "ResourceNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, rC = class e extends Ii { name = "TooManyRequestsException"; $fault = "client"; constructor(t) { super({ name: "TooManyRequestsException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, oC = class e extends Ii { name = "UnauthorizedException"; $fault = "client"; constructor(t) { super({ name: "UnauthorizedException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } } }); var Kmt, Qmt, Ymt, Xmt, Jmt, Zmt, elt, tlt, rlt, olt, nlt, slt, ilt, alt, clt, plt, ult, mlt, llt, dlt, flt, hlt, glt, nC, xlt, Elt, ylt, sC, Bhe, iC, aC, Slt, _lt, cC, pC, uC, Uc, mC, Lhe, Mhe, lC, $he, Clt, Rlt, Fhe, Alt, Uhe, Tlt, wlt, dC, Nt, fC, blt, Ilt, vlt, Plt, Olt, Dlt, klt, Nlt, Blt, Llt, Mlt, $lt, Flt, Ult, Hlt, Glt, jlt, qlt, Vlt, zlt, Hhe, Ghe, jhe, qhe, Bm = s(() => { Oe(); fL(); dL(); Kmt = "AccountInfo", Qmt = "AccountListType", Ymt = "AccessTokenType", Xmt = "GetRoleCredentials", Jmt = "GetRoleCredentialsRequest", Zmt = "GetRoleCredentialsResponse", elt = "InvalidRequestException", tlt = "Logout", rlt = "ListAccounts", olt = "ListAccountsRequest", nlt = "ListAccountRolesRequest", slt = "ListAccountRolesResponse", ilt = "ListAccountsResponse", alt = "ListAccountRoles", clt = "LogoutRequest", plt = "RoleCredentials", ult = "RoleInfo", mlt = "RoleListType", llt = "ResourceNotFoundException", dlt = "SecretAccessKeyType", flt = "SessionTokenType", hlt = "TooManyRequestsException", glt = "UnauthorizedException", nC = "accountId", xlt = "accessKeyId", Elt = "accountList", ylt = "accountName", sC = "accessToken", Bhe = "account_id", iC = "client", aC = "error", Slt = "emailAddress", _lt = "expiration", cC = "http", pC = "httpError", uC = "httpHeader", Uc = "httpQuery", mC = "message", Lhe = "maxResults", Mhe = "max_result", lC = "nextToken", $he = "next_token", Clt = "roleCredentials", Rlt = "roleList", Fhe = "roleName", Alt = "role_name", Uhe = "smithy.ts.sdk.synthetic.com.amazonaws.sso", Tlt = "secretAccessKey", wlt = "sessionToken", dC = "x-amz-sso_bearer_token", Nt = "com.amazonaws.sso", fC = [0, Nt, Ymt, 8, 0], blt = [0, Nt, dlt, 8, 0], Ilt = [0, Nt, flt, 8, 0], vlt = [3, Nt, Kmt, 0, [nC, ylt, Slt], [0, 0, 0]], Plt = [3, Nt, Jmt, 0, [Fhe, nC, sC], [[0, { [Uc]: Alt }], [0, { [Uc]: Bhe }], [() => fC, { [uC]: dC }]]], Olt = [3, Nt, Zmt, 0, [Clt], [[() => Flt, 0]]], Dlt = [-3, Nt, elt, { [aC]: iC, [pC]: 400 }, [mC], [0]]; k.for(Nt).registerError(Dlt, eC); klt = [3, Nt, nlt, 0, [lC, Lhe, sC, nC], [[0, { [Uc]: $he }], [1, { [Uc]: Mhe }], [() => fC, { [uC]: dC }], [0, { [Uc]: Bhe }]]], Nlt = [3, Nt, slt, 0, [lC, Rlt], [0, () => zlt]], Blt = [3, Nt, olt, 0, [lC, Lhe, sC], [[0, { [Uc]: $he }], [1, { [Uc]: Mhe }], [() => fC, { [uC]: dC }]]], Llt = [3, Nt, ilt, 0, [lC, Elt], [0, () => Vlt]], Mlt = [3, Nt, clt, 0, [sC], [[() => fC, { [uC]: dC }]]], $lt = [-3, Nt, llt, { [aC]: iC, [pC]: 404 }, [mC], [0]]; k.for(Nt).registerError($lt, tC); Flt = [3, Nt, plt, 0, [xlt, Tlt, wlt, _lt], [0, [() => blt, 0], [() => Ilt, 0], 1]], Ult = [3, Nt, ult, 0, [Fhe, nC], [0, 0]], Hlt = [-3, Nt, hlt, { [aC]: iC, [pC]: 429 }, [mC], [0]]; k.for(Nt).registerError(Hlt, rC); Glt = [-3, Nt, glt, { [aC]: iC, [pC]: 401 }, [mC], [0]]; k.for(Nt).registerError(Glt, oC); jlt = "unit", qlt = [-3, Uhe, "SSOServiceException", 0, [], []]; k.for(Uhe).registerError(qlt, Ii); Vlt = [1, Nt, Qmt, 0, () => vlt], zlt = [1, Nt, mlt, 0, () => Ult], Hhe = [9, Nt, Xmt, { [cC]: ["GET", "/federation/credentials", 200] }, () => Plt, () => Olt], Ghe = [9, Nt, alt, { [cC]: ["GET", "/assignment/roles", 200] }, () => klt, () => Nlt], jhe = [9, Nt, rlt, { [cC]: ["GET", "/assignment/accounts", 200] }, () => Blt, () => Llt], qhe = [9, Nt, tlt, { [cC]: ["POST", "/logout", 200] }, () => Mlt, () => jlt] }); var Lm, hL = s(() => { me(); ae(); vm(); Bm(); Lm = class extends $.classBuilder().ep(Pa).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").sc(Hhe).build() { } }); var Mm, hC = s(() => { me(); ae(); vm(); Bm(); Mm = class extends $.classBuilder().ep(Pa).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").sc(Ghe).build() { } }); var $m, gC = s(() => { me(); ae(); vm(); Bm(); $m = class extends $.classBuilder().ep(Pa).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").sc(jhe).build() { } }); var xC, gL = s(() => { me(); ae(); vm(); Bm(); xC = class extends $.classBuilder().ep(Pa).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").sc(qhe).build() { } }); var Wlt, xL, Vhe = s(() => { ae(); hL(); hC(); gC(); gL(); kh(); Wlt = { GetRoleCredentialsCommand: Lm, ListAccountRolesCommand: Mm, ListAccountsCommand: $m, LogoutCommand: xC }, xL = class extends Gs { }; By(Wlt, xL) }); var zhe = s(() => { hL(); hC(); gC(); gL() }); var Whe = s(() => { }); var gDr, Khe = s(() => { Ie(); hC(); kh(); gDr = qe(Gs, Mm, "nextToken", "nextToken", "maxResults") }); var _Dr, Qhe = s(() => { Ie(); gC(); kh(); _Dr = qe(Gs, $m, "nextToken", "nextToken", "maxResults") }); var Yhe = s(() => { Whe(); Khe(); Qhe() }); var Xhe = s(() => { }); var Jhe = s(() => { kh(); Vhe(); zhe(); Bm(); Yhe(); fL(); Xhe() }); var Zhe = {}; Qe(Zhe, { GetRoleCredentialsCommand: () => Lm, SSOClient: () => Gs }); var ege = s(() => { Jhe() }); var Nh, EL, tge = s(() => { He(); rfe(); Z(); Xo(); Nh = !1, EL = async ({ ssoStartUrl: e, ssoSession: t, ssoAccountId: r, ssoRegion: o, ssoRoleName: n, ssoClient: i, clientConfig: a, parentClientConfig: c, callerClientConfig: p, profile: u, filepath: l, configFilepath: m, ignoreCache: f, logger: h }) => { let E, S = "To refresh this SSO session run aws sso login with the corresponding profile."; if (t) try { let dt = await Jde({ profile: u, filepath: l, configFilepath: m, ignoreCache: f })(); E = { accessToken: dt.token, expiresAt: new Date(dt.expiration).toISOString() } } catch (dt) { throw new I(dt.message, { tryNextLink: Nh, logger: h }) } else try { E = await $f(e) } catch { throw new I(`The SSO session associated with this profile is invalid. ${S}`, { tryNextLink: Nh, logger: h }) } if (new Date(E.expiresAt).getTime() - Date.now() <= 0) throw new I(`The SSO session associated with this profile has expired. ${S}`, { tryNextLink: Nh, logger: h }); let { accessToken: y } = E, { SSOClient: C, GetRoleCredentialsCommand: b } = await Promise.resolve().then(() => (ege(), Zhe)), L = i || new C(Object.assign({}, a ?? {}, { logger: a?.logger ?? p?.logger ?? c?.logger, region: a?.region ?? o, userAgentAppId: a?.userAgentAppId ?? p?.userAgentAppId ?? c?.userAgentAppId })), N; try { N = await L.send(new b({ accountId: r, roleName: n, accessToken: y })) } catch (dt) { throw new I(dt, { tryNextLink: Nh, logger: h }) } let { roleCredentials: { accessKeyId: j, secretAccessKey: re, sessionToken: Ce, expiration: O, credentialScope: ie, accountId: st } = {} } = N; if (!j || !re || !Ce || !O) throw new I("SSO returns an invalid temporary credential.", { tryNextLink: Nh, logger: h }); let Ct = { accessKeyId: j, secretAccessKey: re, sessionToken: Ce, expiration: new Date(O), ...ie && { credentialScope: ie }, ...st && { accountId: st } }; return t ? ee(Ct, "CREDENTIALS_SSO", "s") : ee(Ct, "CREDENTIALS_SSO_LEGACY", "u"), Ct } }); var yL, SL = s(() => {
  Z(); yL = (e, t) => {
    let { sso_start_url: r, sso_account_id: o, sso_region: n, sso_role_name: i } = e; if (!r || !o || !n || !i) throw new I(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: !1, logger: t }); return e
  }
}); var Klt, rge = s(() => { Z(); Xo(); $N(); tge(); SL(); Klt = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO"); let { ssoStartUrl: r, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoSession: a } = e, { ssoClient: c } = e, p = Sn({ profile: e.profile ?? t?.profile }); if (!r && !o && !n && !i && !a) { let l = (await ia(e))[p]; if (!l) throw new I(`Profile ${p} was not found.`, { logger: e.logger }); if (!MN(l)) throw new I(`Profile ${p} is not configured with SSO credentials.`, { logger: e.logger }); if (l?.sso_session) { let C = (await _y(e))[l.sso_session], b = ` configurations in profile ${p} and sso-session ${l.sso_session}`; if (n && n !== C.sso_region) throw new I("Conflicting SSO region" + b, { tryNextLink: !1, logger: e.logger }); if (r && r !== C.sso_start_url) throw new I("Conflicting SSO start_url" + b, { tryNextLink: !1, logger: e.logger }); l.sso_region = C.sso_region, l.sso_start_url = C.sso_start_url } let { sso_start_url: m, sso_account_id: f, sso_region: h, sso_role_name: E, sso_session: S } = yL(l, e.logger); return EL({ ssoStartUrl: m, ssoSession: S, ssoAccountId: f, ssoRegion: h, ssoRoleName: E, ssoClient: c, clientConfig: e.clientConfig, parentClientConfig: e.parentClientConfig, callerClientConfig: e.callerClientConfig, profile: p, filepath: e.filepath, configFilepath: e.configFilepath, ignoreCache: e.ignoreCache, logger: e.logger }) } else { if (!r || !o || !n || !i) throw new I('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', { tryNextLink: !1, logger: e.logger }); return EL({ ssoStartUrl: r, ssoSession: a, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoClient: c, clientConfig: e.clientConfig, parentClientConfig: e.parentClientConfig, callerClientConfig: e.callerClientConfig, profile: p, filepath: e.filepath, configFilepath: e.configFilepath, ignoreCache: e.ignoreCache, logger: e.logger }) } } }); var oge = s(() => { }); var _L = {}; Qe(_L, { fromSSO: () => Klt, isSsoProfile: () => MN, validateSsoProfile: () => yL }); var CL = s(() => { rge(); $N(); oge(); SL() }); var nge, RL, sge = s(() => { He(); Z(); nge = (e, t, r) => { let o = { EcsContainer: async n => { let { fromHttp: i } = await Promise.resolve().then(() => (vc(), Ic)), { fromContainerMetadata: a } = await Promise.resolve().then(() => (ph(), ch)); return r?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"), async () => sr(i(n ?? {}), a(n))().then(RL) }, Ec2InstanceMetadata: async n => { r?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata"); let { fromInstanceMetadata: i } = await Promise.resolve().then(() => (ph(), ch)); return async () => i(n)().then(RL) }, Environment: async n => { r?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment"); let { fromEnv: i } = await Promise.resolve().then(() => (EN(), jre)); return async () => i(n)().then(RL) } }; if (e in o) return o[e]; throw new I(`Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger: r }) }, RL = e => ee(e, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p") }); function Qlt(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "sts", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } function Ylt(e) { return { schemeId: "smithy.api#noAuth" } } var ige, age, Xlt, cge, AL = s(() => { Ye(); gt(); Bh(); ige = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }); age = e => { let t = []; switch (e.operation) { case "AssumeRoleWithWebIdentity": { t.push(Ylt(e)); break } default: t.push(Qlt(e)) }return t }, Xlt = e => Object.assign(e, { stsClientCtor: js }), cge = e => { let t = Xlt(e), r = qr(t); return Object.assign(r, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var pge, EC, yC = s(() => { pge = e => Object.assign(e, { useDualstackEndpoint: e.useDualstackEndpoint ?? !1, useFipsEndpoint: e.useFipsEndpoint ?? !1, useGlobalEndpoint: e.useGlobalEndpoint ?? !1, defaultSigningName: "sts" }), EC = { UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" }, UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" } } }); var Sge, Ne, pt, ut, ka, Da, oo, _ge, Cge, Rge, Jt, uge, qs, Fm, wL, mge, TL, Age, lge, no, dge, Tge, wge, mo, Zo, fge, bge, Ige, hge, vge, gge, xge, Ege, yge, Jlt, Pge, Oge = s(() => { Sge = "required", Ne = "type", pt = "fn", ut = "argv", ka = "ref", Da = "booleanEquals", oo = "stringEquals", _ge = "sigv4", Cge = "sts", Rge = "us-east-1", Jt = "endpoint", uge = "https://sts.{Region}.{PartitionResult#dnsSuffix}", qs = "tree", Fm = "error", wL = "getAttr", mge = { [Sge]: !1, [Ne]: "string" }, TL = { [Sge]: !0, default: !1, [Ne]: "boolean" }, Age = { [ka]: "Endpoint" }, lge = { [pt]: "isSet", [ut]: [{ [ka]: "Region" }] }, no = { [ka]: "Region" }, dge = { [pt]: "aws.partition", [ut]: [no], assign: "PartitionResult" }, Tge = { [ka]: "UseFIPS" }, wge = { [ka]: "UseDualStack" }, mo = { url: "https://sts.amazonaws.com", properties: { authSchemes: [{ name: _ge, signingName: Cge, signingRegion: Rge }] }, headers: {} }, Zo = {}, fge = { conditions: [{ [pt]: oo, [ut]: [no, "aws-global"] }], [Jt]: mo, [Ne]: Jt }, bge = { [pt]: Da, [ut]: [Tge, !0] }, Ige = { [pt]: Da, [ut]: [wge, !0] }, hge = { [pt]: wL, [ut]: [{ [ka]: "PartitionResult" }, "supportsFIPS"] }, vge = { [ka]: "PartitionResult" }, gge = { [pt]: Da, [ut]: [!0, { [pt]: wL, [ut]: [vge, "supportsDualStack"] }] }, xge = [{ [pt]: "isSet", [ut]: [Age] }], Ege = [bge], yge = [Ige], Jlt = { version: "1.0", parameters: { Region: mge, UseDualStack: TL, UseFIPS: TL, Endpoint: mge, UseGlobalEndpoint: TL }, rules: [{ conditions: [{ [pt]: Da, [ut]: [{ [ka]: "UseGlobalEndpoint" }, !0] }, { [pt]: "not", [ut]: xge }, lge, dge, { [pt]: Da, [ut]: [Tge, !1] }, { [pt]: Da, [ut]: [wge, !1] }], rules: [{ conditions: [{ [pt]: oo, [ut]: [no, "ap-northeast-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "ap-south-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "ap-southeast-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "ap-southeast-2"] }], endpoint: mo, [Ne]: Jt }, fge, { conditions: [{ [pt]: oo, [ut]: [no, "ca-central-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "eu-central-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "eu-north-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "eu-west-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "eu-west-2"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "eu-west-3"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "sa-east-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, Rge] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "us-east-2"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "us-west-1"] }], endpoint: mo, [Ne]: Jt }, { conditions: [{ [pt]: oo, [ut]: [no, "us-west-2"] }], endpoint: mo, [Ne]: Jt }, { endpoint: { url: uge, properties: { authSchemes: [{ name: _ge, signingName: Cge, signingRegion: "{Region}" }] }, headers: Zo }, [Ne]: Jt }], [Ne]: qs }, { conditions: xge, rules: [{ conditions: Ege, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [Ne]: Fm }, { conditions: yge, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [Ne]: Fm }, { endpoint: { url: Age, properties: Zo, headers: Zo }, [Ne]: Jt }], [Ne]: qs }, { conditions: [lge], rules: [{ conditions: [dge], rules: [{ conditions: [bge, Ige], rules: [{ conditions: [{ [pt]: Da, [ut]: [!0, hge] }, gge], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Zo, headers: Zo }, [Ne]: Jt }], [Ne]: qs }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [Ne]: Fm }], [Ne]: qs }, { conditions: Ege, rules: [{ conditions: [{ [pt]: Da, [ut]: [hge, !0] }], rules: [{ conditions: [{ [pt]: oo, [ut]: [{ [pt]: wL, [ut]: [vge, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: Zo, headers: Zo }, [Ne]: Jt }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: Zo, headers: Zo }, [Ne]: Jt }], [Ne]: qs }, { error: "FIPS is enabled but this partition does not support FIPS", [Ne]: Fm }], [Ne]: qs }, { conditions: yge, rules: [{ conditions: [gge], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Zo, headers: Zo }, [Ne]: Jt }], [Ne]: qs }, { error: "DualStack is enabled but this partition does not support DualStack", [Ne]: Fm }], [Ne]: qs }, fge, { endpoint: { url: uge, properties: Zo, headers: Zo }, [Ne]: Jt }], [Ne]: qs }], [Ne]: qs }, { error: "Invalid Configuration: Missing Region", [Ne]: Fm }] }, Pge = Jlt }); var Zlt, Dge, kge = s(() => { mh(); Ft(); Oge(); Zlt = new Rr({ size: 50, params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"] }), Dge = (e, t = {}) => Zlt.get(e, () => Ur(Pge, { endpointParams: e, logger: t.logger })); Rt.aws = Oc }); var Nge, Bge = s(() => { Ye(); yn(); Ie(); Xt(); zu(); F_(); Em(); AL(); kge(); Nge = e => ({ apiVersion: "2011-06-15", base64Decoder: e?.base64Decoder ?? Cm, base64Encoder: e?.base64Encoder ?? Rm, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? Dge, extensions: e?.extensions ?? [], httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? age, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }, { schemeId: "smithy.api#noAuth", identityProvider: t => t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})), signer: new po }], logger: e?.logger ?? new Fs, protocol: e?.protocol ?? ZE, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.sts", xmlNamespace: "https://sts.amazonaws.com/doc/2011-06-15/", version: "2011-06-15", serviceTarget: "AWSSecurityTokenServiceV20110615" }, serviceId: e?.serviceId ?? "STS", urlParser: e?.urlParser ?? Tn, utf8Decoder: e?.utf8Decoder ?? Us, utf8Encoder: e?.utf8Encoder ?? xm }) }); var Lge, Mge = s(() => { R_(); Ye(); A_(); Ea(); Ie(); T_(); kc(); ya(); I_(); Xt(); v_(); $_(); om(); Bge(); Lge = e => { um(process.version); let t = _m(e), r = () => t().then(pm), o = Nge(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, authSchemePreference: e?.authSchemePreference ?? tt(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? Sm, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? hm({ serviceId: o.serviceId, clientVersion: fm.version }), httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: i => i.getIdentityProvider("aws.auth#sigv4") || (async a => await e.credentialDefaultProvider(a?.__config || {})()), signer: new Vt }, { schemeId: "smithy.api#noAuth", identityProvider: i => i.getIdentityProvider("smithy.api#noAuth") || (async () => ({})), signer: new po }], maxAttempts: e?.maxAttempts ?? tt(nm, e), region: e?.region ?? tt(xa, { ...Yu, ...n }), requestHandler: wa.create(e?.requestHandler ?? r), retryMode: e?.retryMode ?? tt({ ...im, default: async () => (await r()).retryMode || Ca }, e), sha256: e?.sha256 ?? Ta.bind(null, "sha256"), streamCollector: e?.streamCollector ?? ym, useDualstackEndpoint: e?.useDualstackEndpoint ?? tt(Ku, n), useFipsEndpoint: e?.useFipsEndpoint ?? tt(Qu, n), userAgentAppId: e?.userAgentAppId ?? tt(gm, n) } } }); var $ge, Fge, Uge = s(() => { $ge = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, Fge = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var Hge, Gge = s(() => { ps(); Ms(); Xt(); Uge(); Hge = (e, t) => { let r = Object.assign(Vr(e), mm(e), $u(e), $ge(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), lm(r), Fu(r), Fge(r)) } }); var js, Bh = s(() => { n_(); s_(); i_(); lh(); Ea(); Ie(); Oe(); m_(); _a(); kc(); Xt(); AL(); yC(); Mge(); Gge(); js = class extends cs { config; constructor(...[t]) { let r = Lge(t || {}); super(r), this.initConfig = r; let o = pge(r), n = Vu(o), i = sm(n), a = Xu(i), c = a, p = em(c), u = cge(p), l = Hge(u, t?.extensions || []); this.config = l, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(Wu(this.config)), this.middlewareStack.use(dm(this.config)), this.middlewareStack.use(Ju(this.config)), this.middlewareStack.use(Gu(this.config)), this.middlewareStack.use(ju(this.config)), this.middlewareStack.use(qu(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: ige, identityProviderConfigProvider: async m => new Cr({ "aws.auth#sigv4": m.credentials }) })), this.middlewareStack.use($r(this.config)) } destroy() { super.destroy() } } }); var Fo, SC = s(() => { Xt(); Fo = class e extends Aa { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var Lh, Mh, $h, Fh, Uh, Hh, Gh, bL = s(() => { SC(); Lh = class e extends Fo { name = "ExpiredTokenException"; $fault = "client"; constructor(t) { super({ name: "ExpiredTokenException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Mh = class e extends Fo { name = "MalformedPolicyDocumentException"; $fault = "client"; constructor(t) { super({ name: "MalformedPolicyDocumentException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, $h = class e extends Fo { name = "PackedPolicyTooLargeException"; $fault = "client"; constructor(t) { super({ name: "PackedPolicyTooLargeException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Fh = class e extends Fo { name = "RegionDisabledException"; $fault = "client"; constructor(t) { super({ name: "RegionDisabledException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Uh = class e extends Fo { name = "IDPRejectedClaimException"; $fault = "client"; constructor(t) { super({ name: "IDPRejectedClaimException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Hh = class e extends Fo { name = "InvalidIdentityTokenException"; $fault = "client"; constructor(t) { super({ name: "InvalidIdentityTokenException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Gh = class e extends Fo { name = "IDPCommunicationErrorException"; $fault = "client"; constructor(t) { super({ name: "IDPCommunicationErrorException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } } }); var edt, tdt, rdt, odt, ndt, sdt, IL, idt, adt, cdt, pdt, vL, udt, jge, mdt, ldt, ddt, fdt, hdt, gdt, xdt, Edt, qge, Vge, ydt, Sdt, _dt, Cdt, Rdt, Adt, zge, Tdt, wdt, Wge, bdt, Kge, Idt, vdt, PL, Pdt, Odt, Ddt, kdt, Ndt, Bdt, Ldt, Mdt, $dt, Fdt, Hc, Gc, Udt, jc, qc, Vc, Hdt, Qge, Gdt, yt, jdt, qdt, OL, Yge, Xge, Jge, Zge, DL, exe, txe, rxe, oxe, nxe, sxe, ixe, axe, cxe, pxe, uxe, mxe, Vdt, zdt, kL, NL, _C = s(() => { Oe(); bL(); SC(); edt = "Arn", tdt = "AccessKeyId", rdt = "AssumeRole", odt = "AssumedRoleId", ndt = "AssumeRoleRequest", sdt = "AssumeRoleResponse", IL = "AssumedRoleUser", idt = "AssumeRoleWithWebIdentity", adt = "AssumeRoleWithWebIdentityRequest", cdt = "AssumeRoleWithWebIdentityResponse", pdt = "Audience", vL = "Credentials", udt = "ContextAssertion", jge = "DurationSeconds", mdt = "Expiration", ldt = "ExternalId", ddt = "ExpiredTokenException", fdt = "IDPCommunicationErrorException", hdt = "IDPRejectedClaimException", gdt = "InvalidIdentityTokenException", xdt = "Key", Edt = "MalformedPolicyDocumentException", qge = "Policy", Vge = "PolicyArns", ydt = "ProviderArn", Sdt = "ProvidedContexts", _dt = "ProvidedContextsListType", Cdt = "ProvidedContext", Rdt = "PolicyDescriptorType", Adt = "ProviderId", zge = "PackedPolicySize", Tdt = "PackedPolicyTooLargeException", wdt = "Provider", Wge = "RoleArn", bdt = "RegionDisabledException", Kge = "RoleSessionName", Idt = "SecretAccessKey", vdt = "SubjectFromWebIdentityToken", PL = "SourceIdentity", Pdt = "SerialNumber", Odt = "SessionToken", Ddt = "Tags", kdt = "TokenCode", Ndt = "TransitiveTagKeys", Bdt = "Tag", Ldt = "Value", Mdt = "WebIdentityToken", $dt = "arn", Fdt = "accessKeySecretType", Hc = "awsQueryError", Gc = "client", Udt = "clientTokenType", jc = "error", qc = "httpError", Vc = "message", Hdt = "policyDescriptorListType", Qge = "smithy.ts.sdk.synthetic.com.amazonaws.sts", Gdt = "tagListType", yt = "com.amazonaws.sts", jdt = [0, yt, Fdt, 8, 0], qdt = [0, yt, Udt, 8, 0], OL = [3, yt, IL, 0, [odt, edt], [0, 0]], Yge = [3, yt, ndt, 0, [Wge, Kge, Vge, qge, jge, Ddt, Ndt, ldt, Pdt, kdt, PL, Sdt], [0, 0, () => mxe, 0, 1, () => zdt, 64, 0, 0, 0, 0, () => Vdt]], Xge = [3, yt, sdt, 0, [vL, IL, zge, PL], [[() => DL, 0], () => OL, 1, 0]], Jge = [3, yt, adt, 0, [Wge, Kge, Mdt, Adt, Vge, qge, jge], [0, 0, [() => qdt, 0], 0, () => mxe, 0, 1]], Zge = [3, yt, cdt, 0, [vL, vdt, IL, zge, wdt, pdt, PL], [[() => DL, 0], 0, () => OL, 1, 0, 0, 0]], DL = [3, yt, vL, 0, [tdt, Idt, Odt, mdt], [0, [() => jdt, 0], 0, 4]], exe = [-3, yt, ddt, { [Hc]: ["ExpiredTokenException", 400], [jc]: Gc, [qc]: 400 }, [Vc], [0]]; k.for(yt).registerError(exe, Lh); txe = [-3, yt, fdt, { [Hc]: ["IDPCommunicationError", 400], [jc]: Gc, [qc]: 400 }, [Vc], [0]]; k.for(yt).registerError(txe, Gh); rxe = [-3, yt, hdt, { [Hc]: ["IDPRejectedClaim", 403], [jc]: Gc, [qc]: 403 }, [Vc], [0]]; k.for(yt).registerError(rxe, Uh); oxe = [-3, yt, gdt, { [Hc]: ["InvalidIdentityToken", 400], [jc]: Gc, [qc]: 400 }, [Vc], [0]]; k.for(yt).registerError(oxe, Hh); nxe = [-3, yt, Edt, { [Hc]: ["MalformedPolicyDocument", 400], [jc]: Gc, [qc]: 400 }, [Vc], [0]]; k.for(yt).registerError(nxe, Mh); sxe = [-3, yt, Tdt, { [Hc]: ["PackedPolicyTooLarge", 400], [jc]: Gc, [qc]: 400 }, [Vc], [0]]; k.for(yt).registerError(sxe, $h); ixe = [3, yt, Rdt, 0, [$dt], [0]], axe = [3, yt, Cdt, 0, [ydt, udt], [0, 0]], cxe = [-3, yt, bdt, { [Hc]: ["RegionDisabledException", 403], [jc]: Gc, [qc]: 403 }, [Vc], [0]]; k.for(yt).registerError(cxe, Fh); pxe = [3, yt, Bdt, 0, [xdt, Ldt], [0, 0]], uxe = [-3, Qge, "STSServiceException", 0, [], []]; k.for(Qge).registerError(uxe, Fo); mxe = [1, yt, Hdt, 0, () => ixe], Vdt = [1, yt, _dt, 0, () => axe], zdt = [1, yt, Gdt, 0, () => pxe], kL = [9, yt, rdt, 0, () => Yge, () => Xge], NL = [9, yt, idt, 0, () => Jge, () => Zge] }); var zc, CC = s(() => { _a(); Xt(); yC(); _C(); zc = class extends $o.classBuilder().ep(EC).m(function (t, r, o, n) { return [Sa(o, t.getEndpointParameterInstructions())] }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").sc(kL).build() { } }); var Wc, RC = s(() => { _a(); Xt(); yC(); _C(); Wc = class extends $o.classBuilder().ep(EC).m(function (t, r, o, n) { return [Sa(o, t.getEndpointParameterInstructions())] }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").sc(NL).build() { } }); var Wdt, AC, lxe = s(() => { Xt(); CC(); RC(); Bh(); Wdt = { AssumeRoleCommand: zc, AssumeRoleWithWebIdentityCommand: Wc }, AC = class extends js { }; cm(Wdt, AC) }); var dxe = s(() => { CC(); RC() }); var fxe = s(() => { }); var hxe, gxe, xxe, Exe, yxe, Sxe = s(() => { He(); ps(); CC(); RC(); hxe = e => { if (typeof e?.Arn == "string") { let t = e.Arn.split(":"); if (t.length > 4 && t[4] !== "") return t[4] } }, gxe = async (e, t, r, o = {}) => { let n = typeof e == "function" ? await e() : e, i = typeof t == "function" ? await t() : t, a = "", c = n ?? i ?? (a = await dde(o)()); return r?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${n} (credential provider clientConfig)`, `${i} (contextual client)`, `${a} (STS default: AWS_REGION, profile region, or us-east-1)`), c }, xxe = (e, t) => { let r, o; return async (n, i) => { if (o = n, !r) { let { logger: l = e?.parentClientConfig?.logger, profile: m = e?.parentClientConfig?.profile, region: f, requestHandler: h = e?.parentClientConfig?.requestHandler, credentialProviderLogger: E, userAgentAppId: S = e?.parentClientConfig?.userAgentAppId } = e, y = await gxe(f, e?.parentClientConfig?.region, E, { logger: l, profile: m }), C = !yxe(h); r = new t({ ...e, userAgentAppId: S, profile: m, credentialDefaultProvider: () => async () => o, region: y, requestHandler: C ? h : void 0, logger: l }) } let { Credentials: a, AssumedRoleUser: c } = await r.send(new zc(i)); if (!a || !a.AccessKeyId || !a.SecretAccessKey) throw new Error(`Invalid response from STS.assumeRole call with role ${i.RoleArn}`); let p = hxe(c), u = { accessKeyId: a.AccessKeyId, secretAccessKey: a.SecretAccessKey, sessionToken: a.SessionToken, expiration: a.Expiration, ...a.CredentialScope && { credentialScope: a.CredentialScope }, ...p && { accountId: p } }; return ee(u, "CREDENTIALS_STS_ASSUME_ROLE", "i"), u } }, Exe = (e, t) => { let r; return async o => { if (!r) { let { logger: p = e?.parentClientConfig?.logger, profile: u = e?.parentClientConfig?.profile, region: l, requestHandler: m = e?.parentClientConfig?.requestHandler, credentialProviderLogger: f, userAgentAppId: h = e?.parentClientConfig?.userAgentAppId } = e, E = await gxe(l, e?.parentClientConfig?.region, f, { logger: p, profile: u }), S = !yxe(m); r = new t({ ...e, userAgentAppId: h, profile: u, region: E, requestHandler: S ? m : void 0, logger: p }) } let { Credentials: n, AssumedRoleUser: i } = await r.send(new Wc(o)); if (!n || !n.AccessKeyId || !n.SecretAccessKey) throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${o.RoleArn}`); let a = hxe(i), c = { accessKeyId: n.AccessKeyId, secretAccessKey: n.SecretAccessKey, sessionToken: n.SessionToken, expiration: n.Expiration, ...n.CredentialScope && { credentialScope: n.CredentialScope }, ...a && { accountId: a } }; return a && ee(c, "RESOLVED_ACCOUNT_ID", "T"), ee(c, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"), c } }, yxe = e => e?.metadata?.handlerProtocol === "h2" }); var _xe, Cxe, Rxe, Kdt, Axe = s(() => { Sxe(); Bh(); _xe = (e, t) => t ? class extends e { constructor(o) { super(o); for (let n of t) this.middlewareStack.use(n) } } : e, Cxe = (e = {}, t) => xxe(e, _xe(js, t)), Rxe = (e = {}, t) => Exe(e, _xe(js, t)), Kdt = e => t => e({ roleAssumer: Cxe(t), roleAssumerWithWebIdentity: Rxe(t), ...t }) }); var Kc = {}; Qe(Kc, { $Command: () => $o, AssumeRole$: () => kL, AssumeRoleCommand: () => zc, AssumeRoleRequest$: () => Yge, AssumeRoleResponse$: () => Xge, AssumeRoleWithWebIdentity$: () => NL, AssumeRoleWithWebIdentityCommand: () => Wc, AssumeRoleWithWebIdentityRequest$: () => Jge, AssumeRoleWithWebIdentityResponse$: () => Zge, AssumedRoleUser$: () => OL, Credentials$: () => DL, ExpiredTokenException: () => Lh, ExpiredTokenException$: () => exe, IDPCommunicationErrorException: () => Gh, IDPCommunicationErrorException$: () => txe, IDPRejectedClaimException: () => Uh, IDPRejectedClaimException$: () => rxe, InvalidIdentityTokenException: () => Hh, InvalidIdentityTokenException$: () => oxe, MalformedPolicyDocumentException: () => Mh, MalformedPolicyDocumentException$: () => nxe, PackedPolicyTooLargeException: () => $h, PackedPolicyTooLargeException$: () => sxe, PolicyDescriptorType$: () => ixe, ProvidedContext$: () => axe, RegionDisabledException: () => Fh, RegionDisabledException$: () => cxe, STS: () => AC, STSClient: () => js, STSServiceException: () => Fo, STSServiceException$: () => uxe, Tag$: () => pxe, __Client: () => cs, decorateDefaultCredentialProvider: () => Kdt, getDefaultRoleAssumer: () => Cxe, getDefaultRoleAssumerWithWebIdentity: () => Rxe }); var Qc = s(() => { Bh(); lxe(); dxe(); _C(); bL(); fxe(); Axe(); SC() }); var wxe, Qdt, Ydt, bxe, Txe, Ixe = s(() => { He(); Z(); Xo(); sge(); wxe = (e, { profile: t = "default", logger: r } = {}) => !!e && typeof e == "object" && typeof e.role_arn == "string" && ["undefined", "string"].indexOf(typeof e.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof e.external_id) > -1 && ["undefined", "string"].indexOf(typeof e.mfa_serial) > -1 && (Qdt(e, { profile: t, logger: r }) || Ydt(e, { profile: t, logger: r })), Qdt = (e, { profile: t, logger: r }) => { let o = typeof e.source_profile == "string" && typeof e.credential_source > "u"; return o && r?.debug?.(`    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`), o }, Ydt = (e, { profile: t, logger: r }) => { let o = typeof e.credential_source == "string" && typeof e.source_profile > "u"; return o && r?.debug?.(`    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`), o }, bxe = async (e, t, r, o, n = {}, i) => { r.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)"); let a = t[e], { source_profile: c, region: p } = a; if (!r.roleAssumer) { let { getDefaultRoleAssumer: l } = await Promise.resolve().then(() => (Qc(), Kc)); r.roleAssumer = l({ ...r.clientConfig, credentialProviderLogger: r.logger, parentClientConfig: { ...o, ...r?.parentClientConfig, region: p ?? r?.parentClientConfig?.region ?? o?.region } }, r.clientPlugins) } if (c && c in n) throw new I(`Detected a cycle attempting to resolve credentials for profile ${Sn(r)}. Profiles visited: ` + Object.keys(n).join(", "), { logger: r.logger }); r.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${c ? `source_profile=[${c}]` : `profile=[${e}]`}`); let u = c ? i(c, t, r, o, { ...n, [c]: !0 }, Txe(t[c] ?? {})) : (await nge(a.credential_source, e, r.logger)(r))(); if (Txe(a)) return u.then(l => ee(l, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")); { let l = { RoleArn: a.role_arn, RoleSessionName: a.role_session_name || `aws-sdk-js-${Date.now()}`, ExternalId: a.external_id, DurationSeconds: parseInt(a.duration_seconds || "3600", 10) }, { mfa_serial: m } = a; if (m) { if (!r.mfaCodeProvider) throw new I(`Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`, { logger: r.logger, tryNextLink: !1 }); l.SerialNumber = m, l.TokenCode = await r.mfaCodeProvider(m) } let f = await u; return r.roleAssumer(f, l).then(h => ee(h, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")) } }, Txe = e => !e.role_arn && !!e.credential_source }); import { homedir as Xdt } from "os"; import { sep as Jdt } from "path"; var BL, Zdt, Um, jh = s(() => { BL = {}, Zdt = () => process && process.geteuid ? `${process.geteuid()}` : "DEFAULT", Um = () => { let { HOME: e, USERPROFILE: t, HOMEPATH: r, HOMEDRIVE: o = `C:${Jdt}` } = process.env; if (e) return e; if (t) return t; if (r) return `${o}${r}`; let n = Zdt(); return BL[n] || (BL[n] = Xdt()), BL[n] } }); var eft, tft, vxe, Pxe = s(() => { eft = "AWS_PROFILE", tft = "default", vxe = e => e.profile || process.env[eft] || tft }); var Oxe = s(() => { }); var Dxe = s(() => { }); var kxe, Nxe = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(kxe || (kxe = {})) }); var Bxe, Lxe = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Bxe || (Bxe = {})) }); var Mxe = s(() => { }); var $xe = s(() => { }); var Fxe = s(() => { }); var Uxe = s(() => { }); var Hxe = s(() => { Nxe(); Lxe(); Mxe(); $xe(); Fxe(); Uxe() }); var Gxe = s(() => { }); var jxe = s(() => { }); var qxe = s(() => { }); var Vxe = s(() => { }); var zxe = s(() => { }); var Wxe = s(() => { }); var Kxe = s(() => { }); var Qxe = s(() => { zxe(); Wxe(); Kxe() }); var Yxe = s(() => { }); var Xxe = s(() => { }); var Jxe, Zxe = s(() => { (function (e) { e.HTTP = "http", e.HTTPS = "https" })(Jxe || (Jxe = {})) }); var eEe = s(() => { }); var tEe = s(() => { }); var rEe = s(() => { }); var oEe = s(() => { }); var nEe = s(() => { }); var sEe = s(() => { eEe(); tEe(); rEe(); oEe(); nEe() }); var iEe = s(() => { }); var aEe = s(() => { }); var cEe = s(() => { }); var pEe = s(() => { aEe(); cEe() }); var uEe = s(() => { }); var mEe, lEe = s(() => { (function (e) { e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER" })(mEe || (mEe = {})) }); var dEe = s(() => { }); var fEe = s(() => { }); var hEe = s(() => { }); var gEe = s(() => { }); var xEe = s(() => { }); var EEe = s(() => { fEe(); hEe(); gEe(); xEe() }); var yEe = s(() => { }); var SEe = s(() => { }); var _Ee = s(() => { }); var Yc, CEe = s(() => { (function (e) { e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services" })(Yc || (Yc = {})) }); var REe = s(() => { }); var AEe = s(() => { }); var TEe = s(() => { }); var wEe = s(() => { }); var bEe = s(() => { }); var IEe = s(() => { }); var vEe = s(() => { }); var PEe = s(() => { }); var OEe = s(() => { }); var DEe = s(() => { }); var kEe = s(() => { }); var NEe = s(() => { }); var BEe = s(() => { }); var LEe = s(() => { }); var MEe, $Ee = s(() => { (function (e) { e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0" })(MEe || (MEe = {})) }); var FEe = s(() => { }); var UEe = s(() => { }); var HEe = s(() => { }); var GEe = s(() => { }); var jEe = s(() => { }); var qEe = s(() => { }); var VEe = s(() => { }); var LL = s(() => { Dxe(); Hxe(); Gxe(); jxe(); qxe(); Vxe(); Qxe(); Yxe(); Xxe(); Zxe(); sEe(); iEe(); pEe(); uEe(); lEe(); dEe(); EEe(); yEe(); SEe(); _Ee(); CEe(); REe(); AEe(); TEe(); wEe(); bEe(); IEe(); vEe(); PEe(); OEe(); DEe(); kEe(); NEe(); BEe(); LEe(); $Ee(); FEe(); UEe(); HEe(); GEe(); jEe(); qEe(); VEe() }); var Hm, ML = s(() => { Hm = "." }); var zEe, WEe = s(() => { LL(); ML(); zEe = e => Object.entries(e).filter(([t]) => { let r = t.indexOf(Hm); return r === -1 ? !1 : Object.values(Yc).includes(t.substring(0, r)) }).reduce((t, [r, o]) => { let n = r.indexOf(Hm), i = r.substring(0, n) === Yc.PROFILE ? r.substring(n + 1) : r; return t[i] = o, t }, { ...e.default && { default: e.default } }) }); import { join as rft } from "path"; var oft, KEe, QEe = s(() => { jh(); oft = "AWS_CONFIG_FILE", KEe = () => process.env[oft] || rft(Um(), ".aws", "config") }); import { join as nft } from "path"; var sft, YEe, XEe = s(() => { jh(); sft = "AWS_SHARED_CREDENTIALS_FILE", YEe = () => process.env[sft] || nft(Um(), ".aws", "credentials") }); var ift, aft, $L, JEe = s(() => { LL(); ML(); ift = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/, aft = ["__proto__", "profile __proto__"], $L = e => { let t = {}, r, o; for (let n of e.split(/\r?\n/)) { let i = n.split(/(^|\s)[;#]/)[0].trim(); if (i[0] === "[" && i[i.length - 1] === "]") { r = void 0, o = void 0; let c = i.substring(1, i.length - 1), p = ift.exec(c); if (p) { let [, u, , l] = p; Object.values(Yc).includes(u) && (r = [u, l].join(Hm)) } else r = c; if (aft.includes(c)) throw new Error(`Found invalid profile name "${c}"`) } else if (r) { let c = i.indexOf("="); if (![0, -1].includes(c)) { let [p, u] = [i.substring(0, c).trim(), i.substring(c + 1).trim()]; if (u === "") o = p; else { o && n.trimStart() === n && (o = void 0), t[r] = t[r] || {}; let l = o ? [o, p].join(Hm) : p; t[r][l] = u } } } } return t } }); import { readFile as cft } from "node:fs/promises"; var FL, ZEe, Gm, UL = s(() => { FL = {}, ZEe = {}, Gm = (e, t) => ZEe[e] !== void 0 ? ZEe[e] : ((!FL[e] || t?.ignoreCache) && (FL[e] = cft(e, "utf8")), FL[e]) }); import { join as eye } from "path"; var tye, rye, HL = s(() => { WEe(); QEe(); XEe(); jh(); JEe(); UL(); tye = () => ({}), rye = async (e = {}) => { let { filepath: t = YEe(), configFilepath: r = KEe() } = e, o = Um(), n = "~/", i = t; t.startsWith(n) && (i = eye(o, t.slice(2))); let a = r; r.startsWith(n) && (a = eye(o, r.slice(2))); let c = await Promise.all([Gm(a, { ignoreCache: e.ignoreCache }).then($L).then(zEe).catch(tye), Gm(i, { ignoreCache: e.ignoreCache }).then($L).catch(tye)]); return { configFile: c[0], credentialsFile: c[1] } } }); var oye = s(() => { }); var nye, sye = s(() => { nye = (...e) => { let t = {}; for (let r of e) for (let [o, n] of Object.entries(r)) t[o] !== void 0 ? Object.assign(t[o], n) : t[o] = n; return t } }); var iye, aye = s(() => { HL(); sye(); iye = async e => { let t = await rye(e); return nye(t.configFile, t.credentialsFile) } }); var cye = s(() => { }); var GL = s(() => { jh(); Pxe(); Oxe(); HL(); oye(); aye(); cye(); UL() }); var pye = s(() => { }); var uye = s(() => { pye() }); var mye = s(() => { }); var lye = s(() => { }); var dye = s(() => { }); function pft(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var TC, fye = s(() => { TC = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = pft(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var hye = s(() => { }); var gye = s(() => { }); var xye = s(() => { }); var Eye = s(() => { uye(); mye(); lye(); dye(); fye(); hye(); gye(); xye() }); function uft(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "signin", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } function mft(e) { return { schemeId: "smithy.api#noAuth" } } var yye, Sye, _ye, jL = s(() => { Ye(); gt(); yye = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }); Sye = e => { let t = []; switch (e.operation) { case "CreateOAuth2Token": { t.push(mft(e)); break } default: t.push(uft(e)) }return t }, _ye = e => { let t = qr(e); return Object.assign(t, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var Cye, Rye, qL = s(() => { Cye = e => Object.assign(e, { useDualstackEndpoint: e.useDualstackEndpoint ?? !1, useFipsEndpoint: e.useFipsEndpoint ?? !1, defaultSigningName: "signin" }), Rye = { UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" } } }); var Oye, fo, ho, vi, Aye, Xc, jm, Na, ls, IC, VL, Tye, wye, bye, zL, WL, lo, KL, wC, bC, Iye, vye, Pye, lft, Dye, kye = s(() => { Oye = "required", fo = "fn", ho = "argv", vi = "ref", Aye = "isSet", Xc = "booleanEquals", jm = "error", Na = "endpoint", ls = "tree", IC = "PartitionResult", VL = "stringEquals", Tye = { [Oye]: !0, default: !1, type: "boolean" }, wye = { [Oye]: !1, type: "string" }, bye = { [vi]: "Endpoint" }, zL = { [fo]: Xc, [ho]: [{ [vi]: "UseFIPS" }, !0] }, WL = { [fo]: Xc, [ho]: [{ [vi]: "UseDualStack" }, !0] }, lo = {}, KL = { [fo]: "getAttr", [ho]: [{ [vi]: IC }, "name"] }, wC = { [fo]: Xc, [ho]: [{ [vi]: "UseFIPS" }, !1] }, bC = { [fo]: Xc, [ho]: [{ [vi]: "UseDualStack" }, !1] }, Iye = { [fo]: "getAttr", [ho]: [{ [vi]: IC }, "supportsFIPS"] }, vye = { [fo]: Xc, [ho]: [!0, { [fo]: "getAttr", [ho]: [{ [vi]: IC }, "supportsDualStack"] }] }, Pye = [{ [vi]: "Region" }], lft = { version: "1.0", parameters: { UseDualStack: Tye, UseFIPS: Tye, Endpoint: wye, Region: wye }, rules: [{ conditions: [{ [fo]: Aye, [ho]: [bye] }], rules: [{ conditions: [zL], error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: jm }, { rules: [{ conditions: [WL], error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: jm }, { endpoint: { url: bye, properties: lo, headers: lo }, type: Na }], type: ls }], type: ls }, { rules: [{ conditions: [{ [fo]: Aye, [ho]: Pye }], rules: [{ conditions: [{ [fo]: "aws.partition", [ho]: Pye, assign: IC }], rules: [{ conditions: [{ [fo]: VL, [ho]: [KL, "aws"] }, wC, bC], endpoint: { url: "https://{Region}.signin.aws.amazon.com", properties: lo, headers: lo }, type: Na }, { conditions: [{ [fo]: VL, [ho]: [KL, "aws-cn"] }, wC, bC], endpoint: { url: "https://{Region}.signin.amazonaws.cn", properties: lo, headers: lo }, type: Na }, { conditions: [{ [fo]: VL, [ho]: [KL, "aws-us-gov"] }, wC, bC], endpoint: { url: "https://{Region}.signin.amazonaws-us-gov.com", properties: lo, headers: lo }, type: Na }, { conditions: [zL, WL], rules: [{ conditions: [{ [fo]: Xc, [ho]: [!0, Iye] }, vye], rules: [{ endpoint: { url: "https://signin-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: lo, headers: lo }, type: Na }], type: ls }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: jm }], type: ls }, { conditions: [zL, bC], rules: [{ conditions: [{ [fo]: Xc, [ho]: [Iye, !0] }], rules: [{ endpoint: { url: "https://signin-fips.{Region}.{PartitionResult#dnsSuffix}", properties: lo, headers: lo }, type: Na }], type: ls }, { error: "FIPS is enabled but this partition does not support FIPS", type: jm }], type: ls }, { conditions: [wC, WL], rules: [{ conditions: [vye], rules: [{ endpoint: { url: "https://signin.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: lo, headers: lo }, type: Na }], type: ls }, { error: "DualStack is enabled but this partition does not support DualStack", type: jm }], type: ls }, { endpoint: { url: "https://signin.{Region}.{PartitionResult#dnsSuffix}", properties: lo, headers: lo }, type: Na }], type: ls }], type: ls }, { error: "Invalid Configuration: Missing Region", type: jm }], type: ls }] }, Dye = lft }); var dft, Nye, Bye = s(() => { mh(); Ft(); kye(); dft = new Rr({ size: 50, params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"] }), Nye = (e, t = {}) => dft.get(e, () => Ur(Dye, { endpointParams: e, logger: t.logger })); Rt.aws = Oc }); var Lye, Mye = s(() => { Ye(); yn(); Ie(); Xt(); zu(); F_(); Em(); jL(); Bye(); Lye = e => ({ apiVersion: "2023-01-01", base64Decoder: e?.base64Decoder ?? Cm, base64Encoder: e?.base64Encoder ?? Rm, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? Nye, extensions: e?.extensions ?? [], httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? Sye, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }, { schemeId: "smithy.api#noAuth", identityProvider: t => t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})), signer: new po }], logger: e?.logger ?? new Fs, protocol: e?.protocol ?? En, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.signin", version: "2023-01-01", serviceTarget: "Signin" }, serviceId: e?.serviceId ?? "Signin", urlParser: e?.urlParser ?? Tn, utf8Decoder: e?.utf8Decoder ?? Us, utf8Encoder: e?.utf8Encoder ?? xm }) }); var $ye, Fye = s(() => { R_(); Ye(); A_(); Ea(); T_(); kc(); ya(); I_(); Xt(); v_(); $_(); om(); Mye(); $ye = e => { um(process.version); let t = _m(e), r = () => t().then(pm), o = Lye(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, authSchemePreference: e?.authSchemePreference ?? tt(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? Sm, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? hm({ serviceId: o.serviceId, clientVersion: fm.version }), maxAttempts: e?.maxAttempts ?? tt(nm, e), region: e?.region ?? tt(xa, { ...Yu, ...n }), requestHandler: wa.create(e?.requestHandler ?? r), retryMode: e?.retryMode ?? tt({ ...im, default: async () => (await r()).retryMode || Ca }, e), sha256: e?.sha256 ?? Ta.bind(null, "sha256"), streamCollector: e?.streamCollector ?? ym, useDualstackEndpoint: e?.useDualstackEndpoint ?? tt(Ku, n), useFipsEndpoint: e?.useFipsEndpoint ?? tt(Qu, n), userAgentAppId: e?.userAgentAppId ?? tt(gm, n) } } }); var Uye, Hye, Gye = s(() => { Uye = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, Hye = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var jye, qye = s(() => { ps(); Ms(); Xt(); Gye(); jye = (e, t) => { let r = Object.assign(Vr(e), mm(e), $u(e), Uye(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), lm(r), Fu(r), Hye(r)) } }); var qh, QL = s(() => { n_(); s_(); i_(); lh(); Ea(); Ie(); Oe(); m_(); _a(); kc(); Xt(); jL(); qL(); Fye(); qye(); qh = class extends cs { config; constructor(...[t]) { let r = $ye(t || {}); super(r), this.initConfig = r; let o = Cye(r), n = Vu(o), i = sm(n), a = Xu(i), c = a, p = em(c), u = _ye(p), l = jye(u, t?.extensions || []); this.config = l, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(Wu(this.config)), this.middlewareStack.use(dm(this.config)), this.middlewareStack.use(Ju(this.config)), this.middlewareStack.use(Gu(this.config)), this.middlewareStack.use(ju(this.config)), this.middlewareStack.use(qu(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: yye, identityProviderConfigProvider: async m => new Cr({ "aws.auth#sigv4": m.credentials }) })), this.middlewareStack.use($r(this.config)) } destroy() { super.destroy() } } }); var ds, vC = s(() => { Xt(); ds = class e extends Aa { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var Vh, zh, Wh, Kh, YL = s(() => { vC(); Vh = class e extends ds { name = "AccessDeniedException"; $fault = "client"; error; constructor(t) { super({ name: "AccessDeniedException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error } }, zh = class e extends ds { name = "InternalServerException"; $fault = "server"; error; constructor(t) { super({ name: "InternalServerException", $fault: "server", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error } }, Wh = class e extends ds { name = "TooManyRequestsError"; $fault = "client"; error; constructor(t) { super({ name: "TooManyRequestsError", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error } }, Kh = class e extends ds { name = "ValidationException"; $fault = "client"; error; constructor(t) { super({ name: "ValidationException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.error = t.error } } }); var fft, hft, gft, xft, Eft, yft, Sft, _ft, Cft, Rft, Aft, Vye, zye, XL, Wye, Kye, Tft, Ba, Qye, Yye, wft, JL, Xye, en, OC, PC, Jye, bft, Zye, eSe, rSe, Ift, vft, tSe, Co, oSe, nSe, sSe, iSe, aSe, cSe, pSe, uSe, mSe, lSe, dSe, ZL, eM = s(() => { Oe(); YL(); vC(); fft = "AccessDeniedException", hft = "AccessToken", gft = "CreateOAuth2Token", xft = "CreateOAuth2TokenRequest", Eft = "CreateOAuth2TokenRequestBody", yft = "CreateOAuth2TokenResponseBody", Sft = "CreateOAuth2TokenResponse", _ft = "InternalServerException", Cft = "RefreshToken", Rft = "TooManyRequestsError", Aft = "ValidationException", Vye = "accessKeyId", zye = "accessToken", XL = "client", Wye = "clientId", Kye = "codeVerifier", Tft = "code", Ba = "error", Qye = "expiresIn", Yye = "grantType", wft = "http", JL = "httpError", Xye = "idToken", en = "jsonName", OC = "message", PC = "refreshToken", Jye = "redirectUri", bft = "server", Zye = "secretAccessKey", eSe = "sessionToken", rSe = "smithy.ts.sdk.synthetic.com.amazonaws.signin", Ift = "tokenInput", vft = "tokenOutput", tSe = "tokenType", Co = "com.amazonaws.signin", oSe = [0, Co, Cft, 8, 0], nSe = [-3, Co, fft, { [Ba]: XL }, [Ba, OC], [0, 0]]; k.for(Co).registerError(nSe, Vh); sSe = [3, Co, hft, 8, [Vye, Zye, eSe], [[0, { [en]: Vye }], [0, { [en]: Zye }], [0, { [en]: eSe }]]], iSe = [3, Co, xft, 0, [Ift], [[() => aSe, 16]]], aSe = [3, Co, Eft, 0, [Wye, Yye, Tft, Jye, Kye, PC], [[0, { [en]: Wye }], [0, { [en]: Yye }], 0, [0, { [en]: Jye }], [0, { [en]: Kye }], [() => oSe, { [en]: PC }]]], cSe = [3, Co, Sft, 0, [vft], [[() => pSe, 16]]], pSe = [3, Co, yft, 0, [zye, tSe, Qye, PC, Xye], [[() => sSe, { [en]: zye }], [0, { [en]: tSe }], [1, { [en]: Qye }], [() => oSe, { [en]: PC }], [0, { [en]: Xye }]]], uSe = [-3, Co, _ft, { [Ba]: bft, [JL]: 500 }, [Ba, OC], [0, 0]]; k.for(Co).registerError(uSe, zh); mSe = [-3, Co, Rft, { [Ba]: XL, [JL]: 429 }, [Ba, OC], [0, 0]]; k.for(Co).registerError(mSe, Wh); lSe = [-3, Co, Aft, { [Ba]: XL, [JL]: 400 }, [Ba, OC], [0, 0]]; k.for(Co).registerError(lSe, Kh); dSe = [-3, rSe, "SigninServiceException", 0, [], []]; k.for(rSe).registerError(dSe, ds); ZL = [9, Co, gft, { [wft]: ["POST", "/v1/token", 200] }, () => iSe, () => cSe] }); var Qh, tM = s(() => { _a(); Xt(); qL(); eM(); Qh = class extends $o.classBuilder().ep(Rye).m(function (t, r, o, n) { return [Sa(o, t.getEndpointParameterInstructions())] }).s("Signin", "CreateOAuth2Token", {}).n("SigninClient", "CreateOAuth2TokenCommand").sc(ZL).build() { } }); var Pft, DC, fSe = s(() => { Xt(); tM(); QL(); Pft = { CreateOAuth2TokenCommand: Qh }, DC = class extends qh { }; cm(Pft, DC) }); var hSe = s(() => { tM() }); var Oft, gSe = s(() => { Oft = { AUTHCODE_EXPIRED: "AUTHCODE_EXPIRED", INSUFFICIENT_PERMISSIONS: "INSUFFICIENT_PERMISSIONS", INVALID_REQUEST: "INVALID_REQUEST", SERVER_ERROR: "server_error", TOKEN_EXPIRED: "TOKEN_EXPIRED", USER_CREDENTIALS_CHANGED: "USER_CREDENTIALS_CHANGED" } }); var xSe = s(() => { }); var ESe = {}; Qe(ESe, { $Command: () => $o, AccessDeniedException: () => Vh, AccessDeniedException$: () => nSe, AccessToken$: () => sSe, CreateOAuth2Token$: () => ZL, CreateOAuth2TokenCommand: () => Qh, CreateOAuth2TokenRequest$: () => iSe, CreateOAuth2TokenRequestBody$: () => aSe, CreateOAuth2TokenResponse$: () => cSe, CreateOAuth2TokenResponseBody$: () => pSe, InternalServerException: () => zh, InternalServerException$: () => uSe, OAuth2ErrorCode: () => Oft, Signin: () => DC, SigninClient: () => qh, SigninServiceException: () => ds, SigninServiceException$: () => dSe, TooManyRequestsError: () => Wh, TooManyRequestsError$: () => mSe, ValidationException: () => Kh, ValidationException$: () => lSe, __Client: () => cs }); var ySe = s(() => { QL(); fSe(); hSe(); eM(); gSe(); YL(); xSe(); vC() }); import { createHash as Dft, createPrivateKey as kft, createPublicKey as Nft, sign as Bft } from "node:crypto"; import { promises as rM } from "node:fs"; import { homedir as Lft } from "node:os"; import { dirname as Mft, join as SSe } from "node:path"; var kC, _Se = s(() => { Z(); Eye(); GL(); kC = class e { profileData; init; callerClientConfig; static REFRESH_THRESHOLD = 5 * 60 * 1e3; constructor(t, r, o) { this.profileData = t, this.init = r, this.callerClientConfig = o } async loadCredentials() { let t = await this.loadToken(); if (!t) throw new I(`Failed to load a token for session ${this.loginSession}, please re-authenticate using aws login`, { tryNextLink: !1, logger: this.logger }); let r = t.accessToken, o = Date.now(); return new Date(r.expiresAt).getTime() - o <= e.REFRESH_THRESHOLD ? this.refresh(t) : { accessKeyId: r.accessKeyId, secretAccessKey: r.secretAccessKey, sessionToken: r.sessionToken, accountId: r.accountId, expiration: new Date(r.expiresAt) } } get logger() { return this.init?.logger } get loginSession() { return this.profileData.login_session } async refresh(t) { let { SigninClient: r, CreateOAuth2TokenCommand: o } = await Promise.resolve().then(() => (ySe(), ESe)), { logger: n, userAgentAppId: i } = this.callerClientConfig ?? {}, c = (m => m?.metadata?.handlerProtocol === "h2")(this.callerClientConfig?.requestHandler) ? void 0 : this.callerClientConfig?.requestHandler, p = this.profileData.region ?? await this.callerClientConfig?.region?.() ?? process.env.AWS_REGION, u = new r({ credentials: { accessKeyId: "", secretAccessKey: "" }, region: p, requestHandler: c, logger: n, userAgentAppId: i, ...this.init?.clientConfig }); this.createDPoPInterceptor(u.middlewareStack); let l = { tokenInput: { clientId: t.clientId, refreshToken: t.refreshToken, grantType: "refresh_token" } }; try { let m = await u.send(new o(l)), { accessKeyId: f, secretAccessKey: h, sessionToken: E } = m.tokenOutput?.accessToken ?? {}, { refreshToken: S, expiresIn: y } = m.tokenOutput ?? {}; if (!f || !h || !E || !S) throw new I("Token refresh response missing required fields", { logger: this.logger, tryNextLink: !1 }); let C = (y ?? 900) * 1e3, b = new Date(Date.now() + C), L = { ...t, accessToken: { ...t.accessToken, accessKeyId: f, secretAccessKey: h, sessionToken: E, expiresAt: b.toISOString() }, refreshToken: S }; await this.saveToken(L); let N = L.accessToken; return { accessKeyId: N.accessKeyId, secretAccessKey: N.secretAccessKey, sessionToken: N.sessionToken, accountId: N.accountId, expiration: b } } catch (m) { if (m.name === "AccessDeniedException") { let f = m.error, h; switch (f) { case "TOKEN_EXPIRED": h = "Your session has expired. Please reauthenticate."; break; case "USER_CREDENTIALS_CHANGED": h = "Unable to refresh credentials because of a change in your password. Please reauthenticate with your new password."; break; case "INSUFFICIENT_PERMISSIONS": h = "Unable to refresh credentials due to insufficient permissions. You may be missing permission for the 'CreateOAuth2Token' action."; break; default: h = `Failed to refresh token: ${String(m)}. Please re-authenticate using \`aws login\`` }throw new I(h, { logger: this.logger, tryNextLink: !1 }) } throw new I(`Failed to refresh token: ${String(m)}. Please re-authenticate using aws login`, { logger: this.logger }) } } async loadToken() { let t = this.getTokenFilePath(); try { let r; try { r = await Gm(t, { ignoreCache: this.init?.ignoreCache }) } catch { r = await rM.readFile(t, "utf8") } let o = JSON.parse(r), n = ["accessToken", "clientId", "refreshToken", "dpopKey"].filter(i => !o[i]); if (o.accessToken?.accountId || n.push("accountId"), n.length > 0) throw new I(`Token validation failed, missing fields: ${n.join(", ")}`, { logger: this.logger, tryNextLink: !1 }); return o } catch (r) { throw new I(`Failed to load token from ${t}: ${String(r)}`, { logger: this.logger, tryNextLink: !1 }) } } async saveToken(t) { let r = this.getTokenFilePath(), o = Mft(r); try { await rM.mkdir(o, { recursive: !0 }) } catch { } await rM.writeFile(r, JSON.stringify(t, null, 2), "utf8") } getTokenFilePath() { let t = process.env.AWS_LOGIN_CACHE_DIRECTORY ?? SSe(Lft(), ".aws", "login", "cache"), r = Buffer.from(this.loginSession, "utf8"), o = Dft("sha256").update(r).digest("hex"); return SSe(t, `${o}.json`) } derToRawSignature(t) { let r = 2; if (t[r] !== 2) throw new Error("Invalid DER signature"); r++; let o = t[r++], n = t.subarray(r, r + o); if (r += o, t[r] !== 2) throw new Error("Invalid DER signature"); r++; let i = t[r++], a = t.subarray(r, r + i); n = n[0] === 0 ? n.subarray(1) : n, a = a[0] === 0 ? a.subarray(1) : a; let c = Buffer.concat([Buffer.alloc(32 - n.length), n]), p = Buffer.concat([Buffer.alloc(32 - a.length), a]); return Buffer.concat([c, p]) } createDPoPInterceptor(t) { t.add(r => async o => { if (TC.isInstance(o.request)) { let n = o.request, i = `${n.protocol}//${n.hostname}${n.port ? `:${n.port}` : ""}${n.path}`, a = await this.generateDpop(n.method, i); n.headers = { ...n.headers, DPoP: a } } return r(o) }, { step: "finalizeRequest", name: "dpopInterceptor", override: !0 }) } async generateDpop(t = "POST", r) { let o = await this.loadToken(); try { let n = kft({ key: o.dpopKey, format: "pem", type: "sec1" }), a = Nft(n).export({ format: "der", type: "spki" }), c = -1; for (let b = 0; b < a.length; b++)if (a[b] === 4) { c = b; break } let p = a.slice(c + 1, c + 33), u = a.slice(c + 33, c + 65), l = { alg: "ES256", typ: "dpop+jwt", jwk: { kty: "EC", crv: "P-256", x: p.toString("base64url"), y: u.toString("base64url") } }, m = { jti: crypto.randomUUID(), htm: t, htu: r, iat: Math.floor(Date.now() / 1e3) }, f = Buffer.from(JSON.stringify(l)).toString("base64url"), h = Buffer.from(JSON.stringify(m)).toString("base64url"), E = `${f}.${h}`, S = Bft("sha256", Buffer.from(E), n), C = this.derToRawSignature(S).toString("base64url"); return `${E}.${C}` } catch (n) { throw new I(`Failed to generate Dpop proof: ${n instanceof Error ? n.message : String(n)}`, { logger: this.logger, tryNextLink: !1 }) } } } }); var qm, CSe = s(() => { He(); Z(); GL(); _Se(); qm = e => async ({ callerClientConfig: t } = {}) => { e?.logger?.debug?.("@aws-sdk/credential-providers - fromLoginCredentials"); let r = await iye(e || {}), o = vxe({ profile: e?.profile ?? t?.profile }), n = r[o]; if (!n?.login_session) throw new I(`Profile ${o} does not contain login_session.`, { tryNextLink: !0, logger: e?.logger }); let a = await new kC(n, e, t).loadCredentials(); return ee(a, "CREDENTIALS_LOGIN", "AD") } }); var RSe = s(() => { }); var NC = s(() => { CSe(); RSe() }); var ASe, TSe, wSe = s(() => { He(); NC(); ASe = e => !!(e && e.login_session), TSe = async (e, t, r) => { let o = await qm({ ...t, profile: e })({ callerClientConfig: r }); return ee(o, "CREDENTIALS_PROFILE_LOGIN", "AC") } }); var bSe, ISe = s(() => { He(); bSe = (e, t, r) => { if (t.Version !== 1) throw Error(`Profile ${e} credential_process did not return Version 1.`); if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0) throw Error(`Profile ${e} credential_process returned invalid credentials.`); if (t.Expiration) { let i = new Date; if (new Date(t.Expiration) < i) throw Error(`Profile ${e} credential_process returned expired credentials.`) } let o = t.AccountId; !o && r?.[e]?.aws_account_id && (o = r[e].aws_account_id); let n = { accessKeyId: t.AccessKeyId, secretAccessKey: t.SecretAccessKey, ...t.SessionToken && { sessionToken: t.SessionToken }, ...t.Expiration && { expiration: new Date(t.Expiration) }, ...t.CredentialScope && { credentialScope: t.CredentialScope }, ...o && { accountId: o } }; return ee(n, "CREDENTIALS_PROCESS", "w"), n } }); import { exec as $ft } from "child_process"; import { promisify as Fft } from "util"; var vSe, PSe = s(() => { Z(); Xo(); ISe(); vSe = async (e, t, r) => { let o = t[e]; if (t[e]) { let n = o.credential_process; if (n !== void 0) { let i = Fft(Gf?.getTokenRecord?.().exec ?? $ft); try { let { stdout: a } = await i(n), c; try { c = JSON.parse(a.trim()) } catch { throw Error(`Profile ${e} credential_process returned invalid JSON.`) } return bSe(e, c, t) } catch (a) { throw new I(a.message, { logger: r }) } } else throw new I(`Profile ${e} did not contain credential_process.`, { logger: r }) } else throw new I(`Profile ${e} could not be found in shared credentials file.`, { logger: r }) } }); var Uft, OSe = s(() => { Xo(); PSe(); Uft = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess"); let r = await ia(e); return vSe(Sn({ profile: e.profile ?? t?.profile }), r, e.logger) } }); var oM = {}; Qe(oM, { fromProcess: () => Uft }); var nM = s(() => { OSe() }); var DSe, kSe, NSe = s(() => { He(); DSe = e => !!e && typeof e == "object" && typeof e.credential_process == "string", kSe = async (e, t) => Promise.resolve().then(() => (nM(), oM)).then(({ fromProcess: r }) => r({ ...e, profile: t })().then(o => ee(o, "CREDENTIALS_PROFILE_PROCESS", "v"))) }); var BSe, LSe, MSe = s(() => { He(); BSe = async (e, t, r = {}, o) => { let { fromSSO: n } = await Promise.resolve().then(() => (CL(), _L)); return n({ profile: e, logger: r.logger, parentClientConfig: r.parentClientConfig, clientConfig: r.clientConfig })({ callerClientConfig: o }).then(i => t.sso_session ? ee(i, "CREDENTIALS_PROFILE_SSO", "r") : ee(i, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")) }, LSe = e => e && (typeof e.sso_start_url == "string" || typeof e.sso_account_id == "string" || typeof e.sso_session == "string" || typeof e.sso_region == "string" || typeof e.sso_role_name == "string") }); var sM, iM, $Se = s(() => { He(); sM = e => !!e && typeof e == "object" && typeof e.aws_access_key_id == "string" && typeof e.aws_secret_access_key == "string" && ["undefined", "string"].indexOf(typeof e.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof e.aws_account_id) > -1, iM = async (e, t) => { t?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials"); let r = { accessKeyId: e.aws_access_key_id, secretAccessKey: e.aws_secret_access_key, sessionToken: e.aws_session_token, ...e.aws_credential_scope && { credentialScope: e.aws_credential_scope }, ...e.aws_account_id && { accountId: e.aws_account_id } }; return ee(r, "CREDENTIALS_PROFILE", "n") } }); var aM, cM = s(() => { aM = e => async t => { e.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken"); let { roleArn: r, roleSessionName: o, webIdentityToken: n, providerId: i, policyArns: a, policy: c, durationSeconds: p } = e, { roleAssumerWithWebIdentity: u } = e; if (!u) { let { getDefaultRoleAssumerWithWebIdentity: l } = await Promise.resolve().then(() => (Qc(), Kc)); u = l({ ...e.clientConfig, credentialProviderLogger: e.logger, parentClientConfig: { ...t?.callerClientConfig, ...e.parentClientConfig } }, e.clientPlugins) } return u({ RoleArn: r, RoleSessionName: o ?? `aws-sdk-js-session-${Date.now()}`, WebIdentityToken: n, ProviderId: i, PolicyArns: a, Policy: c, DurationSeconds: p }) } }); import { readFileSync as Hft } from "fs"; var FSe, Gft, jft, qft, USe = s(() => { He(); Z(); Xo(); cM(); FSe = "AWS_WEB_IDENTITY_TOKEN_FILE", Gft = "AWS_ROLE_ARN", jft = "AWS_ROLE_SESSION_NAME", qft = (e = {}) => async t => { e.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile"); let r = e?.webIdentityTokenFile ?? process.env[FSe], o = e?.roleArn ?? process.env[Gft], n = e?.roleSessionName ?? process.env[jft]; if (!r || !o) throw new I("Web identity configuration not specified", { logger: e.logger }); let i = await aM({ ...e, webIdentityToken: Gf?.getTokenRecord?.()[r] ?? Hft(r, { encoding: "ascii" }), roleArn: o, roleSessionName: n })(t); return r === process.env[FSe] && ee(i, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h"), i } }); var pM = {}; Qe(pM, { fromTokenFile: () => qft, fromWebToken: () => aM }); var uM = s(() => { USe(); cM() }); var HSe, GSe, jSe = s(() => { He(); HSe = e => !!e && typeof e == "object" && typeof e.web_identity_token_file == "string" && typeof e.role_arn == "string" && ["undefined", "string"].indexOf(typeof e.role_session_name) > -1, GSe = async (e, t, r) => Promise.resolve().then(() => (uM(), pM)).then(({ fromTokenFile: o }) => o({ webIdentityTokenFile: e.web_identity_token_file, roleArn: e.role_arn, roleSessionName: e.role_session_name, roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity, logger: t.logger, parentClientConfig: t.parentClientConfig })({ callerClientConfig: r }).then(n => ee(n, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))) }); var mM, qSe = s(() => { Z(); Ixe(); wSe(); NSe(); MSe(); $Se(); jSe(); mM = async (e, t, r, o, n = {}, i = !1) => { let a = t[e]; if (Object.keys(n).length > 0 && sM(a)) return iM(a, r); if (i || wxe(a, { profile: e, logger: r.logger })) return bxe(e, t, r, o, n, mM); if (sM(a)) return iM(a, r); if (HSe(a)) return GSe(a, r, o); if (DSe(a)) return kSe(r, e); if (LSe(a)) return await BSe(e, a, r, o); if (ASe(a)) return TSe(e, r, o); throw new I(`Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`, { logger: r.logger }) } }); var Vft, VSe = s(() => { Xo(); qSe(); Vft = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-ini - fromIni"); let r = await ia(e); return mM(Sn({ profile: e.profile ?? t?.profile }), r, e, t) } }); var zSe = {}; Qe(zSe, { fromIni: () => Vft }); var WSe = s(() => { VSe() }); var KSe, QSe, zft, YSe = s(() => {
  EN(); Z(); Xo(); zne(); Kne(); KSe = !1, QSe = (e = {}) => Wne([async () => {
    if (e.profile ?? process.env[YD]) throw process.env[HS] && process.env[GS] && (KSe || ((e.logger?.warn && e.logger?.constructor?.name !== "NoOpLogger" ? e.logger.warn.bind(e.logger) : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`), KSe = !0)), new I("AWS_PROFILE is set, skipping fromEnv provider.", { logger: e.logger, tryNextLink: !0 }); return e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv"), xN(e)()
  }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO"); let { ssoStartUrl: r, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoSession: a } = e; if (!r && !o && !n && !i && !a) throw new I("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: e.logger }); let { fromSSO: c } = await Promise.resolve().then(() => (CL(), _L)); return c(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni"); let { fromIni: r } = await Promise.resolve().then(() => (WSe(), zSe)); return r(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess"); let { fromProcess: r } = await Promise.resolve().then(() => (nM(), oM)); return r(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile"); let { fromTokenFile: r } = await Promise.resolve().then(() => (uM(), pM)); return r(e)(t) }, async () => (e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"), (await Vne(e))()), async () => { throw new I("Could not load credentials from any providers", { tryNextLink: !1, logger: e.logger }) }], zft), zft = e => e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5
}); var XSe = s(() => { YSe() }); var JSe = s(() => { }); var ZSe = s(() => { }); var e_e = s(() => { }); var t_e = s(() => { }); var r_e = s(() => { }); var o_e = s(() => { }); var n_e = s(() => { }); var s_e = s(() => { }); var i_e = s(() => { }); var a_e = s(() => { }); var c_e = s(() => { }); var p_e = s(() => { c_e() }); var u_e = s(() => { }); var m_e = s(() => { }); var l_e = s(() => { }); var d_e = s(() => { }); var f_e = s(() => { }); var h_e = s(() => { }); var g_e = s(() => { }); var Yh, x_e = s(() => { Yh = e => { if (e == null) return {}; if (Array.isArray(e)) return e.filter(t => t != null).map(Yh); if (typeof e == "object") { let t = {}; for (let r of Object.keys(e)) e[r] != null && (t[r] = Yh(e[r])); return t } return e } }); var E_e = s(() => { JSe(); ZSe(); e_e(); t_e(); r_e(); n_e(); s_e(); i_e(); o_e(); a_e(); p_e(); u_e(); m_e(); l_e(); d_e(); f_e(); h_e(); g_e(); x_e(); Pr() }); import { Buffer as lM } from "buffer"; var y_e, BC, LC = s(() => { cr(); y_e = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return lM.from(e, t, r) }, BC = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? lM.from(e, t) : lM.from(e) } }); var Wft, S_e, __e = s(() => { LC(); Wft = /^[A-Za-z0-9+/]*={0,2}$/, S_e = e => { if (e.length * 3 % 4 !== 0) throw new TypeError("Incorrect padding on base64 string."); if (!Wft.exec(e)) throw new TypeError("Invalid base64 string."); let t = BC(e, "base64"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength) } }); var C_e, R_e = s(() => { LC(); C_e = e => { let t = BC(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var A_e = s(() => { }); var T_e = s(() => { }); var w_e = s(() => { R_e(); A_e(); T_e() }); var b_e, I_e = s(() => { LC(); w_e(); b_e = e => { let t; if (typeof e == "string" ? t = C_e(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return y_e(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var v_e = s(() => { __e(); I_e() }); var MC, P_e, dM, fM, O_e = s(() => { yn(); Oe(); E_e(); v_e(); MC = class extends oa { constructor() { super({ timestampFormat: { useTrait: !0, default: 7 }, jsonName: !1 }) } createSerializer() { let t = new dM(this.settings); return t.setSerdeContext(this.serdeContext), t } createDeserializer() { let t = new fM(this.settings); return t.setSerdeContext(this.serdeContext), t } }, P_e = "com.amazonaws.dynamodb#AttributeValue", dM = class extends lu { _write(t, r, o) { let n = ue.of(t); if (n.isStructSchema() && n.getName(!0) === P_e && r && typeof r == "object") { let i = r, a = Yh(i), c = this.serdeContext?.base64Encoder ?? b_e; if (i.B instanceof Uint8Array && (a.B = c(i.B)), Array.isArray(i.BS) && (a.BS = i.BS.map(c)), Array.isArray(i.L) && (a.L = i.L.filter(p => p != null).map(p => this._write(n, p, o))), i.M && typeof i.M == "object") { a.M = {}; for (let [p, u] of Object.entries(i.M)) u != null && (a.M[p] = this._write(n, u, o)) } return a } return super._write(n, r, o) } }, fM = class extends mu { _read(t, r) { let o = ue.of(t); if (o.isStructSchema() && o.getName(!0) === P_e && r && typeof r == "object") { let n = r, i = Yh(n), a = this.serdeContext?.base64Decoder ?? S_e; if (typeof n.B == "string" && (i.B = a(n.B)), Array.isArray(n.BS) && (i.BS = n.BS.map(a)), Array.isArray(n.L) && (i.L = n.L.map(c => this._read(o, c))), n.M && typeof n.M == "object") { i.M = {}; for (let [c, p] of Object.entries(n.M)) i.M[c] = this._read(o, p) } return i } return super._read(o, r) } } }); var D_e = s(() => { O_e() }); var xM, Re, dr, At, ge, xe, ze, $C, Vs, zs, Ws, eCe, fr, go, k_e, Uo, Ar, EM, Xh, N_e, B_e, Kft, L_e, tCe, M_e, $_e, Vm, F_e, rCe, U_e, Pi, H_e, G_e, hM, Jh, j_e, q_e, gM, V_e, z_e, W_e, K_e, Q_e, Y_e, X_e, J_e, Z_e, Qft, oCe, nCe = s(() => { xM = "required", Re = "type", dr = "rules", At = "conditions", ge = "fn", xe = "argv", ze = "ref", $C = "assign", Vs = "url", zs = "properties", Ws = "headers", eCe = "metricValues", fr = "error", go = "stringEquals", k_e = "https://dynamodb.{Region}.{PartitionResult#dualStackDnsSuffix}", Uo = "endpoint", Ar = "tree", EM = "dynamodb", Xh = { [xM]: !1, [Re]: "string" }, N_e = { [xM]: !0, default: !1, [Re]: "boolean" }, B_e = { [ge]: "isSet", [xe]: [{ [ze]: "Endpoint" }] }, Kft = { [ze]: "Endpoint" }, L_e = { [ge]: "isSet", [xe]: [{ [ze]: "Region" }] }, tCe = { [ze]: "Region" }, M_e = { [ge]: "aws.partition", [xe]: [tCe], [$C]: "PartitionResult" }, $_e = { [At]: [{ [ge]: "booleanEquals", [xe]: [{ [ze]: "UseFIPS" }, !0] }], [fr]: "Invalid Configuration: FIPS and custom endpoint are not supported", [Re]: fr }, Vm = { [ge]: "booleanEquals", [xe]: [{ [ze]: "UseFIPS" }, !0] }, F_e = { [At]: [{ [ge]: "booleanEquals", [xe]: [{ [ze]: "UseDualStack" }, !0] }], [fr]: "Invalid Configuration: Dualstack and custom endpoint are not supported", [Re]: fr }, rCe = { [ge]: "booleanEquals", [xe]: [{ [ze]: "UseDualStack" }, !0] }, U_e = { [Uo]: { [Vs]: "{Endpoint}", [zs]: {}, [Ws]: {} }, [Re]: Uo }, Pi = {}, H_e = { [ge]: "booleanEquals", [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "PartitionResult" }, "supportsFIPS"] }, !0] }, G_e = { [ge]: "booleanEquals", [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "PartitionResult" }, "supportsDualStack"] }, !0] }, hM = { [At]: [{ [ge]: "isSet", [xe]: [{ [ze]: "AccountIdEndpointMode" }] }, { [ge]: go, [xe]: [{ [ze]: "AccountIdEndpointMode" }, "required"] }], [dr]: [{ [fr]: "Invalid Configuration: AccountIdEndpointMode is required and FIPS is enabled, but FIPS account endpoints are not supported", [Re]: fr }], [Re]: Ar }, Jh = { [ge]: "getAttr", [xe]: [{ [ze]: "PartitionResult" }, "name"] }, j_e = { [Uo]: { [Vs]: "https://dynamodb.{Region}.{PartitionResult#dnsSuffix}", [zs]: {}, [Ws]: {} }, [Re]: Uo }, q_e = { [Vs]: "https://{ParsedArn#accountId}.ddb.{Region}.{PartitionResult#dualStackDnsSuffix}", [zs]: { [eCe]: ["O"] }, [Ws]: {} }, gM = { [eCe]: ["O"] }, V_e = { [fr]: "Credentials-sourced account ID parameter is invalid", [Re]: fr }, z_e = { [At]: [{ [ge]: "isSet", [xe]: [{ [ze]: "AccountIdEndpointMode" }] }, { [ge]: go, [xe]: [{ [ze]: "AccountIdEndpointMode" }, "required"] }], [dr]: [{ [At]: [{ [ge]: "not", [xe]: [Vm] }], [dr]: [{ [At]: [{ [ge]: go, [xe]: [Jh, "aws"] }], [dr]: [{ [fr]: "AccountIdEndpointMode is required but no AccountID was provided or able to be loaded", [Re]: fr }], [Re]: Ar }, { [fr]: "Invalid Configuration: AccountIdEndpointMode is required but account endpoints are not supported in this partition", [Re]: fr }], [Re]: Ar }, { [fr]: "Invalid Configuration: AccountIdEndpointMode is required and FIPS is enabled, but FIPS account endpoints are not supported", [Re]: fr }], [Re]: Ar }, W_e = { [Vs]: "https://{ParsedArn#accountId}.ddb.{Region}.{PartitionResult#dnsSuffix}", [zs]: gM, [Ws]: {} }, K_e = [Vm], Q_e = [rCe], Y_e = [{ [ge]: "isSet", [xe]: [{ [ze]: "AccountIdEndpointMode" }] }, { [ge]: "not", [xe]: [{ [ge]: go, [xe]: [{ [ze]: "AccountIdEndpointMode" }, "disabled"] }] }, { [ge]: go, [xe]: [Jh, "aws"] }, { [ge]: "not", [xe]: [Vm] }, { [ge]: "isSet", [xe]: [{ [ze]: "ResourceArn" }] }, { [ge]: "aws.parseArn", [xe]: [{ [ze]: "ResourceArn" }], [$C]: "ParsedArn" }, { [ge]: go, [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "ParsedArn" }, "service"] }, EM] }, { [ge]: "isValidHostLabel", [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "ParsedArn" }, "region"] }, !1] }, { [ge]: go, [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "ParsedArn" }, "region"] }, "{Region}"] }, { [ge]: "isValidHostLabel", [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "ParsedArn" }, "accountId"] }, !1] }], X_e = [{ [ge]: "isSet", [xe]: [{ [ze]: "AccountIdEndpointMode" }] }, { [ge]: "not", [xe]: [{ [ge]: go, [xe]: [{ [ze]: "AccountIdEndpointMode" }, "disabled"] }] }, { [ge]: go, [xe]: [Jh, "aws"] }, { [ge]: "not", [xe]: [Vm] }, { [ge]: "isSet", [xe]: [{ [ze]: "ResourceArnList" }] }, { [ge]: "getAttr", [xe]: [{ [ze]: "ResourceArnList" }, "[0]"], [$C]: "FirstArn" }, { [ge]: "aws.parseArn", [xe]: [{ [ze]: "FirstArn" }], [$C]: "ParsedArn" }, { [ge]: go, [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "ParsedArn" }, "service"] }, EM] }, { [ge]: "isValidHostLabel", [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "ParsedArn" }, "region"] }, !1] }, { [ge]: go, [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "ParsedArn" }, "region"] }, "{Region}"] }, { [ge]: "isValidHostLabel", [xe]: [{ [ge]: "getAttr", [xe]: [{ [ze]: "ParsedArn" }, "accountId"] }, !1] }], J_e = [{ [ge]: "isSet", [xe]: [{ [ze]: "AccountIdEndpointMode" }] }, { [ge]: "not", [xe]: [{ [ge]: go, [xe]: [{ [ze]: "AccountIdEndpointMode" }, "disabled"] }] }, { [ge]: go, [xe]: [Jh, "aws"] }, { [ge]: "not", [xe]: [Vm] }, { [ge]: "isSet", [xe]: [{ [ze]: "AccountId" }] }], Z_e = [{ [ge]: "isValidHostLabel", [xe]: [{ [ze]: "AccountId" }, !1] }], Qft = { version: "1.0", parameters: { Region: Xh, UseDualStack: N_e, UseFIPS: N_e, Endpoint: Xh, AccountId: Xh, AccountIdEndpointMode: Xh, ResourceArn: Xh, ResourceArnList: { [xM]: !1, [Re]: "stringArray" } }, [dr]: [{ [At]: [B_e, L_e, M_e], [dr]: [$_e, F_e, { [At]: [{ [ge]: go, [xe]: [Kft, k_e] }], error: "Endpoint override is not supported for dual-stack endpoints. Please enable dual-stack functionality by enabling the configuration. For more details, see: https://docs.aws.amazon.com/sdkref/latest/guide/feature-endpoints.html", [Re]: fr }, U_e], [Re]: Ar }, { [At]: [B_e], [dr]: [$_e, F_e, U_e], [Re]: Ar }, { [At]: [L_e], [dr]: [{ [At]: [M_e], [dr]: [{ [At]: [{ [ge]: go, [xe]: [tCe, "local"] }], [dr]: [{ [At]: K_e, error: "Invalid Configuration: FIPS and local endpoint are not supported", [Re]: fr }, { [At]: Q_e, error: "Invalid Configuration: Dualstack and local endpoint are not supported", [Re]: fr }, { endpoint: { [Vs]: "http://localhost:8000", [zs]: { authSchemes: [{ name: "sigv4", signingName: EM, signingRegion: "us-east-1" }] }, [Ws]: Pi }, [Re]: Uo }], [Re]: Ar }, { [At]: [Vm, rCe], [dr]: [{ [At]: [H_e, G_e], [dr]: [hM, { endpoint: { [Vs]: "https://dynamodb-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", [zs]: Pi, [Ws]: Pi }, [Re]: Uo }], [Re]: Ar }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [Re]: fr }], [Re]: Ar }, { [At]: K_e, [dr]: [{ [At]: [H_e], [dr]: [{ [At]: [{ [ge]: go, [xe]: [Jh, "aws-us-gov"] }], [dr]: [hM, j_e], [Re]: Ar }, hM, { endpoint: { [Vs]: "https://dynamodb-fips.{Region}.{PartitionResult#dnsSuffix}", [zs]: Pi, [Ws]: Pi }, [Re]: Uo }], [Re]: Ar }, { error: "FIPS is enabled but this partition does not support FIPS", [Re]: fr }], [Re]: Ar }, { [At]: Q_e, [dr]: [{ [At]: [G_e], [dr]: [{ [At]: Y_e, endpoint: q_e, [Re]: Uo }, { [At]: X_e, endpoint: q_e, [Re]: Uo }, { [At]: J_e, [dr]: [{ [At]: Z_e, [dr]: [{ endpoint: { [Vs]: "https://{AccountId}.ddb.{Region}.{PartitionResult#dualStackDnsSuffix}", [zs]: gM, [Ws]: Pi }, [Re]: Uo }], [Re]: Ar }, V_e], [Re]: Ar }, z_e, { endpoint: { [Vs]: k_e, [zs]: Pi, [Ws]: Pi }, [Re]: Uo }], [Re]: Ar }, { error: "DualStack is enabled but this partition does not support DualStack", [Re]: fr }], [Re]: Ar }, { [At]: Y_e, endpoint: W_e, [Re]: Uo }, { [At]: X_e, endpoint: W_e, [Re]: Uo }, { [At]: J_e, [dr]: [{ [At]: Z_e, [dr]: [{ endpoint: { [Vs]: "https://{AccountId}.ddb.{Region}.{PartitionResult#dnsSuffix}", [zs]: gM, [Ws]: Pi }, [Re]: Uo }], [Re]: Ar }, V_e], [Re]: Ar }, z_e, j_e], [Re]: Ar }], [Re]: Ar }, { error: "Invalid Configuration: Missing Region", [Re]: fr }] }, oCe = Qft }); var Yft, sCe, iCe = s(() => { wE(); Ft(); nCe(); Yft = new Rr({ size: 50, params: ["AccountId", "AccountIdEndpointMode", "Endpoint", "Region", "ResourceArn", "ResourceArnList", "UseDualStack", "UseFIPS"] }), sCe = (e, t = {}) => Yft.get(e, () => Ur(oCe, { endpointParams: e, logger: t.logger })); Rt.aws = Cf }); var aCe, cCe = s(() => { Ye(); yn(); D_e(); ae(); Rf(); uL(); Oh(); lk(); iCe(); aCe = e => ({ apiVersion: "2012-08-10", base64Decoder: e?.base64Decoder ?? J_, base64Encoder: e?.base64Encoder ?? Z_, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? sCe, extensions: e?.extensions ?? [], httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? nZ, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }], logger: e?.logger ?? new ca, protocol: e?.protocol ?? du, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.dynamodb", xmlNamespace: "http://dynamodb.amazonaws.com/doc/2012-08-10/", version: "2012-08-10", serviceTarget: "DynamoDB_20120810", jsonCodec: new MC }, serviceId: e?.serviceId ?? "DynamoDB", urlParser: e?.urlParser ?? bs, utf8Decoder: e?.utf8Decoder ?? Oa, utf8Encoder: e?.utf8Encoder ?? z_ }) }); var pCe, uCe = s(() => { Lre(); Ye(); eO(); XSe(); iO(); KB(); xu(); eL(); qf(); Cc(); oL(); ae(); nL(); aL(); jf(); cCe(); pCe = e => { My(process.version); let t = X_(e), r = () => t().then(Ly), o = aCe(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, accountIdEndpointMode: e?.accountIdEndpointMode ?? It(WV, n), authSchemePreference: e?.authSchemePreference ?? It(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? Y_, credentialDefaultProvider: e?.credentialDefaultProvider ?? QSe, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? q_({ serviceId: o.serviceId, clientVersion: Mre.version }), endpointDiscoveryEnabledProvider: e?.endpointDiscoveryEnabledProvider ?? It(XV, n), maxAttempts: e?.maxAttempts ?? It(Oy, e), region: e?.region ?? It(gu, { ...uy, ...n }), requestHandler: Om.create(e?.requestHandler ?? r), retryMode: e?.retryMode ?? It({ ...ky, default: async () => (await r()).retryMode || Su }, e), sha256: e?.sha256 ?? Pm.bind(null, "sha256"), streamCollector: e?.streamCollector ?? Q_, useDualstackEndpoint: e?.useDualstackEndpoint ?? It(cy, n), useFipsEndpoint: e?.useFipsEndpoint ?? It(py, n), userAgentAppId: e?.userAgentAppId ?? It(V_, n) } } }); var mCe, lCe, dCe = s(() => { mCe = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, lCe = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var fCe, hCe = s(() => { ps(); di(); ae(); dCe(); fCe = (e, t) => { let r = Object.assign(Vr(e), $y(e), tE(e), mCe(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), Fy(r), rE(r), lCe(r)) } }); var Kr, Oi = s(() => { eO(); iO(); aO(); cO(); fO(); ay(); xu(); Ie(); Oe(); WD(); me(); qf(); ae(); lk(); US(); fe(); uCe(); hCe(); Kr = class extends Ru { config; constructor(...[t]) { let r = pCe(t || {}); super(r), this.initConfig = r; let o = iZ(r), n = jV(o), i = SE(n), a = Dy(i), c = ly(a), p = c, u = Ty(p), l = sZ(u), m = hz(l, { endpointDiscoveryCommandCtor: Nu }), f = fCe(m, t?.extensions || []); this.config = f, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(iy(this.config)), this.middlewareStack.use(Uy(this.config)), this.middlewareStack.use(dy(this.config)), this.middlewareStack.use(oE(this.config)), this.middlewareStack.use(nE(this.config)), this.middlewareStack.use(iE(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: oZ, identityProviderConfigProvider: async h => new Cr({ "aws.auth#sigv4": h.credentials }) })), this.middlewareStack.use($r(this.config)) } destroy() { super.destroy() } } }); var FC, yM = s(() => { me(); ae(); fe(); he(); FC = class extends $.classBuilder().ep(q).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "BatchExecuteStatement", {}).n("DynamoDBClient", "BatchExecuteStatementCommand").sc(kte).build() { } }); var UC, SM = s(() => { me(); ae(); fe(); he(); UC = class extends $.classBuilder().ep({ ...q, ResourceArnList: { type: "operationContextParams", get: t => Object.keys(t?.RequestItems ?? {}) } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "BatchGetItem", {}).n("DynamoDBClient", "BatchGetItemCommand").sc(Nte).build() { } }); var zm, _M = s(() => { me(); ae(); fe(); he(); zm = class extends $.classBuilder().ep({ ...q, ResourceArnList: { type: "operationContextParams", get: t => Object.keys(t?.RequestItems ?? {}) } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "BatchWriteItem", {}).n("DynamoDBClient", "BatchWriteItemCommand").sc(Bte).build() { } }); var HC, CM = s(() => { me(); ae(); fe(); he(); HC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "CreateBackup", {}).n("DynamoDBClient", "CreateBackupCommand").sc(Lte).build() { } }); var GC, RM = s(() => { me(); ae(); fe(); he(); GC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "GlobalTableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "CreateGlobalTable", {}).n("DynamoDBClient", "CreateGlobalTableCommand").sc(Mte).build() { } }); var jC, AM = s(() => { me(); ae(); fe(); he(); jC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "CreateTable", {}).n("DynamoDBClient", "CreateTableCommand").sc($te).build() { } }); var qC, TM = s(() => { me(); ae(); fe(); he(); qC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "BackupArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DeleteBackup", {}).n("DynamoDBClient", "DeleteBackupCommand").sc(Fte).build() { } }); var VC, wM = s(() => { me(); ae(); fe(); he(); VC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DeleteItem", {}).n("DynamoDBClient", "DeleteItemCommand").sc(Ute).build() { } }); var zC, bM = s(() => { me(); ae(); fe(); he(); zC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "ResourceArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DeleteResourcePolicy", {}).n("DynamoDBClient", "DeleteResourcePolicyCommand").sc(Hte).build() { } }); var WC, IM = s(() => { me(); ae(); fe(); he(); WC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DeleteTable", {}).n("DynamoDBClient", "DeleteTableCommand").sc(Gte).build() { } }); var KC, vM = s(() => { me(); ae(); fe(); he(); KC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "BackupArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeBackup", {}).n("DynamoDBClient", "DescribeBackupCommand").sc(jte).build() { } }); var QC, PM = s(() => { me(); ae(); fe(); he(); QC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeContinuousBackups", {}).n("DynamoDBClient", "DescribeContinuousBackupsCommand").sc(qte).build() { } }); var YC, OM = s(() => { me(); ae(); fe(); he(); YC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeContributorInsights", {}).n("DynamoDBClient", "DescribeContributorInsightsCommand").sc(Vte).build() { } }); var XC, DM = s(() => { me(); ae(); fe(); he(); XC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "ExportArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeExport", {}).n("DynamoDBClient", "DescribeExportCommand").sc(Wte).build() { } }); var JC, kM = s(() => { me(); ae(); fe(); he(); JC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "GlobalTableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeGlobalTable", {}).n("DynamoDBClient", "DescribeGlobalTableCommand").sc(Kte).build() { } }); var ZC, NM = s(() => { me(); ae(); fe(); he(); ZC = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "GlobalTableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeGlobalTableSettings", {}).n("DynamoDBClient", "DescribeGlobalTableSettingsCommand").sc(Qte).build() { } }); var eR, BM = s(() => { me(); ae(); fe(); he(); eR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "ImportArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeImport", {}).n("DynamoDBClient", "DescribeImportCommand").sc(Yte).build() { } }); var tR, LM = s(() => { me(); ae(); fe(); he(); tR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeKinesisStreamingDestination", {}).n("DynamoDBClient", "DescribeKinesisStreamingDestinationCommand").sc(Xte).build() { } }); var rR, MM = s(() => { me(); ae(); fe(); he(); rR = class extends $.classBuilder().ep(q).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeLimits", {}).n("DynamoDBClient", "DescribeLimitsCommand").sc(Jte).build() { } }); var oR, $M = s(() => { me(); ae(); fe(); he(); oR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeTable", {}).n("DynamoDBClient", "DescribeTableCommand").sc(Zte).build() { } }); var nR, FM = s(() => { me(); ae(); fe(); he(); nR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeTableReplicaAutoScaling", {}).n("DynamoDBClient", "DescribeTableReplicaAutoScalingCommand").sc(ere).build() { } }); var sR, UM = s(() => { me(); ae(); fe(); he(); sR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DescribeTimeToLive", {}).n("DynamoDBClient", "DescribeTimeToLiveCommand").sc(tre).build() { } }); var iR, HM = s(() => { me(); ae(); fe(); he(); iR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "DisableKinesisStreamingDestination", {}).n("DynamoDBClient", "DisableKinesisStreamingDestinationCommand").sc(rre).build() { } }); var aR, GM = s(() => { me(); ae(); fe(); he(); aR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "EnableKinesisStreamingDestination", {}).n("DynamoDBClient", "EnableKinesisStreamingDestinationCommand").sc(ore).build() { } }); var cR, jM = s(() => { me(); ae(); fe(); he(); cR = class extends $.classBuilder().ep(q).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ExecuteStatement", {}).n("DynamoDBClient", "ExecuteStatementCommand").sc(nre).build() { } }); var pR, qM = s(() => { me(); ae(); fe(); he(); pR = class extends $.classBuilder().ep(q).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ExecuteTransaction", {}).n("DynamoDBClient", "ExecuteTransactionCommand").sc(sre).build() { } }); var uR, VM = s(() => { me(); ae(); fe(); he(); uR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ExportTableToPointInTime", {}).n("DynamoDBClient", "ExportTableToPointInTimeCommand").sc(ire).build() { } }); var mR, zM = s(() => { me(); ae(); fe(); he(); mR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "GetItem", {}).n("DynamoDBClient", "GetItemCommand").sc(are).build() { } }); var lR, WM = s(() => { me(); ae(); fe(); he(); lR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "ResourceArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "GetResourcePolicy", {}).n("DynamoDBClient", "GetResourcePolicyCommand").sc(cre).build() { } }); var dR, KM = s(() => { me(); ae(); fe(); he(); dR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "operationContextParams", get: t => t?.TableCreationParameters?.TableName } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ImportTable", {}).n("DynamoDBClient", "ImportTableCommand").sc(pre).build() { } }); var fR, QM = s(() => { me(); ae(); fe(); he(); fR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ListBackups", {}).n("DynamoDBClient", "ListBackupsCommand").sc(ure).build() { } }); var Wm, hR = s(() => { me(); ae(); fe(); he(); Wm = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ListContributorInsights", {}).n("DynamoDBClient", "ListContributorInsightsCommand").sc(mre).build() { } }); var Km, gR = s(() => { me(); ae(); fe(); he(); Km = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ListExports", {}).n("DynamoDBClient", "ListExportsCommand").sc(lre).build() { } }); var xR, YM = s(() => { me(); ae(); fe(); he(); xR = class extends $.classBuilder().ep(q).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ListGlobalTables", {}).n("DynamoDBClient", "ListGlobalTablesCommand").sc(dre).build() { } }); var Qm, ER = s(() => { me(); ae(); fe(); he(); Qm = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ListImports", {}).n("DynamoDBClient", "ListImportsCommand").sc(fre).build() { } }); var Ym, yR = s(() => { me(); ae(); fe(); he(); Ym = class extends $.classBuilder().ep(q).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ListTables", {}).n("DynamoDBClient", "ListTablesCommand").sc(hre).build() { } }); var SR, XM = s(() => { me(); ae(); fe(); he(); SR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "ResourceArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "ListTagsOfResource", {}).n("DynamoDBClient", "ListTagsOfResourceCommand").sc(gre).build() { } }); var _R, JM = s(() => { me(); ae(); fe(); he(); _R = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "PutItem", {}).n("DynamoDBClient", "PutItemCommand").sc(xre).build() { } }); var CR, ZM = s(() => { me(); ae(); fe(); he(); CR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "ResourceArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "PutResourcePolicy", {}).n("DynamoDBClient", "PutResourcePolicyCommand").sc(Ere).build() { } }); var Ks, RR = s(() => { me(); ae(); fe(); he(); Ks = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "Query", {}).n("DynamoDBClient", "QueryCommand").sc(yre).build() { } }); var AR, e$ = s(() => { me(); ae(); fe(); he(); AR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TargetTableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "RestoreTableFromBackup", {}).n("DynamoDBClient", "RestoreTableFromBackupCommand").sc(Sre).build() { } }); var TR, t$ = s(() => { me(); ae(); fe(); he(); TR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TargetTableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "RestoreTableToPointInTime", {}).n("DynamoDBClient", "RestoreTableToPointInTimeCommand").sc(_re).build() { } }); var Xm, wR = s(() => { me(); ae(); fe(); he(); Xm = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "Scan", {}).n("DynamoDBClient", "ScanCommand").sc(Cre).build() { } }); var bR, r$ = s(() => { me(); ae(); fe(); he(); bR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "ResourceArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "TagResource", {}).n("DynamoDBClient", "TagResourceCommand").sc(Rre).build() { } }); var IR, o$ = s(() => { me(); ae(); fe(); he(); IR = class extends $.classBuilder().ep({ ...q, ResourceArnList: { type: "operationContextParams", get: t => t?.TransactItems?.map(r => r?.Get?.TableName) } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "TransactGetItems", {}).n("DynamoDBClient", "TransactGetItemsCommand").sc(Are).build() { } }); var vR, n$ = s(() => { me(); ae(); fe(); he(); vR = class extends $.classBuilder().ep({ ...q, ResourceArnList: { type: "operationContextParams", get: t => t?.TransactItems?.map(r => [r?.ConditionCheck?.TableName, r?.Put?.TableName, r?.Delete?.TableName, r?.Update?.TableName].filter(o => o)).flat() } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "TransactWriteItems", {}).n("DynamoDBClient", "TransactWriteItemsCommand").sc(Tre).build() { } }); var PR, s$ = s(() => { me(); ae(); fe(); he(); PR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "ResourceArn" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UntagResource", {}).n("DynamoDBClient", "UntagResourceCommand").sc(wre).build() { } }); var OR, i$ = s(() => { me(); ae(); fe(); he(); OR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateContinuousBackups", {}).n("DynamoDBClient", "UpdateContinuousBackupsCommand").sc(bre).build() { } }); var DR, a$ = s(() => { me(); ae(); fe(); he(); DR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateContributorInsights", {}).n("DynamoDBClient", "UpdateContributorInsightsCommand").sc(Ire).build() { } }); var kR, c$ = s(() => { me(); ae(); fe(); he(); kR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "GlobalTableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateGlobalTable", {}).n("DynamoDBClient", "UpdateGlobalTableCommand").sc(vre).build() { } }); var NR, p$ = s(() => { me(); ae(); fe(); he(); NR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "GlobalTableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateGlobalTableSettings", {}).n("DynamoDBClient", "UpdateGlobalTableSettingsCommand").sc(Pre).build() { } }); var BR, u$ = s(() => { me(); ae(); fe(); he(); BR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateItem", {}).n("DynamoDBClient", "UpdateItemCommand").sc(Ore).build() { } }); var LR, m$ = s(() => { me(); ae(); fe(); he(); LR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateKinesisStreamingDestination", {}).n("DynamoDBClient", "UpdateKinesisStreamingDestinationCommand").sc(Dre).build() { } }); var MR, l$ = s(() => { me(); ae(); fe(); he(); MR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateTable", {}).n("DynamoDBClient", "UpdateTableCommand").sc(kre).build() { } }); var $R, d$ = s(() => { me(); ae(); fe(); he(); $R = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateTableReplicaAutoScaling", {}).n("DynamoDBClient", "UpdateTableReplicaAutoScalingCommand").sc(Nre).build() { } }); var FR, f$ = s(() => { me(); ae(); fe(); he(); FR = class extends $.classBuilder().ep({ ...q, ResourceArn: { type: "contextParams", name: "TableName" } }).m(function (t, r, o, n) { return [G(o, t.getEndpointParameterInstructions())] }).s("DynamoDB_20120810", "UpdateTimeToLive", {}).n("DynamoDBClient", "UpdateTimeToLiveCommand").sc(Bre).build() { } }); var Xft, h$, gCe = s(() => { ae(); yM(); SM(); _M(); CM(); RM(); AM(); TM(); wM(); bM(); IM(); vM(); PM(); OM(); US(); DM(); kM(); NM(); BM(); LM(); MM(); $M(); FM(); UM(); HM(); GM(); jM(); qM(); VM(); zM(); WM(); KM(); QM(); hR(); gR(); YM(); ER(); yR(); XM(); JM(); ZM(); RR(); e$(); t$(); wR(); r$(); o$(); n$(); s$(); i$(); a$(); c$(); p$(); u$(); m$(); l$(); d$(); f$(); Oi(); Xft = { BatchExecuteStatementCommand: FC, BatchGetItemCommand: UC, BatchWriteItemCommand: zm, CreateBackupCommand: HC, CreateGlobalTableCommand: GC, CreateTableCommand: jC, DeleteBackupCommand: qC, DeleteItemCommand: VC, DeleteResourcePolicyCommand: zC, DeleteTableCommand: WC, DescribeBackupCommand: KC, DescribeContinuousBackupsCommand: QC, DescribeContributorInsightsCommand: YC, DescribeEndpointsCommand: Nu, DescribeExportCommand: XC, DescribeGlobalTableCommand: JC, DescribeGlobalTableSettingsCommand: ZC, DescribeImportCommand: eR, DescribeKinesisStreamingDestinationCommand: tR, DescribeLimitsCommand: rR, DescribeTableCommand: oR, DescribeTableReplicaAutoScalingCommand: nR, DescribeTimeToLiveCommand: sR, DisableKinesisStreamingDestinationCommand: iR, EnableKinesisStreamingDestinationCommand: aR, ExecuteStatementCommand: cR, ExecuteTransactionCommand: pR, ExportTableToPointInTimeCommand: uR, GetItemCommand: mR, GetResourcePolicyCommand: lR, ImportTableCommand: dR, ListBackupsCommand: fR, ListContributorInsightsCommand: Wm, ListExportsCommand: Km, ListGlobalTablesCommand: xR, ListImportsCommand: Qm, ListTablesCommand: Ym, ListTagsOfResourceCommand: SR, PutItemCommand: _R, PutResourcePolicyCommand: CR, QueryCommand: Ks, RestoreTableFromBackupCommand: AR, RestoreTableToPointInTimeCommand: TR, ScanCommand: Xm, TagResourceCommand: bR, TransactGetItemsCommand: IR, TransactWriteItemsCommand: vR, UntagResourceCommand: PR, UpdateContinuousBackupsCommand: OR, UpdateContributorInsightsCommand: DR, UpdateGlobalTableCommand: kR, UpdateGlobalTableSettingsCommand: NR, UpdateItemCommand: BR, UpdateKinesisStreamingDestinationCommand: LR, UpdateTableCommand: MR, UpdateTableReplicaAutoScalingCommand: $R, UpdateTimeToLiveCommand: FR }, h$ = class extends Kr { }; By(Xft, h$) }); var xCe = s(() => { yM(); SM(); _M(); CM(); RM(); AM(); TM(); wM(); bM(); IM(); vM(); PM(); OM(); US(); DM(); kM(); NM(); BM(); LM(); MM(); $M(); FM(); UM(); HM(); GM(); jM(); qM(); VM(); zM(); WM(); KM(); QM(); hR(); gR(); YM(); ER(); yR(); XM(); JM(); ZM(); RR(); e$(); t$(); wR(); r$(); o$(); n$(); s$(); i$(); a$(); c$(); p$(); u$(); m$(); l$(); d$(); f$() }); var ECe = s(() => { }); var ZVr, yCe = s(() => { Ie(); hR(); Oi(); ZVr = qe(Kr, Wm, "NextToken", "NextToken", "MaxResults") }); var nzr, SCe = s(() => { Ie(); gR(); Oi(); nzr = qe(Kr, Km, "NextToken", "NextToken", "MaxResults") }); var pzr, _Ce = s(() => { Ie(); ER(); Oi(); pzr = qe(Kr, Qm, "NextToken", "NextToken", "PageSize") }); var fzr, CCe = s(() => { Ie(); yR(); Oi(); fzr = qe(Kr, Ym, "ExclusiveStartTableName", "LastEvaluatedTableName", "Limit") }); var yzr, RCe = s(() => { Ie(); RR(); Oi(); yzr = qe(Kr, Ks, "ExclusiveStartKey", "LastEvaluatedKey", "Limit") }); var Azr, ACe = s(() => { Ie(); wR(); Oi(); Azr = qe(Kr, Xm, "ExclusiveStartKey", "LastEvaluatedKey", "Limit") }); var TCe = s(() => { ECe(); yCe(); SCe(); _Ce(); CCe(); RCe(); ACe() }); var wCe = s(() => { }); var bCe = s(() => { }); var ICe = s(() => { wCe(); bCe() }); var vCe = s(() => { }); var PCe = s(() => { }); var OCe = s(() => { Oi(); gCe(); xCe(); he(); TCe(); ICe(); vCe(); fk(); PCe() }); var DCe, kCe = s(() => { DCe = () => { let e = process.env.DYNAMO_BATCH_WRITE_COMMAND_CONCURRENCY, t = e ? Number.parseInt(e) : void 0; return t && !Number.isNaN(t) ? t : 4 } }); var NCe = {}; Qe(NCe, { default: () => nht }); import Zft from "node:path"; function tht() { return { region: eht, logger: vp, maxAttempts: Lx(process.env.AWS_SDK_DYNAMODB_MAX_ATTEMPTS) } } function Zh(e) { return Zft.posix.join(g$ ?? "", e) } function rht(e, t, r) { return { path: { S: Zh(e) }, tag: { S: Zh(t) }, revalidatedAt: { N: `${r ?? Date.now()}` } } } var eht, UR, g$, HR, oht, nht, BCe = s(() => { OCe(); vr(); Zd(); kCe(); ({ CACHE_BUCKET_REGION: eht, CACHE_DYNAMO_TABLE: UR, NEXT_BUILD_ID: g$ } = process.env); HR = new Kr(tht()); oht = { mode: "original", async getByPath(e) { try { if (globalThis.openNextConfig.dangerous?.disableTagCache) return []; let r = (await HR.send(new Ks({ TableName: UR, IndexName: "revalidate", KeyConditionExpression: "#key = :key", ExpressionAttributeNames: { "#key": "path" }, ExpressionAttributeValues: { ":key": { S: Zh(e) } } }))).Items?.map(o => o.tag.S ?? "") ?? []; return be("tags for path", e, r), r.map(o => o.replace(`${g$}/`, "")) } catch (t) { return Qt("Failed to get tags by path", t), [] } }, async getByTag(e) { try { if (globalThis.openNextConfig.dangerous?.disableTagCache) return []; let { Items: t } = await HR.send(new Ks({ TableName: UR, KeyConditionExpression: "#tag = :tag", ExpressionAttributeNames: { "#tag": "tag" }, ExpressionAttributeValues: { ":tag": { S: Zh(e) } } })); return t?.map(({ path: { S: r } }) => r?.replace(`${g$}/`, "") ?? "") ?? [] } catch (t) { return Qt("Failed to get by tag", t), [] } }, async getLastModified(e, t) { try { if (globalThis.openNextConfig.dangerous?.disableTagCache) return t ?? Date.now(); let o = (await HR.send(new Ks({ TableName: UR, IndexName: "revalidate", KeyConditionExpression: "#key = :key AND #revalidatedAt > :lastModified", ExpressionAttributeNames: { "#key": "path", "#revalidatedAt": "revalidatedAt" }, ExpressionAttributeValues: { ":key": { S: Zh(e) }, ":lastModified": { N: String(t ?? 0) } } }))).Items ?? []; return be("revalidatedTags", o), o.length > 0 ? -1 : t ?? Date.now() } catch (r) { return Qt("Failed to get revalidated tags", r), t ?? Date.now() } }, async writeTags(e) { try { if (globalThis.openNextConfig.dangerous?.disableTagCache) return; let t = BP(e, 25).map(o => ({ RequestItems: { [UR ?? ""]: o.map(n => ({ PutRequest: { Item: { ...rht(n.path, n.tag, n.revalidatedAt) } } })) } })), r = BP(t, DCe()); for (let o of r) await Promise.all(o.map(async n => HR.send(new zm(n)))) } catch (t) { Qt("Failed to batch write dynamo item", t) } }, name: "dynamoDb" }, nht = oht }); var GR, jR, LCe = s(() => { GR = e => ({ setHttpHandler(t) { e.httpHandler = t }, httpHandler() { return e.httpHandler }, updateHttpClientConfig(t, r) { e.httpHandler?.updateHttpClientConfig(t, r) }, httpHandlerConfigs() { return e.httpHandler.httpHandlerConfigs() } }), jR = e => ({ httpHandler: e.httpHandler() }) }); var MCe = s(() => { LCe() }); var $Ce = s(() => { }); var FCe, UCe = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(FCe || (FCe = {})) }); var HCe, GCe = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(HCe || (HCe = {})) }); var jCe = s(() => { }); var qCe = s(() => { }); var VCe = s(() => { }); var zCe = s(() => { }); var WCe = s(() => { UCe(); GCe(); jCe(); qCe(); VCe(); zCe() }); var KCe = s(() => { }); var QCe = s(() => { }); var YCe = s(() => { }); var XCe = s(() => { }); var JCe = s(() => { }); var ZCe = s(() => { }); var eRe = s(() => { }); var tRe = s(() => { JCe(); ZCe(); eRe() }); var rRe = s(() => { }); var oRe = s(() => { }); var nRe, sRe = s(() => { (function (e) { e.HTTP = "http", e.HTTPS = "https" })(nRe || (nRe = {})) }); var iRe = s(() => { }); var aRe = s(() => { }); var cRe = s(() => { }); var pRe = s(() => { }); var uRe = s(() => { }); var mRe = s(() => { iRe(); aRe(); cRe(); pRe(); uRe() }); var lRe = s(() => { }); var Jm, dRe = s(() => { (function (e) { e.MD5 = "md5", e.CRC32 = "crc32", e.CRC32C = "crc32c", e.SHA1 = "sha1", e.SHA256 = "sha256" })(Jm || (Jm = {})) }); var fRe = s(() => { }); var hRe = s(() => { }); var gRe = s(() => { fRe(); hRe(); dRe() }); var xRe = s(() => { }); var ERe, yRe = s(() => { (function (e) { e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER" })(ERe || (ERe = {})) }); var SRe = s(() => { }); var _Re = s(() => { }); var CRe = s(() => { }); var RRe = s(() => { }); var ARe = s(() => { }); var TRe = s(() => { _Re(); CRe(); RRe(); ARe() }); var wRe = s(() => { }); var bRe, IRe = s(() => { bRe = "__smithy_context" }); var vRe = s(() => { }); var Di, PRe = s(() => { (function (e) { e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services" })(Di || (Di = {})) }); var ORe = s(() => { }); var DRe = s(() => { }); var kRe = s(() => { }); var NRe = s(() => { }); var BRe = s(() => { }); var LRe = s(() => { }); var MRe = s(() => { }); var $Re = s(() => { }); var FRe = s(() => { }); var URe = s(() => { }); var HRe = s(() => { }); var GRe = s(() => { }); var jRe = s(() => { }); var qRe = s(() => { }); var VRe, zRe = s(() => { (function (e) { e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0" })(VRe || (VRe = {})) }); var WRe = s(() => { }); var KRe = s(() => { }); var QRe = s(() => { }); var YRe = s(() => { }); var XRe = s(() => { }); var JRe = s(() => { }); var ZRe = s(() => { }); var Zm = s(() => { $Ce(); WCe(); KCe(); QCe(); YCe(); XCe(); tRe(); rRe(); oRe(); sRe(); mRe(); lRe(); gRe(); xRe(); yRe(); SRe(); TRe(); wRe(); IRe(); vRe(); PRe(); ORe(); DRe(); kRe(); NRe(); BRe(); LRe(); MRe(); $Re(); FRe(); URe(); HRe(); GRe(); jRe(); qRe(); zRe(); WRe(); KRe(); QRe(); YRe(); XRe(); JRe(); ZRe() }); var eAe = s(() => { }); var tAe = s(() => { }); var rAe = s(() => { }); function sht(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var Dn, oAe = s(() => { Dn = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = sht(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var el, nAe = s(() => { el = class { statusCode; reason; headers; body; constructor(t) { this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body } static isInstance(t) { if (!t) return !1; let r = t; return typeof r.statusCode == "number" && typeof r.headers == "object" } } }); var sAe = s(() => { }); var iAe = s(() => { }); var ki = s(() => { MCe(); eAe(); tAe(); rAe(); oAe(); nAe(); sAe(); iAe() }); var iht, aht, qR, x$ = s(() => { ki(); iht = e => t => async r => { if (!Dn.isInstance(r.request)) return t(r); let { request: o } = r, { handlerProtocol: n = "" } = e.requestHandler.metadata || {}; if (n.indexOf("h2") >= 0 && !o.headers[":authority"]) delete o.headers.host, o.headers[":authority"] = o.hostname + (o.port ? ":" + o.port : ""); else if (!o.headers.host) { let i = o.hostname; o.port != null && (i += `:${o.port}`), o.headers.host = i } return t(r) }, aht = { name: "hostHeaderMiddleware", step: "build", priority: "low", tags: ["HOST"], override: !0 }, qR = e => ({ applyToStack: t => { t.add(iht(e), aht) } }) }); var cht, pht, VR, aAe = s(() => { cht = () => (e, t) => async r => { try { let o = await e(r), { clientName: n, commandName: i, logger: a, dynamoDbDocumentClientOptions: c = {} } = t, { overrideInputFilterSensitiveLog: p, overrideOutputFilterSensitiveLog: u } = c, l = p ?? t.inputFilterSensitiveLog, m = u ?? t.outputFilterSensitiveLog, { $metadata: f, ...h } = o.output; return a?.info?.({ clientName: n, commandName: i, input: l(r.input), output: m(h), metadata: f }), o } catch (o) { let { clientName: n, commandName: i, logger: a, dynamoDbDocumentClientOptions: c = {} } = t, { overrideInputFilterSensitiveLog: p } = c, u = p ?? t.inputFilterSensitiveLog; throw a?.error?.({ clientName: n, commandName: i, input: u(r.input), error: o, metadata: o.$metadata }), o } }, pht = { name: "loggerMiddleware", tags: ["LOGGER"], step: "initialize", override: !0 }, VR = e => ({ applyToStack: t => { t.add(cht(), pht) } }) }); var E$ = s(() => { aAe() }); var cAe, pAe = s(() => { cAe = { step: "build", tags: ["RECURSION_DETECTION"], name: "recursionDetectionMiddleware", override: !0, priority: "low" } }); var y$, uht, mht, uAe, S$ = s(() => { xf(); ki(); y$ = "X-Amzn-Trace-Id", uht = "AWS_LAMBDA_FUNCTION_NAME", mht = "_X_AMZN_TRACE_ID", uAe = () => e => async t => { let { request: r } = t; if (!Dn.isInstance(r)) return e(t); let o = Object.keys(r.headers ?? {}).find(l => l.toLowerCase() === y$.toLowerCase()) ?? y$; if (r.headers.hasOwnProperty(o)) return e(t); let n = process.env[uht], i = process.env[mht], p = (await Cs.getInstanceAsync())?.getXRayTraceId() ?? i, u = l => typeof l == "string" && l.length > 0; return u(n) && u(p) && (r.headers[y$] = p), e({ ...t, request: r }) } }); var zR, mAe = s(() => { pAe(); S$(); zR = e => ({ applyToStack: t => { t.add(uAe(), cAe) } }) }); var _$ = s(() => { mAe(); S$() }); var lAe = s(() => { }); var dAe = s(() => { }); var fAe = s(() => { }); var hAe = s(() => { }); var gAe = s(() => { }); var xAe = s(() => { }); var EAe = s(() => { }); var yAe = s(() => { }); var SAe = s(() => { }); var _Ae = s(() => { }); var CAe = s(() => { }); var RAe = s(() => { CAe() }); var AAe = s(() => { }); var TAe = s(() => { }); var wAe = s(() => { }); var WR, bAe = s(() => { WR = class { trace() { } debug() { } info() { } warn() { } error() { } } }); var IAe = s(() => { }); var vAe = s(() => { }); var PAe = s(() => { }); var OAe = s(() => { }); var DAe = s(() => { lAe(); dAe(); fAe(); hAe(); gAe(); EAe(); yAe(); SAe(); xAe(); _Ae(); RAe(); AAe(); TAe(); wAe(); bAe(); IAe(); vAe(); PAe(); OAe(); Pr() }); function lht({ useQueueUrlAsEndpoint: e, endpoint: t }) {
  return (r, o) => async n => {
    let { input: i } = n, a = o.endpointV2; if (!t && i.QueueUrl && a && e) {
      let c = o.logger instanceof WR || !o.logger?.warn ? console : o.logger; try {
        let p = new URL(i.QueueUrl), u = new URL(p.origin); a.url.origin !== u.origin && (c.warn(`QueueUrl=${i.QueueUrl} differs from SQSClient resolved endpoint=${a.url.toString()}, using QueueUrl host as endpoint.
Set [endpoint=string] or [useQueueUrlAsEndpoint=false] on the SQSClient.`), o.endpointV2 = { ...a, url: u })
      } catch (p) { c.warn(p) }
    } return r(n)
  }
} var kAe, dht, NAe, BAe = s(() => { DAe(); kAe = e => Object.assign(e, { useQueueUrlAsEndpoint: e.useQueueUrlAsEndpoint ?? !0 }); dht = { name: "queueUrlMiddleware", relation: "after", toMiddleware: "endpointV2Middleware", override: !0 }, NAe = e => ({ applyToStack: t => { t.addRelativeTo(lht(e), dht) } }) }); import { Buffer as LAe } from "buffer"; var MAe, $Ae = s(() => { MAe = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? LAe.from(e, t) : LAe.from(e) } }); var FAe, C$ = s(() => { $Ae(); FAe = e => { let t = MAe(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var tl, UAe = s(() => { C$(); tl = e => typeof e == "string" ? FAe(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) }); var HAe = s(() => { }); var KR = s(() => { C$(); UAe(); HAe() }); function fht(e) { return t => async r => { let o = await t({ ...r }); if (e.md5 === !1) return o; let n = o.output, i = []; if (n.Messages !== void 0) for (let a of n.Messages) { let c = a.MD5OfBody, p = new e.md5; p.update(tl(a.Body || "")), c !== it(await p.digest()) && i.push(a.MessageId) } if (i.length > 0) throw new Error("Invalid MD5 checksum on messages: " + i.join(", ")); return o } } var hht, GAe, jAe = s(() => { Oo(); KR(); hht = { step: "initialize", tags: ["VALIDATE_BODY_MD5"], name: "receiveMessageMiddleware", override: !0 }, GAe = e => ({ applyToStack: t => { t.add(fht(e), hht) } }) }); var ght, xht, qAe, VAe = s(() => { Oo(); KR(); ght = e => t => async r => { let o = await t({ ...r }); if (e.md5 === !1) return o; let n = o.output, i = new e.md5; if (i.update(tl(r.input.MessageBody || "")), n.MD5OfMessageBody !== it(await i.digest())) throw new Error("InvalidChecksumError"); return o }, xht = { step: "initialize", tags: ["VALIDATE_BODY_MD5"], name: "sendMessageMiddleware", override: !0 }, qAe = e => ({ applyToStack: t => { t.add(ght(e), xht) } }) }); var Eht, yht, zAe, WAe = s(() => { Oo(); KR(); Eht = e => t => async r => { let o = await t({ ...r }); if (e.md5 === !1) return o; let n = o.output, i = [], a = {}; if (n.Successful !== void 0) for (let c of n.Successful) c.Id !== void 0 && (a[c.Id] = c); for (let c of r.input.Entries) if (a[c.Id]) { let p = a[c.Id].MD5OfMessageBody, u = new e.md5; u.update(tl(c.MessageBody || "")), p !== it(await u.digest()) && i.push(a[c.Id].MessageId) } if (i.length > 0) throw new Error("Invalid MD5 checksum on messages: " + i.join(", ")); return o }, yht = { step: "initialize", tags: ["VALIDATE_BODY_MD5"], name: "sendMessageBatchMiddleware", override: !0 }, zAe = e => ({ applyToStack: t => { t.add(Eht(e), yht) } }) }); var eg = s(() => { BAe(); jAe(); VAe(); WAe() }); function Sht(e) { return e === void 0 ? !0 : typeof e == "string" && e.length <= 50 } function QR(e) { let t = yo(e.userAgentAppId ?? R$), { customUserAgent: r } = e; return Object.assign(e, { customUserAgent: typeof r == "string" ? [[r]] : r, userAgentAppId: async () => { let o = await t(); if (!Sht(o)) { let n = e.logger?.constructor?.name === "NoOpLogger" || !e.logger ? console : e.logger; typeof o != "string" ? n?.warn("userAgentAppId must be a string or undefined.") : o.length > 50 && n?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.") } return o } }) } var R$, KAe = s(() => { Ie(); R$ = void 0 }); var A$ = s(() => { Ft() }); var T$, QAe = s(() => { Ft(); A$(); T$ = (e, t = !1) => { if (t) { for (let r of e.split(".")) if (!T$(r)) return !1; return !0 } return !(!Or(e) || e.length < 3 || e.length > 63 || e !== e.toLowerCase() || No(e)) } }); var YAe, _ht, XAe, JAe = s(() => { YAe = ":", _ht = "/", XAe = e => { let t = e.split(YAe); if (t.length < 6) return null; let [r, o, n, i, a, ...c] = t; if (r !== "arn" || o === "" || n === "" || c.join(YAe) === "") return null; let p = c.map(u => u.split(_ht)).flat(); return { partition: o, service: n, region: i, accountId: a, resourceId: p } } }); var eTe, ZAe = s(() => { eTe = { partitions: [{ id: "aws", outputs: { dnsSuffix: "amazonaws.com", dualStackDnsSuffix: "api.aws", implicitGlobalRegion: "us-east-1", name: "aws", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$", regions: { "af-south-1": { description: "Africa (Cape Town)" }, "ap-east-1": { description: "Asia Pacific (Hong Kong)" }, "ap-east-2": { description: "Asia Pacific (Taipei)" }, "ap-northeast-1": { description: "Asia Pacific (Tokyo)" }, "ap-northeast-2": { description: "Asia Pacific (Seoul)" }, "ap-northeast-3": { description: "Asia Pacific (Osaka)" }, "ap-south-1": { description: "Asia Pacific (Mumbai)" }, "ap-south-2": { description: "Asia Pacific (Hyderabad)" }, "ap-southeast-1": { description: "Asia Pacific (Singapore)" }, "ap-southeast-2": { description: "Asia Pacific (Sydney)" }, "ap-southeast-3": { description: "Asia Pacific (Jakarta)" }, "ap-southeast-4": { description: "Asia Pacific (Melbourne)" }, "ap-southeast-5": { description: "Asia Pacific (Malaysia)" }, "ap-southeast-6": { description: "Asia Pacific (New Zealand)" }, "ap-southeast-7": { description: "Asia Pacific (Thailand)" }, "aws-global": { description: "aws global region" }, "ca-central-1": { description: "Canada (Central)" }, "ca-west-1": { description: "Canada West (Calgary)" }, "eu-central-1": { description: "Europe (Frankfurt)" }, "eu-central-2": { description: "Europe (Zurich)" }, "eu-north-1": { description: "Europe (Stockholm)" }, "eu-south-1": { description: "Europe (Milan)" }, "eu-south-2": { description: "Europe (Spain)" }, "eu-west-1": { description: "Europe (Ireland)" }, "eu-west-2": { description: "Europe (London)" }, "eu-west-3": { description: "Europe (Paris)" }, "il-central-1": { description: "Israel (Tel Aviv)" }, "me-central-1": { description: "Middle East (UAE)" }, "me-south-1": { description: "Middle East (Bahrain)" }, "mx-central-1": { description: "Mexico (Central)" }, "sa-east-1": { description: "South America (Sao Paulo)" }, "us-east-1": { description: "US East (N. Virginia)" }, "us-east-2": { description: "US East (Ohio)" }, "us-west-1": { description: "US West (N. California)" }, "us-west-2": { description: "US West (Oregon)" } } }, { id: "aws-cn", outputs: { dnsSuffix: "amazonaws.com.cn", dualStackDnsSuffix: "api.amazonwebservices.com.cn", implicitGlobalRegion: "cn-northwest-1", name: "aws-cn", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^cn\\-\\w+\\-\\d+$", regions: { "aws-cn-global": { description: "aws-cn global region" }, "cn-north-1": { description: "China (Beijing)" }, "cn-northwest-1": { description: "China (Ningxia)" } } }, { id: "aws-eusc", outputs: { dnsSuffix: "amazonaws.eu", dualStackDnsSuffix: "api.amazonwebservices.eu", implicitGlobalRegion: "eusc-de-east-1", name: "aws-eusc", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$", regions: { "eusc-de-east-1": { description: "EU (Germany)" } } }, { id: "aws-iso", outputs: { dnsSuffix: "c2s.ic.gov", dualStackDnsSuffix: "api.aws.ic.gov", implicitGlobalRegion: "us-iso-east-1", name: "aws-iso", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-iso\\-\\w+\\-\\d+$", regions: { "aws-iso-global": { description: "aws-iso global region" }, "us-iso-east-1": { description: "US ISO East" }, "us-iso-west-1": { description: "US ISO WEST" } } }, { id: "aws-iso-b", outputs: { dnsSuffix: "sc2s.sgov.gov", dualStackDnsSuffix: "api.aws.scloud", implicitGlobalRegion: "us-isob-east-1", name: "aws-iso-b", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-isob\\-\\w+\\-\\d+$", regions: { "aws-iso-b-global": { description: "aws-iso-b global region" }, "us-isob-east-1": { description: "US ISOB East (Ohio)" }, "us-isob-west-1": { description: "US ISOB West" } } }, { id: "aws-iso-e", outputs: { dnsSuffix: "cloud.adc-e.uk", dualStackDnsSuffix: "api.cloud-aws.adc-e.uk", implicitGlobalRegion: "eu-isoe-west-1", name: "aws-iso-e", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$", regions: { "aws-iso-e-global": { description: "aws-iso-e global region" }, "eu-isoe-west-1": { description: "EU ISOE West" } } }, { id: "aws-iso-f", outputs: { dnsSuffix: "csp.hci.ic.gov", dualStackDnsSuffix: "api.aws.hci.ic.gov", implicitGlobalRegion: "us-isof-south-1", name: "aws-iso-f", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-isof\\-\\w+\\-\\d+$", regions: { "aws-iso-f-global": { description: "aws-iso-f global region" }, "us-isof-east-1": { description: "US ISOF EAST" }, "us-isof-south-1": { description: "US ISOF SOUTH" } } }, { id: "aws-us-gov", outputs: { dnsSuffix: "amazonaws.com", dualStackDnsSuffix: "api.aws", implicitGlobalRegion: "us-gov-west-1", name: "aws-us-gov", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-gov\\-\\w+\\-\\d+$", regions: { "aws-us-gov-global": { description: "aws-us-gov global region" }, "us-gov-east-1": { description: "AWS GovCloud (US-East)" }, "us-gov-west-1": { description: "AWS GovCloud (US-West)" } } }], version: "1.1" } }); var Rht, Aht, tTe, rTe, w$ = s(() => { ZAe(); Rht = eTe, Aht = "", tTe = e => { let { partitions: t } = Rht; for (let o of t) { let { regions: n, outputs: i } = o; for (let [a, c] of Object.entries(n)) if (a === e) return { ...i, ...c } } for (let o of t) { let { regionRegex: n, outputs: i } = o; if (new RegExp(n).test(e)) return { ...i } } let r = t.find(o => o.id === "aws"); if (!r) throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."); return { ...r.outputs } }, rTe = () => Aht }); var tg, oTe = s(() => { Ft(); QAe(); JAe(); w$(); tg = { isVirtualHostableS3Bucket: T$, parseArn: XAe, partition: tTe }; Rt.aws = tg }); function nTe(e) { let t = {}; if (e = e.replace(/^\?/, ""), e) for (let r of e.split("&")) { let [o, n = null] = r.split("="); o = decodeURIComponent(o), n && (n = decodeURIComponent(n)), o in t ? Array.isArray(t[o]) ? t[o].push(n) : t[o] = [t[o], n] : t[o] = n } return t } var sTe = s(() => { }); var Qs, rg = s(() => { sTe(); Qs = e => { if (typeof e == "string") return Qs(new URL(e)); let { hostname: t, pathname: r, port: o, protocol: n, search: i } = e, a; return i && (a = nTe(i)), { hostname: t, port: o ? parseInt(o) : void 0, protocol: n, path: r, query: a } } }); var iTe = s(() => { }); var aTe = s(() => { }); var cTe = s(() => { }); var pTe = s(() => { }); var uTe = s(() => { }); var mTe = s(() => { }); var lTe = s(() => { }); var dTe = s(() => { }); var fTe = s(() => { cTe(); pTe(); uTe(); mTe(); lTe(); dTe() }); var YR = s(() => { oTe(); w$(); A$(); iTe(); aTe(); fTe() }); async function hTe(e, t, r) { if (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" && ye(e, "PROTOCOL_RPC_V2_CBOR", "M"), typeof t.retryStrategy == "function") { let i = await t.retryStrategy(); typeof i.acquireInitialRetryToken == "function" ? i.constructor?.name?.includes("Adaptive") ? ye(e, "RETRY_MODE_ADAPTIVE", "F") : ye(e, "RETRY_MODE_STANDARD", "E") : ye(e, "RETRY_MODE_LEGACY", "D") } if (typeof t.accountIdEndpointMode == "function") { let i = e.endpointV2; switch (String(i?.url?.hostname).match(Tht) && ye(e, "ACCOUNT_ID_ENDPOINT", "O"), await t.accountIdEndpointMode?.()) { case "disabled": ye(e, "ACCOUNT_ID_MODE_DISABLED", "Q"); break; case "preferred": ye(e, "ACCOUNT_ID_MODE_PREFERRED", "P"); break; case "required": ye(e, "ACCOUNT_ID_MODE_REQUIRED", "R"); break } } let n = e.__smithy_context?.selectedHttpAuthScheme?.identity; if (n?.$source) { let i = n; i.accountId && ye(e, "RESOLVED_ACCOUNT_ID", "T"); for (let [a, c] of Object.entries(i.$source ?? {})) ye(e, a, c) } } var Tht, gTe = s(() => { Ye(); Tht = /\d{12}\.ddb/ }); var b$, XR, I$, JR, xTe, ETe, v$, yTe = s(() => { b$ = "user-agent", XR = "x-amz-user-agent", I$ = " ", JR = "/", xTe = /[^!$%&'*+\-.^_`|~\w]/g, ETe = /[^!$%&'*+\-.^_`|~\w#]/g, v$ = "-" }); function STe(e) { let t = ""; for (let r in e) { let o = e[r]; if (t.length + o.length + 1 <= 1024) { t.length ? t += "," + o : t += o; continue } break } return t } var _Te = s(() => { }); var wht, ZR, bht, eA, CTe = s(() => { YR(); ki(); gTe(); yTe(); _Te(); wht = e => (t, r) => async o => { let { request: n } = o; if (!Dn.isInstance(n)) return t(o); let { headers: i } = n, a = r?.userAgent?.map(ZR) || [], c = (await e.defaultUserAgentProvider()).map(ZR); await hTe(r, e, o); let p = r; c.push(`m/${STe(Object.assign({}, r.__smithy_context?.features, p.__aws_sdk_context?.features))}`); let u = e?.customUserAgent?.map(ZR) || [], l = await e.userAgentAppId(); l && c.push(ZR(["app", `${l}`])); let m = rTe(), f = (m ? [m] : []).concat([...c, ...a, ...u]).join(I$), h = [...c.filter(E => E.startsWith("aws-sdk-")), ...u].join(I$); return e.runtime !== "browser" ? (h && (i[XR] = i[XR] ? `${i[b$]} ${h}` : h), i[b$] = f) : i[XR] = f, t({ ...o, request: n }) }, ZR = e => { let t = e[0].split(JR).map(a => a.replace(xTe, v$)).join(JR), r = e[1]?.replace(ETe, v$), o = t.indexOf(JR), n = t.substring(0, o), i = t.substring(o + 1); return n === "api" && (i = i.toLowerCase()), [n, i, r].filter(a => a && a.length > 0).reduce((a, c, p) => { switch (p) { case 0: return c; case 1: return `${a}/${c}`; default: return `${a}#${c}` } }, "") }, bht = { name: "getUserAgentMiddleware", step: "build", priority: "low", tags: ["SET_USER_AGENT", "USER_AGENT"], override: !0 }, eA = e => ({ applyToStack: t => { t.add(wht(e), bht) } }) }); var tA = s(() => { KAe(); CTe() }); var Iht, vht, rA, RTe = s(() => { os(); Iht = "AWS_USE_DUALSTACK_ENDPOINT", vht = "use_dualstack_endpoint", rA = { environmentVariableSelector: e => xt(e, Iht, ct.ENV), configFileSelector: e => xt(e, vht, ct.CONFIG), default: !1 } }); var Pht, Oht, oA, ATe = s(() => { os(); Pht = "AWS_USE_FIPS_ENDPOINT", Oht = "use_fips_endpoint", oA = { environmentVariableSelector: e => xt(e, Pht, ct.ENV), configFileSelector: e => xt(e, Oht, ct.CONFIG), default: !1 } }); var TTe = s(() => { }); var wTe = s(() => { }); var bTe = s(() => { RTe(); ATe(); TTe(); wTe() }); var Dht, kht, rl, nA, ITe = s(() => { Dht = "AWS_REGION", kht = "region", rl = { environmentVariableSelector: e => e[Dht], configFileSelector: e => e[kht], default: () => { throw new Error("Region is missing") } }, nA = { preferredFile: "credentials" } }); var vTe, PTe, OTe = s(() => { Ft(); vTe = new Set, PTe = (e, t = Or) => { if (!vTe.has(e) && !t(e)) if (e === "*") console.warn('@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.'); else throw new Error(`Region not accepted: region="${e}" is not a valid hostname component.`); else vTe.add(e) } }); var sA, P$ = s(() => { sA = e => typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")) }); var DTe, kTe = s(() => { P$(); DTe = e => sA(e) ? ["fips-aws-global", "aws-fips"].includes(e) ? "us-east-1" : e.replace(/fips-(dkr-|prod-)?|-fips/, "") : e }); var iA, NTe = s(() => { OTe(); kTe(); P$(); iA = e => { let { region: t, useFipsEndpoint: r } = e; if (!t) throw new Error("Region is missing"); return Object.assign(e, { region: async () => { let o = typeof t == "function" ? await t() : t, n = DTe(o); return PTe(n), n }, useFipsEndpoint: async () => { let o = typeof t == "string" ? t : await t(); return sA(o) ? !0 : typeof r != "function" ? Promise.resolve(!!r) : r() } }) } }); var BTe = s(() => { ITe(); NTe() }); var LTe = s(() => { }); var MTe = s(() => { }); var $Te = s(() => { }); var FTe = s(() => { LTe(); MTe(); $Te() }); var ol = s(() => { bTe(); BTe(); FTe() }); function Nht(e) { return t => async r => { let o = r.request; if (Dn.isInstance(o)) { let { body: n, headers: i } = o; if (n && Object.keys(i).map(a => a.toLowerCase()).indexOf(UTe) === -1) try { let a = e(n); o.headers = { ...o.headers, [UTe]: String(a) } } catch { } } return t({ ...r, request: o }) } } var UTe, Bht, aA, O$ = s(() => { ki(); UTe = "content-length"; Bht = { step: "build", tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"], name: "contentLengthMiddleware", override: !0 }, aA = e => ({ applyToStack: t => { t.add(Nht(e.bodyLengthChecker), Bht) } }) }); var HTe, Lht, Mht, $ht, Fht, Uht, GTe = s(() => { HTe = async e => { let t = e?.Bucket || ""; if (typeof e.Bucket == "string" && (e.Bucket = t.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), Uht(t)) { if (e.ForcePathStyle === !0) throw new Error("Path-style addressing cannot be used with ARN buckets") } else (!Fht(t) || t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:") || t.toLowerCase() !== t || t.length < 3) && (e.ForcePathStyle = !0); return e.DisableMultiRegionAccessPoints && (e.disableMultiRegionAccessPoints = !0, e.DisableMRAP = !0), e }, Lht = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, Mht = /(\d+\.){3}\d+/, $ht = /\.\./, Fht = e => Lht.test(e) && !Mht.test(e) && !$ht.test(e), Uht = e => { let [t, r, o, , , n] = e.split(":"), i = t === "arn" && e.split(":").length >= 6, a = !!(i && r && o && n); if (i && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`); return a } }); var jTe = s(() => { GTe() }); var qTe, VTe = s(() => { qTe = (e, t, r, o = !1) => { let n = async () => { let i; return o ? i = r.clientContextParams?.[e] ?? r[e] ?? r[t] : i = r[e] ?? r[t], typeof i == "function" ? i() : i }; return e === "credentialScope" || t === "CredentialScope" ? async () => { let i = typeof r.credentials == "function" ? await r.credentials() : r.credentials; return i?.credentialScope ?? i?.CredentialScope } : e === "accountId" || t === "AccountId" ? async () => { let i = typeof r.credentials == "function" ? await r.credentials() : r.credentials; return i?.accountId ?? i?.AccountId } : e === "endpoint" || t === "endpoint" ? async () => { if (r.isCustomEndpoint === !1) return; let i = await n(); if (i && typeof i == "object") { if ("url" in i) return i.url.href; if ("hostname" in i) { let { protocol: a, hostname: c, port: p, path: u } = i; return `${a}//${c}${p ? ":" + p : ""}${u}` } } return i } : n } }); function cA(e) { try { let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? [])); return t.delete("CONFIG"), t.delete("CONFIG_PREFIX_SEPARATOR"), t.delete("ENV"), [...t].join(", ") } catch { return e } } var D$ = s(() => { }); var zTe, WTe = s(() => { Z(); D$(); zTe = (e, t) => async () => { try { let r = e(process.env, t); if (r === void 0) throw new Error; return r } catch (r) { throw new I(r.message || `Not found in ENV: ${cA(e.toString())}`, { logger: t?.logger }) } } }); import { homedir as Hht } from "os"; import { sep as Ght } from "path"; var k$, jht, La, nl = s(() => { k$ = {}, jht = () => process && process.geteuid ? `${process.geteuid()}` : "DEFAULT", La = () => { let { HOME: e, USERPROFILE: t, HOMEPATH: r, HOMEDRIVE: o = `C:${Ght}` } = process.env; if (e) return e; if (t) return t; if (r) return `${o}${r}`; let n = jht(); return k$[n] || (k$[n] = Hht()), k$[n] } }); var N$, qht, kn, KTe = s(() => { N$ = "AWS_PROFILE", qht = "default", kn = e => e.profile || process.env[N$] || qht }); import { createHash as Vht } from "crypto"; import { join as zht } from "path"; var pA, B$ = s(() => { nl(); pA = e => { let r = Vht("sha1").update(e).digest("hex"); return zht(La(), ".aws", "sso", "cache", `${r}.json`) } }); import { readFile as Wht } from "fs/promises"; var og, ng, L$ = s(() => { B$(); og = {}, ng = async e => { if (og[e]) return og[e]; let t = pA(e), r = await Wht(t, "utf8"); return JSON.parse(r) } }); var tn, uA = s(() => { tn = "." }); var QTe, YTe = s(() => { Zm(); uA(); QTe = e => Object.entries(e).filter(([t]) => { let r = t.indexOf(tn); return r === -1 ? !1 : Object.values(Di).includes(t.substring(0, r)) }).reduce((t, [r, o]) => { let n = r.indexOf(tn), i = r.substring(0, n) === Di.PROFILE ? r.substring(n + 1) : r; return t[i] = o, t }, { ...e.default && { default: e.default } }) }); import { join as Kht } from "path"; var Qht, mA, M$ = s(() => { nl(); Qht = "AWS_CONFIG_FILE", mA = () => process.env[Qht] || Kht(La(), ".aws", "config") }); import { join as Yht } from "path"; var Xht, XTe, JTe = s(() => { nl(); Xht = "AWS_SHARED_CREDENTIALS_FILE", XTe = () => process.env[Xht] || Yht(La(), ".aws", "credentials") }); var Jht, Zht, sg, $$ = s(() => { Zm(); uA(); Jht = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/, Zht = ["__proto__", "profile __proto__"], sg = e => { let t = {}, r, o; for (let n of e.split(/\r?\n/)) { let i = n.split(/(^|\s)[;#]/)[0].trim(); if (i[0] === "[" && i[i.length - 1] === "]") { r = void 0, o = void 0; let c = i.substring(1, i.length - 1), p = Jht.exec(c); if (p) { let [, u, , l] = p; Object.values(Di).includes(u) && (r = [u, l].join(tn)) } else r = c; if (Zht.includes(c)) throw new Error(`Found invalid profile name "${c}"`) } else if (r) { let c = i.indexOf("="); if (![0, -1].includes(c)) { let [p, u] = [i.substring(0, c).trim(), i.substring(c + 1).trim()]; if (u === "") o = p; else { o && n.trimStart() === n && (o = void 0), t[r] = t[r] || {}; let l = o ? [o, p].join(tn) : p; t[r][l] = u } } } } return t } }); import { readFile as egt } from "node:fs/promises"; var F$, ig, ag, lA = s(() => { F$ = {}, ig = {}, ag = (e, t) => ig[e] !== void 0 ? ig[e] : ((!F$[e] || t?.ignoreCache) && (F$[e] = egt(e, "utf8")), F$[e]) }); import { join as ZTe } from "path"; var ewe, dA, fA = s(() => { YTe(); M$(); JTe(); nl(); $$(); lA(); uA(); ewe = () => ({}), dA = async (e = {}) => { let { filepath: t = XTe(), configFilepath: r = mA() } = e, o = La(), n = "~/", i = t; t.startsWith(n) && (i = ZTe(o, t.slice(2))); let a = r; r.startsWith(n) && (a = ZTe(o, r.slice(2))); let c = await Promise.all([ag(a, { ignoreCache: e.ignoreCache }).then(sg).then(QTe).catch(ewe), ag(i, { ignoreCache: e.ignoreCache }).then(sg).catch(ewe)]); return { configFile: c[0], credentialsFile: c[1] } } }); var twe, rwe = s(() => { Zm(); fA(); twe = e => Object.entries(e).filter(([t]) => t.startsWith(Di.SSO_SESSION + tn)).reduce((t, [r, o]) => ({ ...t, [r.substring(r.indexOf(tn) + 1)]: o }), {}) }); var tgt, hA, owe = s(() => { M$(); rwe(); $$(); lA(); tgt = () => ({}), hA = async (e = {}) => ag(e.configFilepath ?? mA()).then(sg).then(twe).catch(tgt) }); var nwe, swe = s(() => { nwe = (...e) => { let t = {}; for (let r of e) for (let [o, n] of Object.entries(r)) t[o] !== void 0 ? Object.assign(t[o], n) : t[o] = n; return t } }); var Ma, iwe = s(() => { fA(); swe(); Ma = async e => { let t = await dA(e); return nwe(t.configFile, t.credentialsFile) } }); var cg, awe = s(() => { L$(); lA(); cg = { getFileRecord() { return ig }, interceptFile(e, t) { ig[e] = Promise.resolve(t) }, getTokenRecord() { return og }, interceptToken(e, t) { og[e] = t } } }); var cwe = s(() => { }); var rn = s(() => { nl(); KTe(); B$(); L$(); fA(); owe(); iwe(); awe(); cwe() }); var pwe, uwe = s(() => { Z(); rn(); D$(); pwe = (e, { preferredFile: t = "config", ...r } = {}) => async () => { let o = kn(r), { configFile: n, credentialsFile: i } = await dA(r), a = i[o] || {}, c = n[o] || {}, p = t === "config" ? { ...a, ...c } : { ...c, ...a }; try { let l = e(p, t === "config" ? n : i); if (l === void 0) throw new Error; return l } catch (u) { throw new I(u.message || `Not found in config files w/ profile [${o}]: ${cA(e.toString())}`, { logger: r.logger }) } } }); var rgt, mwe, lwe = s(() => { Z(); rgt = e => typeof e == "function", mwe = e => rgt(e) ? async () => await e() : Is(e) }); var Ut, dwe = s(() => { Z(); WTe(); uwe(); lwe(); Ut = ({ environmentVariableSelector: e, configFileSelector: t, default: r }, o = {}) => { let { signingName: n, logger: i } = o; return jr(sr(zTe(e, { signingName: n, logger: i }), pwe(t, o), mwe(r))) } }); var Jc = s(() => { dwe() }); var fwe, hwe, gwe, xwe = s(() => { rn(); fwe = "AWS_ENDPOINT_URL", hwe = "endpoint_url", gwe = e => ({ environmentVariableSelector: t => { let r = e.split(" ").map(i => i.toUpperCase()), o = t[[fwe, ...r].join("_")]; if (o) return o; let n = t[fwe]; if (n) return n }, configFileSelector: (t, r) => { if (r && t.services) { let n = r[["services", t.services].join(tn)]; if (n) { let i = e.split(" ").map(c => c.toLowerCase()), a = n[[i.join("_"), hwe].join(tn)]; if (a) return a } } let o = t[hwe]; if (o) return o }, default: void 0 }) }); var gA, U$ = s(() => { Jc(); xwe(); gA = async e => Ut(gwe(e ?? ""))() }); var xA, EA = s(() => { rg(); xA = e => typeof e == "object" ? "url" in e ? Qs(e.url) : e : Qs(e) }); var Ewe, ogt, H$ = s(() => { jTe(); VTe(); U$(); EA(); Ewe = async (e, t, r, o) => { if (!r.isCustomEndpoint) { let a; r.serviceConfiguredEndpoint ? a = await r.serviceConfiguredEndpoint() : a = await gA(r.serviceId), a && (r.endpoint = () => Promise.resolve(xA(a)), r.isCustomEndpoint = !0) } let n = await ogt(e, t, r); if (typeof r.endpointProvider != "function") throw new Error("config.endpointProvider is not set."); return r.endpointProvider(n, o) }, ogt = async (e, t, r) => { let o = {}, n = t?.getEndpointParameterInstructions?.() || {}; for (let [i, a] of Object.entries(n)) switch (a.type) { case "staticContextParams": o[i] = a.value; break; case "contextParams": o[i] = e[a.name]; break; case "clientContextParams": case "builtInParams": o[i] = await qTe(a.name, i, r, a.type !== "builtInParams")(); break; case "operationContextParams": o[i] = a.get(e); break; default: throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(a)) }return Object.keys(n).length === 0 && Object.assign(o, r), String(r.serviceId).toLowerCase() === "s3" && await HTe(o), o } }); var ywe = s(() => { H$(); EA() }); var Swe, G$ = s(() => { Ie(); gt(); H$(); Swe = ({ config: e, instructions: t }) => (r, o) => async n => { e.isCustomEndpoint && ea(o, "ENDPOINT_OVERRIDE", "N"); let i = await Ewe(n.input, { getEndpointParameterInstructions() { return t } }, { ...e }, o); o.endpointV2 = i, o.authSchemes = i.properties?.authSchemes; let a = o.authSchemes?.[0]; if (a) { o.signing_region = a.signingRegion, o.signing_service = a.signingName; let p = je(o)?.selectedHttpAuthScheme?.httpAuthOption; p && (p.signingProperties = Object.assign(p.signingProperties || {}, { signing_region: a.signingRegion, signingRegion: a.signingRegion, signing_service: a.signingName, signingName: a.signingName, signingRegionSet: a.signingRegionSet }, a.properties)) } return r({ ...n }) } }); var _we = s(() => { }); var Cwe = s(() => { }); var Rwe, Awe = s(() => { Rwe = { name: "serializerMiddleware", step: "serialize", tags: ["SERIALIZER"], override: !0 } }); var Twe = s(() => { _we(); Awe(); Cwe() }); var ngt, _e, wwe = s(() => { Twe(); G$(); ngt = { step: "serialize", tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"], name: "endpointV2Middleware", override: !0, relation: "before", toMiddleware: Rwe.name }, _e = (e, t) => ({ applyToStack: r => { r.addRelativeTo(Swe({ config: e, instructions: t }), ngt) } }) }); var yA, bwe = s(() => { gt(); U$(); EA(); yA = e => { let t = e.tls ?? !0, { endpoint: r, useDualstackEndpoint: o, useFipsEndpoint: n } = e, i = r != null ? async () => xA(await le(r)()) : void 0, c = Object.assign(e, { endpoint: i, tls: t, isCustomEndpoint: !!r, useDualstackEndpoint: le(o ?? !1), useFipsEndpoint: le(n ?? !1) }), p; return c.serviceConfiguredEndpoint = async () => (e.serviceId && !p && (p = gA(e.serviceId)), p), c } }); var Iwe = s(() => { }); var vwe = s(() => { }); var St = s(() => { ywe(); G$(); wwe(); bwe(); Iwe(); vwe() }); var Ni, sl, il, SA = s(() => { (function (e) { e.STANDARD = "standard", e.ADAPTIVE = "adaptive" })(Ni || (Ni = {})); sl = 3, il = Ni.STANDARD }); var Pwe, Owe, Dwe, kwe, Nwe, Bwe = s(() => { Pwe = ["BandwidthLimitExceeded", "EC2ThrottledException", "LimitExceededException", "PriorRequestNotComplete", "ProvisionedThroughputExceededException", "RequestLimitExceeded", "RequestThrottled", "RequestThrottledException", "SlowDown", "ThrottledException", "Throttling", "ThrottlingException", "TooManyRequestsException", "TransactionInProgressException"], Owe = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], Dwe = [500, 502, 503, 504], kwe = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], Nwe = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"] }); var sgt, igt, agt, _A, CA, Lwe, j$ = s(() => { Bwe(); sgt = e => e?.$retryable !== void 0, igt = e => e.$metadata?.clockSkewCorrected, agt = e => { let t = new Set(["Failed to fetch", "NetworkError when attempting to fetch resource", "The Internet connection appears to be offline", "Load failed", "Network request failed"]); return e && e instanceof TypeError ? t.has(e.message) : !1 }, _A = e => e.$metadata?.httpStatusCode === 429 || Pwe.includes(e.name) || e.$retryable?.throttling == !0, CA = (e, t = 0) => sgt(e) || igt(e) || Owe.includes(e.name) || kwe.includes(e?.code || "") || Nwe.includes(e?.code || "") || Dwe.includes(e.$metadata?.httpStatusCode || 0) || agt(e) || e.cause !== void 0 && t <= 10 && CA(e.cause, t + 1), Lwe = e => { if (e.$metadata?.httpStatusCode !== void 0) { let t = e.$metadata.httpStatusCode; return 500 <= t && t <= 599 && !CA(e) } return !1 } }); var RA, q$ = s(() => { j$(); RA = class e { static setTimeoutFn = setTimeout; beta; minCapacity; minFillRate; scaleConstant; smooth; currentCapacity = 0; enabled = !1; lastMaxRate = 0; measuredTxRate = 0; requestCount = 0; fillRate; lastThrottleTime; lastTimestamp = 0; lastTxRateBucket; maxCapacity; timeWindow = 0; constructor(t) { this.beta = t?.beta ?? .7, this.minCapacity = t?.minCapacity ?? 1, this.minFillRate = t?.minFillRate ?? .5, this.scaleConstant = t?.scaleConstant ?? .4, this.smooth = t?.smooth ?? .8; let r = this.getCurrentTimeInSeconds(); this.lastThrottleTime = r, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity } getCurrentTimeInSeconds() { return Date.now() / 1e3 } async getSendToken() { return this.acquireTokenBucket(1) } async acquireTokenBucket(t) { if (this.enabled) { if (this.refillTokenBucket(), t > this.currentCapacity) { let r = (t - this.currentCapacity) / this.fillRate * 1e3; await new Promise(o => e.setTimeoutFn(o, r)) } this.currentCapacity = this.currentCapacity - t } } refillTokenBucket() { let t = this.getCurrentTimeInSeconds(); if (!this.lastTimestamp) { this.lastTimestamp = t; return } let r = (t - this.lastTimestamp) * this.fillRate; this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + r), this.lastTimestamp = t } updateClientSendingRate(t) { let r; if (this.updateMeasuredRate(), _A(t)) { let n = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate; this.lastMaxRate = n, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), r = this.cubicThrottle(n), this.enableTokenBucket() } else this.calculateTimeWindow(), r = this.cubicSuccess(this.getCurrentTimeInSeconds()); let o = Math.min(r, 2 * this.measuredTxRate); this.updateTokenBucketRate(o) } calculateTimeWindow() { this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3)) } cubicThrottle(t) { return this.getPrecise(t * this.beta) } cubicSuccess(t) { return this.getPrecise(this.scaleConstant * Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate) } enableTokenBucket() { this.enabled = !0 } updateTokenBucketRate(t) { this.refillTokenBucket(), this.fillRate = Math.max(t, this.minFillRate), this.maxCapacity = Math.max(t, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity) } updateMeasuredRate() { let t = this.getCurrentTimeInSeconds(), r = Math.floor(t * 2) / 2; if (this.requestCount++, r > this.lastTxRateBucket) { let o = this.requestCount / (r - this.lastTxRateBucket); this.measuredTxRate = this.getPrecise(o * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = r } } getPrecise(t) { return parseFloat(t.toFixed(8)) } } }); var Mwe, $we, Fwe = s(() => { Mwe = "amz-sdk-invocation-id", $we = "amz-sdk-request" }); var Hwe, Gwe = s(() => { Hwe = () => { let e = 100; return { computeNextBackoffDelay: o => Math.floor(Math.min(2e4, Math.random() * 2 ** o * e)), setDelayBase: o => { e = o } } } }); var V$, jwe = s(() => { V$ = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({ getRetryCount: () => t, getRetryDelay: () => Math.min(2e4, e), getRetryCost: () => r }) }); var al, z$ = s(() => { SA(); Gwe(); jwe(); al = class { maxAttempts; mode = Ni.STANDARD; capacity = 500; retryBackoffStrategy = Hwe(); maxAttemptsProvider; constructor(t) { this.maxAttempts = t, this.maxAttemptsProvider = typeof t == "function" ? t : async () => t } async acquireInitialRetryToken(t) { return V$({ retryDelay: 100, retryCount: 0 }) } async refreshRetryTokenForRetry(t, r) { let o = await this.getMaxAttempts(); if (this.shouldRetry(t, r, o)) { let n = r.errorType; this.retryBackoffStrategy.setDelayBase(n === "THROTTLING" ? 500 : 100); let i = this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()), a = r.retryAfterHint ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i) : i, c = this.getCapacityCost(n); return this.capacity -= c, V$({ retryDelay: a, retryCount: t.getRetryCount() + 1, retryCost: c }) } throw new Error("No retry token available") } recordSuccess(t) { this.capacity = Math.max(500, this.capacity + (t.getRetryCost() ?? 1)) } getCapacity() { return this.capacity } async getMaxAttempts() { try { return await this.maxAttemptsProvider() } catch { return console.warn(`Max attempts provider could not resolve. Using default of ${sl}`), sl } } shouldRetry(t, r, o) { return t.getRetryCount() + 1 < o && this.capacity >= this.getCapacityCost(r.errorType) && this.isRetryableError(r.errorType) } getCapacityCost(t) { return t === "TRANSIENT" ? 10 : 5 } isRetryableError(t) { return t === "THROTTLING" || t === "TRANSIENT" } } }); var AA, qwe = s(() => { SA(); q$(); z$(); AA = class { maxAttemptsProvider; rateLimiter; standardRetryStrategy; mode = Ni.ADAPTIVE; constructor(t, r) { this.maxAttemptsProvider = t; let { rateLimiter: o } = r ?? {}; this.rateLimiter = o ?? new RA, this.standardRetryStrategy = new al(t) } async acquireInitialRetryToken(t) { return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(t) } async refreshRetryTokenForRetry(t, r) { return this.rateLimiter.updateClientSendingRate(r), this.standardRetryStrategy.refreshRetryTokenForRetry(t, r) } recordSuccess(t) { this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(t) } } }); var Vwe = s(() => { }); var zwe = s(() => { }); var pg = s(() => { qwe(); Vwe(); q$(); z$(); SA(); Fwe(); zwe() }); var Wwe = s(() => { }); var Kwe = s(() => { }); var Qwe, Ywe = s(() => { Qwe = e => e instanceof Error ? e : e instanceof Object ? Object.assign(new Error, e) : typeof e == "string" ? new Error(e) : new Error(`AWS SDK error wrapper for ${e}`) }); var Xwe = s(() => { }); var Jwe = s(() => { }); var Zwe, ebe, TA, wA, ugt, mgt, bA, tbe = s(() => { gt(); pg(); Zwe = "AWS_MAX_ATTEMPTS", ebe = "max_attempts", TA = { environmentVariableSelector: e => { let t = e[Zwe]; if (!t) return; let r = parseInt(t); if (Number.isNaN(r)) throw new Error(`Environment variable ${Zwe} mast be a number, got "${t}"`); return r }, configFileSelector: e => { let t = e[ebe]; if (!t) return; let r = parseInt(t); if (Number.isNaN(r)) throw new Error(`Shared config file entry ${ebe} mast be a number, got "${t}"`); return r }, default: sl }, wA = e => { let { retryStrategy: t, retryMode: r, maxAttempts: o } = e, n = le(o ?? sl); return Object.assign(e, { maxAttempts: n, retryStrategy: async () => t || (await le(r)() === Ni.ADAPTIVE ? new AA(n) : new al(n)) }) }, ugt = "AWS_RETRY_MODE", mgt = "retry_mode", bA = { environmentVariableSelector: e => e[ugt], configFileSelector: e => e[mgt], default: il } }); var rbe = s(() => { }); var Zc, $a, cl, obe, nbe, sbe = s(() => { Zc = (e, t) => { let r = []; if (e && r.push(e), t) for (let o of t) r.push(o); return r }, $a = (e, t) => `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`, cl = () => { let e = [], t = [], r = !1, o = new Set, n = m => m.sort((f, h) => obe[h.step] - obe[f.step] || nbe[h.priority || "normal"] - nbe[f.priority || "normal"]), i = m => { let f = !1, h = E => { let S = Zc(E.name, E.aliases); if (S.includes(m)) { f = !0; for (let y of S) o.delete(y); return !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, a = m => { let f = !1, h = E => { if (E.middleware === m) { f = !0; for (let S of Zc(E.name, E.aliases)) o.delete(S); return !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, c = m => (e.forEach(f => { m.add(f.middleware, { ...f }) }), t.forEach(f => { m.addRelativeTo(f.middleware, { ...f }) }), m.identifyOnResolve?.(l.identifyOnResolve()), m), p = m => { let f = []; return m.before.forEach(h => { h.before.length === 0 && h.after.length === 0 ? f.push(h) : f.push(...p(h)) }), f.push(m), m.after.reverse().forEach(h => { h.before.length === 0 && h.after.length === 0 ? f.push(h) : f.push(...p(h)) }), f }, u = (m = !1) => { let f = [], h = [], E = {}; return e.forEach(y => { let C = { ...y, before: [], after: [] }; for (let b of Zc(C.name, C.aliases)) E[b] = C; f.push(C) }), t.forEach(y => { let C = { ...y, before: [], after: [] }; for (let b of Zc(C.name, C.aliases)) E[b] = C; h.push(C) }), h.forEach(y => { if (y.toMiddleware) { let C = E[y.toMiddleware]; if (C === void 0) { if (m) return; throw new Error(`${y.toMiddleware} is not found when adding ${$a(y.name, y.aliases)} middleware ${y.relation} ${y.toMiddleware}`) } y.relation === "after" && C.after.push(y), y.relation === "before" && C.before.push(y) } }), n(f).map(p).reduce((y, C) => (y.push(...C), y), []) }, l = { add: (m, f = {}) => { let { name: h, override: E, aliases: S } = f, y = { step: "initialize", priority: "normal", middleware: m, ...f }, C = Zc(h, S); if (C.length > 0) { if (C.some(b => o.has(b))) { if (!E) throw new Error(`Duplicate middleware name '${$a(h, S)}'`); for (let b of C) { let L = e.findIndex(j => j.name === b || j.aliases?.some(re => re === b)); if (L === -1) continue; let N = e[L]; if (N.step !== y.step || y.priority !== N.priority) throw new Error(`"${$a(N.name, N.aliases)}" middleware with ${N.priority} priority in ${N.step} step cannot be overridden by "${$a(h, S)}" middleware with ${y.priority} priority in ${y.step} step.`); e.splice(L, 1) } } for (let b of C) o.add(b) } e.push(y) }, addRelativeTo: (m, f) => { let { name: h, override: E, aliases: S } = f, y = { middleware: m, ...f }, C = Zc(h, S); if (C.length > 0) { if (C.some(b => o.has(b))) { if (!E) throw new Error(`Duplicate middleware name '${$a(h, S)}'`); for (let b of C) { let L = t.findIndex(j => j.name === b || j.aliases?.some(re => re === b)); if (L === -1) continue; let N = t[L]; if (N.toMiddleware !== y.toMiddleware || N.relation !== y.relation) throw new Error(`"${$a(N.name, N.aliases)}" middleware ${N.relation} "${N.toMiddleware}" middleware cannot be overridden by "${$a(h, S)}" middleware ${y.relation} "${y.toMiddleware}" middleware.`); t.splice(L, 1) } } for (let b of C) o.add(b) } t.push(y) }, clone: () => c(cl()), use: m => { m.applyToStack(l) }, remove: m => typeof m == "string" ? i(m) : a(m), removeByTag: m => { let f = !1, h = E => { let { tags: S, name: y, aliases: C } = E; if (S && S.includes(m)) { let b = Zc(y, C); for (let L of b) o.delete(L); return f = !0, !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, concat: m => { let f = c(cl()); return f.use(m), f.identifyOnResolve(r || f.identifyOnResolve() || (m.identifyOnResolve?.() ?? !1)), f }, applyToStack: c, identify: () => u(!0).map(m => { let f = m.step ?? m.relation + " " + m.toMiddleware; return $a(m.name, m.aliases) + " - " + f }), identifyOnResolve(m) { return typeof m == "boolean" && (r = m), r }, resolve: (m, f) => { for (let h of u().map(E => E.middleware).reverse()) m = h(m, f); return r && console.log(l.identify()), m } }; return l }, obe = { initialize: 5, serialize: 4, build: 3, finalizeRequest: 2, deserialize: 1 }, nbe = { high: 3, normal: 2, low: 1 } }); var W$ = s(() => { sbe() }); var pl, ibe = s(() => { W$(); pl = class { config; middlewareStack = cl(); initConfig; handlers; constructor(t) { this.config = t; let { protocol: r, protocolSettings: o } = t; o && typeof r == "function" && (t.protocol = new r(o)) } send(t, r, o) { let n = typeof r != "function" ? r : void 0, i = typeof r == "function" ? r : o, a = n === void 0 && this.config.cacheMiddleware === !0, c; if (a) { this.handlers || (this.handlers = new WeakMap); let p = this.handlers; p.has(t.constructor) ? c = p.get(t.constructor) : (c = t.resolveMiddleware(this.middlewareStack, this.config, n), p.set(t.constructor, c)) } else delete this.handlers, c = t.resolveMiddleware(this.middlewareStack, this.config, n); if (i) c(t).then(p => i(null, p.output), p => i(p)).catch(() => { }); else return c(t).then(p => p.output) } destroy() { this.config?.requestHandler?.destroy?.(), delete this.handlers } } }); var abe = s(() => { }); function IA(e, t) { if (t == null) return t; let r = ue.of(e); if (r.getMergedTraits().sensitive) return K$; if (r.isListSchema()) { if (!!r.getValueSchema().getMergedTraits().sensitive) return K$ } else if (r.isMapSchema()) { if (!!r.getKeySchema().getMergedTraits().sensitive || !!r.getValueSchema().getMergedTraits().sensitive) return K$ } else if (r.isStructSchema() && typeof t == "object") { let o = t, n = {}; for (let [i, a] of r.structIterator()) o[i] != null && (n[i] = IA(a, o[i])); return n } return t } var K$, cbe = s(() => { Oe(); K$ = "***SensitiveInformation***" }); var Se, Q$, pbe = s(() => { W$(); Zm(); cbe(); Se = class { middlewareStack = cl(); schema; static classBuilder() { return new Q$ } resolveMiddlewareWithContext(t, r, o, { middlewareFn: n, clientName: i, commandName: a, inputFilterSensitiveLog: c, outputFilterSensitiveLog: p, smithyContext: u, additionalContext: l, CommandCtor: m }) { for (let y of n.bind(this)(m, t, r, o)) this.middlewareStack.use(y); let f = t.concat(this.middlewareStack), { logger: h } = r, E = { logger: h, clientName: i, commandName: a, inputFilterSensitiveLog: c, outputFilterSensitiveLog: p, [bRe]: { commandInstance: this, ...u }, ...l }, { requestHandler: S } = r; return f.resolve(y => S.handle(y.request, o || {}), E) } }, Q$ = class { _init = () => { }; _ep = {}; _middlewareFn = () => []; _commandName = ""; _clientName = ""; _additionalContext = {}; _smithyContext = {}; _inputFilterSensitiveLog = void 0; _outputFilterSensitiveLog = void 0; _serializer = null; _deserializer = null; _operationSchema; init(t) { this._init = t } ep(t) { return this._ep = t, this } m(t) { return this._middlewareFn = t, this } s(t, r, o = {}) { return this._smithyContext = { service: t, operation: r, ...o }, this } c(t = {}) { return this._additionalContext = t, this } n(t, r) { return this._clientName = t, this._commandName = r, this } f(t = o => o, r = o => o) { return this._inputFilterSensitiveLog = t, this._outputFilterSensitiveLog = r, this } ser(t) { return this._serializer = t, this } de(t) { return this._deserializer = t, this } sc(t) { return this._operationSchema = t, this._smithyContext.operationSchema = t, this } build() { let t = this, r; return r = class extends Se { input; static getEndpointParameterInstructions() { return t._ep } constructor(...[o]) { super(), this.input = o ?? {}, t._init(this), this.schema = t._operationSchema } resolveMiddleware(o, n, i) { let a = t._operationSchema, c = a?.[4] ?? a?.input, p = a?.[5] ?? a?.output; return this.resolveMiddlewareWithContext(o, n, i, { CommandCtor: r, middlewareFn: t._middlewareFn, clientName: t._clientName, commandName: t._commandName, inputFilterSensitiveLog: t._inputFilterSensitiveLog ?? (a ? IA.bind(null, c) : u => u), outputFilterSensitiveLog: t._outputFilterSensitiveLog ?? (a ? IA.bind(null, p) : u => u), smithyContext: t._smithyContext, additionalContext: t._additionalContext }) } serialize = t._serializer; deserialize = t._deserializer } } } }); var ube = s(() => { }); var vA, mbe = s(() => { vA = (e, t) => { for (let r of Object.keys(e)) { let o = e[r], n = async function (a, c, p) { let u = new o(a); if (typeof c == "function") this.send(u, c); else if (typeof p == "function") { if (typeof c != "object") throw new Error(`Expected http options but got ${typeof c}`); this.send(u, c || {}, p) } else return this.send(u, c) }, i = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, ""); t.prototype[i] = n } } }); var ul, lbe = s(() => { ul = class e extends Error { $fault; $response; $retryable; $metadata; constructor(t) { super(t.message), Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = t.name, this.$fault = t.$fault, this.$metadata = t.$metadata } static isInstance(t) { if (!t) return !1; let r = t; return e.prototype.isPrototypeOf(r) || !!r.$fault && !!r.$metadata && (r.$fault === "client" || r.$fault === "server") } static [Symbol.hasInstance](t) { if (!t) return !1; let r = t; return this === e ? e.isInstance(t) : e.isInstance(t) ? r.name && this.name ? this.prototype.isPrototypeOf(t) || r.name === this.name : this.prototype.isPrototypeOf(t) : !1 } } }); var dbe = s(() => { }); var PA, fbe = s(() => { PA = e => { switch (e) { case "standard": return { retryMode: "standard", connectionTimeout: 3100 }; case "in-region": return { retryMode: "standard", connectionTimeout: 1100 }; case "cross-region": return { retryMode: "standard", connectionTimeout: 3100 }; case "mobile": return { retryMode: "standard", connectionTimeout: 3e4 }; default: return {} } } }); var hbe, OA, gbe = s(() => { hbe = !1, OA = e => { e && !hbe && parseInt(e.substring(1, e.indexOf("."))) < 16 && (hbe = !0) } }); var xbe = s(() => { }); var Ebe, ybe, Sbe = s(() => { Zm(); Ebe = e => { let t = []; for (let r in Jm) { let o = Jm[r]; e[o] !== void 0 && t.push({ algorithmId: () => o, checksumConstructor: () => e[o] }) } return { addChecksumAlgorithm(r) { t.push(r) }, checksumAlgorithms() { return t } } }, ybe = e => { let t = {}; return e.checksumAlgorithms().forEach(r => { t[r.algorithmId()] = r.checksumConstructor() }), t } }); var _be, Cbe, Rbe = s(() => { _be = e => ({ setRetryStrategy(t) { e.retryStrategy = t }, retryStrategy() { return e.retryStrategy } }), Cbe = e => { let t = {}; return t.retryStrategy = e.retryStrategy(), t } }); var DA, kA, Abe = s(() => { Sbe(); Rbe(); DA = e => Object.assign(Ebe(e), _be(e)), kA = e => Object.assign(ybe(e), Cbe(e)) }); var Tbe = s(() => { Abe() }); var wbe = s(() => { }); var bbe = s(() => { }); var Ibe = s(() => { }); var Fa, vbe = s(() => { Fa = class { trace() { } debug() { } info() { } warn() { } error() { } } }); var Pbe = s(() => { }); var Obe = s(() => { }); var Dbe = s(() => { }); var kbe = s(() => { }); var Be = s(() => { ibe(); abe(); pbe(); ube(); mbe(); dbe(); fbe(); gbe(); lbe(); xbe(); Tbe(); wbe(); bbe(); Ibe(); vbe(); Pbe(); Obe(); Dbe(); kbe(); Pr() }); import { Readable as lgt } from "stream"; var Nbe, Bbe = s(() => { Nbe = e => e?.body instanceof lgt || typeof ReadableStream < "u" && e?.body instanceof ReadableStream }); var dgt, fgt, hgt, ggt, xgt, NA, Egt, Lbe = s(() => { ki(); j$(); Be(); pg(); Wp(); Bbe(); Ywe(); dgt = e => (t, r) => async o => { let n = await e.retryStrategy(), i = await e.maxAttempts(); if (fgt(n)) { n = n; let a = await n.acquireInitialRetryToken(r.partition_id), c = new Error, p = 0, u = 0, { request: l } = o, m = Dn.isInstance(l); for (m && (l.headers[Mwe] = ro()); ;)try { m && (l.headers[$we] = `attempt=${p + 1}; max=${i}`); let { response: f, output: h } = await t(o); return n.recordSuccess(a), h.$metadata.attempts = p + 1, h.$metadata.totalRetryDelay = u, { response: f, output: h } } catch (f) { let h = hgt(f); if (c = Qwe(f), m && Nbe(l)) throw (r.logger instanceof Fa ? console : r.logger)?.warn("An error was encountered in a non-retryable streaming request."), c; try { a = await n.refreshRetryTokenForRetry(a, h) } catch { throw c.$metadata || (c.$metadata = {}), c.$metadata.attempts = p + 1, c.$metadata.totalRetryDelay = u, c } p = a.getRetryCount(); let E = a.getRetryDelay(); u += E, await new Promise(S => setTimeout(S, E)) } } else return n = n, n?.mode && (r.userAgent = [...r.userAgent || [], ["cfg/retry-mode", n.mode]]), n.retry(t, o) }, fgt = e => typeof e.acquireInitialRetryToken < "u" && typeof e.refreshRetryTokenForRetry < "u" && typeof e.recordSuccess < "u", hgt = e => { let t = { error: e, errorType: ggt(e) }, r = Egt(e.$response); return r && (t.retryAfterHint = r), t }, ggt = e => _A(e) ? "THROTTLING" : CA(e) ? "TRANSIENT" : Lwe(e) ? "SERVER_ERROR" : "CLIENT_ERROR", xgt = { name: "retryMiddleware", tags: ["RETRY"], step: "finalizeRequest", priority: "high", override: !0 }, NA = e => ({ applyToStack: t => { t.add(dgt(e), xgt) } }), Egt = e => { if (!el.isInstance(e)) return; let t = Object.keys(e.headers).find(i => i.toLowerCase() === "retry-after"); if (!t) return; let r = e.headers[t], o = Number(r); return Number.isNaN(o) ? new Date(r) : new Date(o * 1e3) } }); var ug = s(() => { Jwe(); Xwe(); tbe(); Wwe(); rbe(); Kwe(); Lbe() }); function ygt(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "sqs", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } var Mbe, $be, Fbe, Y$ = s(() => { Ye(); gt(); Mbe = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }); $be = e => { let t = []; switch (e.operation) { default: t.push(ygt(e)) }return t }, Fbe = e => { let t = qr(e); return Object.assign(t, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var Ube, ve, zt = s(() => { Ube = e => Object.assign(e, { useDualstackEndpoint: e.useDualstackEndpoint ?? !1, useFipsEndpoint: e.useFipsEndpoint ?? !1, defaultSigningName: "sqs" }), ve = { UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" } } }); var Gbe, Hbe = s(() => { Gbe = { name: "@aws-sdk/client-sqs", description: "AWS SDK for JavaScript Sqs Client for Node.js, Browser and React Native", version: "3.962.0", scripts: { build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs", "build:cjs": "node ../../scripts/compilation/inline client-sqs", "build:es": "tsc -p tsconfig.es.json", "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"', "build:types": "tsc -p tsconfig.types.json", "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4", clean: "rimraf ./dist-* && rimraf *.tsbuildinfo", "extract:docs": "api-extractor run --local", "generate:client": "node ../../scripts/generate-clients/single-service --solo sqs", "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts", "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts", "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs" }, main: "./dist-cjs/index.js", types: "./dist-types/index.d.ts", module: "./dist-es/index.js", sideEffects: !1, dependencies: { "@aws-crypto/sha256-browser": "5.2.0", "@aws-crypto/sha256-js": "5.2.0", "@aws-sdk/core": "3.957.0", "@aws-sdk/credential-provider-node": "3.962.0", "@aws-sdk/middleware-host-header": "3.957.0", "@aws-sdk/middleware-logger": "3.957.0", "@aws-sdk/middleware-recursion-detection": "3.957.0", "@aws-sdk/middleware-sdk-sqs": "3.957.0", "@aws-sdk/middleware-user-agent": "3.957.0", "@aws-sdk/region-config-resolver": "3.957.0", "@aws-sdk/types": "3.957.0", "@aws-sdk/util-endpoints": "3.957.0", "@aws-sdk/util-user-agent-browser": "3.957.0", "@aws-sdk/util-user-agent-node": "3.957.0", "@smithy/config-resolver": "^4.4.5", "@smithy/core": "^3.20.0", "@smithy/fetch-http-handler": "^5.3.8", "@smithy/hash-node": "^4.2.7", "@smithy/invalid-dependency": "^4.2.7", "@smithy/md5-js": "^4.2.7", "@smithy/middleware-content-length": "^4.2.7", "@smithy/middleware-endpoint": "^4.4.1", "@smithy/middleware-retry": "^4.4.17", "@smithy/middleware-serde": "^4.2.8", "@smithy/middleware-stack": "^4.2.7", "@smithy/node-config-provider": "^4.3.7", "@smithy/node-http-handler": "^4.4.7", "@smithy/protocol-http": "^5.3.7", "@smithy/smithy-client": "^4.10.2", "@smithy/types": "^4.11.0", "@smithy/url-parser": "^4.2.7", "@smithy/util-base64": "^4.3.0", "@smithy/util-body-length-browser": "^4.2.0", "@smithy/util-body-length-node": "^4.2.1", "@smithy/util-defaults-mode-browser": "^4.3.16", "@smithy/util-defaults-mode-node": "^4.2.19", "@smithy/util-endpoints": "^3.2.7", "@smithy/util-middleware": "^4.2.7", "@smithy/util-retry": "^4.2.7", "@smithy/util-utf8": "^4.2.0", tslib: "^2.6.2" }, devDependencies: { "@tsconfig/node18": "18.2.4", "@types/node": "^18.19.69", concurrently: "7.0.0", "downlevel-dts": "0.10.1", rimraf: "3.0.2", typescript: "~5.8.3" }, engines: { node: ">=18.0.0" }, typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } }, files: ["dist-*/**"], author: { name: "AWS SDK for JavaScript Team", url: "https://aws.amazon.com/javascript/" }, license: "Apache-2.0", browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" }, "react-native": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native" }, homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sqs", repository: { type: "git", url: "https://github.com/aws/aws-sdk-js-v3.git", directory: "clients/client-sqs" } } }); var BA, LA, jbe, qbe, Vbe, zbe, X$, Wbe = s(() => { He(); Z(); BA = "AWS_ACCESS_KEY_ID", LA = "AWS_SECRET_ACCESS_KEY", jbe = "AWS_SESSION_TOKEN", qbe = "AWS_CREDENTIAL_EXPIRATION", Vbe = "AWS_CREDENTIAL_SCOPE", zbe = "AWS_ACCOUNT_ID", X$ = e => async () => { e?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv"); let t = process.env[BA], r = process.env[LA], o = process.env[jbe], n = process.env[qbe], i = process.env[Vbe], a = process.env[zbe]; if (t && r) { let c = { accessKeyId: t, secretAccessKey: r, ...o && { sessionToken: o }, ...n && { expiration: new Date(n) }, ...i && { credentialScope: i }, ...a && { accountId: a } }; return ee(c, "CREDENTIALS_ENV_VARS", "g"), c } throw new I("Unable to find environment variable credentials.", { logger: e?.logger }) } }); var Kbe = {}; Qe(Kbe, { ENV_ACCOUNT_ID: () => zbe, ENV_CREDENTIAL_SCOPE: () => Vbe, ENV_EXPIRATION: () => qbe, ENV_KEY: () => BA, ENV_SECRET: () => LA, ENV_SESSION: () => jbe, fromEnv: () => X$ }); var J$ = s(() => { Wbe() }); import { Buffer as _gt } from "buffer"; import { request as Cgt } from "http"; function Ua(e) { return new Promise((t, r) => { let o = Cgt({ method: "GET", ...e, hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1") }); o.on("error", n => { r(Object.assign(new kt("Unable to connect to instance metadata service"), n)), o.destroy() }), o.on("timeout", () => { r(new kt("TimeoutError from instance metadata service")), o.destroy() }), o.on("response", n => { let { statusCode: i = 400 } = n; (i < 200 || 300 <= i) && (r(Object.assign(new kt("Error response received from instance metadata service"), { statusCode: i })), o.destroy()); let a = []; n.on("data", c => { a.push(c) }), n.on("end", () => { t(_gt.concat(a)), o.destroy() }) }), o.end() }) } var MA = s(() => { Z() }); var $A, FA, Z$ = s(() => { $A = e => !!e && typeof e == "object" && typeof e.AccessKeyId == "string" && typeof e.SecretAccessKey == "string" && typeof e.Token == "string" && typeof e.Expiration == "string", FA = e => ({ accessKeyId: e.AccessKeyId, secretAccessKey: e.SecretAccessKey, sessionToken: e.Token, expiration: new Date(e.Expiration), ...e.AccountId && { accountId: e.AccountId } }) }); var IXr, vXr, mg, UA = s(() => { IXr = 1e3, vXr = 0, mg = ({ maxRetries: e = 0, timeout: t = 1e3 }) => ({ maxRetries: e, timeout: t }) }); var lg, eF = s(() => { lg = (e, t) => { let r = e(); for (let o = 0; o < t; o++)r = r.catch(e); return r } }); import { parse as Rgt } from "url"; var HA, GA, tF, Agt, Tgt, wgt, bgt, Igt, vgt, Qbe = s(() => { Z(); MA(); Z$(); UA(); eF(); HA = "AWS_CONTAINER_CREDENTIALS_FULL_URI", GA = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", tF = "AWS_CONTAINER_AUTHORIZATION_TOKEN", Agt = (e = {}) => { let { timeout: t, maxRetries: r } = mg(e); return () => lg(async () => { let o = await vgt({ logger: e.logger }), n = JSON.parse(await Tgt(t, o)); if (!$A(n)) throw new I("Invalid response received from instance metadata service.", { logger: e.logger }); return FA(n) }, r) }, Tgt = async (e, t) => (process.env[tF] && (t.headers = { ...t.headers, Authorization: process.env[tF] }), (await Ua({ ...t, timeout: e })).toString()), wgt = "169.254.170.2", bgt = { localhost: !0, "127.0.0.1": !0 }, Igt = { "http:": !0, "https:": !0 }, vgt = async ({ logger: e }) => { if (process.env[GA]) return { hostname: wgt, path: process.env[GA] }; if (process.env[HA]) { let t = Rgt(process.env[HA]); if (!t.hostname || !(t.hostname in bgt)) throw new I(`${t.hostname} is not a valid container metadata service hostname`, { tryNextLink: !1, logger: e }); if (!t.protocol || !(t.protocol in Igt)) throw new I(`${t.protocol} is not a valid container metadata service protocol`, { tryNextLink: !1, logger: e }); return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 } } throw new I(`The container metadata credential provider cannot be used unless the ${GA} or ${HA} environment variable is set`, { tryNextLink: !1, logger: e }) } }); var jA, Ybe = s(() => { Z(); jA = class e extends I { tryNextLink; name = "InstanceMetadataV1FallbackError"; constructor(t, r = !0) { super(t, r), this.tryNextLink = r, Object.setPrototypeOf(this, e.prototype) } } }); var ep, rF = s(() => { (function (e) { e.IPv4 = "http://169.254.169.254", e.IPv6 = "http://[fd00:ec2::254]" })(ep || (ep = {})) }); var Pgt, Ogt, Xbe, Jbe = s(() => { Pgt = "AWS_EC2_METADATA_SERVICE_ENDPOINT", Ogt = "ec2_metadata_service_endpoint", Xbe = { environmentVariableSelector: e => e[Pgt], configFileSelector: e => e[Ogt], default: void 0 } }); var Ha, oF = s(() => { (function (e) { e.IPv4 = "IPv4", e.IPv6 = "IPv6" })(Ha || (Ha = {})) }); var Dgt, kgt, Zbe, e0e = s(() => { oF(); Dgt = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE", kgt = "ec2_metadata_service_endpoint_mode", Zbe = { environmentVariableSelector: e => e[Dgt], configFileSelector: e => e[kgt], default: Ha.IPv4 } }); var qA, Ngt, Bgt, nF = s(() => { Jc(); rg(); rF(); Jbe(); oF(); e0e(); qA = async () => Qs(await Ngt() || await Bgt()), Ngt = async () => Ut(Xbe)(), Bgt = async () => { let e = await Ut(Zbe)(); switch (e) { case Ha.IPv4: return ep.IPv4; case Ha.IPv6: return ep.IPv6; default: throw new Error(`Unsupported endpoint mode: ${e}. Select from ${Object.values(Ha)}`) } } }); var Lgt, sF, t0e = s(() => {
  Lgt = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html", sF = (e, t) => {
    let r = 300 + Math.floor(Math.random() * 300), o = new Date(Date.now() + r * 1e3); t.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: `+ Lgt); let n = e.originalExpiration ?? e.expiration; return { ...e, ...n ? { originalExpiration: n } : {}, expiration: o }
  }
}); var r0e, o0e = s(() => { t0e(); r0e = (e, t = {}) => { let r = t?.logger || console, o; return async () => { let n; try { n = await e(), n.expiration && n.expiration.getTime() < Date.now() && (n = sF(n, r)) } catch (i) { if (o) r.warn("Credential renew failed: ", i), n = sF(o, r); else throw i } return o = n, n } } }); var i0e, Mgt, iF, n0e, s0e, $gt, Fgt, Ugt, Hgt, Ggt, a0e = s(() => { Jc(); Z(); Ybe(); MA(); Z$(); UA(); eF(); nF(); o0e(); i0e = "/latest/meta-data/iam/security-credentials/", Mgt = "/latest/api/token", iF = "AWS_EC2_METADATA_V1_DISABLED", n0e = "ec2_metadata_v1_disabled", s0e = "x-aws-ec2-metadata-token", $gt = (e = {}) => r0e(Fgt(e), { logger: e.logger }), Fgt = (e = {}) => { let t = !1, { logger: r, profile: o } = e, { timeout: n, maxRetries: i } = mg(e), a = async (c, p) => { if (t || p.headers?.[s0e] == null) { let m = !1, f = !1, h = await Ut({ environmentVariableSelector: E => { let S = E[iF]; if (f = !!S && S !== "false", S === void 0) throw new I(`${iF} not set in env, checking config file next.`, { logger: e.logger }); return f }, configFileSelector: E => { let S = E[n0e]; return m = !!S && S !== "false", m }, default: !1 }, { profile: o })(); if (e.ec2MetadataV1Disabled || h) { let E = []; throw e.ec2MetadataV1Disabled && E.push("credential provider initialization (runtime option ec2MetadataV1Disabled)"), m && E.push(`config file profile (${n0e})`), f && E.push(`process environment variable (${iF})`), new jA(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${E.join(", ")}].`) } } let l = (await lg(async () => { let m; try { m = await Hgt(p) } catch (f) { throw f.statusCode === 401 && (t = !1), f } return m }, c)).trim(); return lg(async () => { let m; try { m = await Ggt(l, p, e) } catch (f) { throw f.statusCode === 401 && (t = !1), f } return m }, c) }; return async () => { let c = await qA(); if (t) return r?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)"), a(i, { ...c, timeout: n }); { let p; try { p = (await Ugt({ ...c, timeout: n })).toString() } catch (u) { if (u?.statusCode === 400) throw Object.assign(u, { message: "EC2 Metadata token request returned error" }); return (u.message === "TimeoutError" || [403, 404, 405].includes(u.statusCode)) && (t = !0), r?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)"), a(i, { ...c, timeout: n }) } return a(i, { ...c, headers: { [s0e]: p }, timeout: n }) } } }, Ugt = async e => Ua({ ...e, path: Mgt, method: "PUT", headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" } }), Hgt = async e => (await Ua({ ...e, path: i0e })).toString(), Ggt = async (e, t, r) => { let o = JSON.parse((await Ua({ ...t, path: i0e + e })).toString()); if (!$A(o)) throw new I("Invalid response received from instance metadata service.", { logger: r.logger }); return FA(o) } }); var c0e = s(() => { }); var dg = {}; Qe(dg, { DEFAULT_MAX_RETRIES: () => vXr, DEFAULT_TIMEOUT: () => IXr, ENV_CMDS_AUTH_TOKEN: () => tF, ENV_CMDS_FULL_URI: () => HA, ENV_CMDS_RELATIVE_URI: () => GA, Endpoint: () => ep, fromContainerMetadata: () => Agt, fromInstanceMetadata: () => $gt, getInstanceMetadataEndpoint: () => qA, httpRequest: () => Ua, providerConfigFromInit: () => mg }); var fg = s(() => { Qbe(); a0e(); UA(); c0e(); MA(); nF(); rF() }); var p0e, u0e, m0e = s(() => { Z(); p0e = "AWS_EC2_METADATA_DISABLED", u0e = async e => { let { ENV_CMDS_FULL_URI: t, ENV_CMDS_RELATIVE_URI: r, fromContainerMetadata: o, fromInstanceMetadata: n } = await Promise.resolve().then(() => (fg(), dg)); if (process.env[r] || process.env[t]) { e.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata"); let { fromHttp: i } = await Promise.resolve().then(() => (vc(), Ic)); return sr(i(e), o(e)) } return process.env[p0e] && process.env[p0e] !== "false" ? async () => { throw new I("EC2 Instance Metadata Service access disabled", { logger: e.logger }) } : (e.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"), n(e)) } }); function l0e(e, t) { let r = jgt(e), o, n, i, a = async c => { if (c?.forceRefresh) return await r(c); if (i?.expiration && i?.expiration?.getTime() < Date.now() && (i = void 0), o) await o; else if (!i || t?.(i)) if (i) n || (n = r(c).then(p => { i = p, n = void 0 })); else return o = r(c).then(p => { i = p, o = void 0 }), a(c); return i }; return a } var jgt, d0e = s(() => { jgt = e => async t => { let r; for (let o of e) try { return await o(t) } catch (n) { if (r = n, n?.tryNextLink) continue; throw n } throw r } }); var aF, cF = s(() => { aF = e => e && (typeof e.sso_start_url == "string" || typeof e.sso_account_id == "string" || typeof e.sso_session == "string" || typeof e.sso_region == "string" || typeof e.sso_role_name == "string") }); var f0e = s(() => { }); var ml, VA = s(() => { ml = "To refresh this SSO session run 'aws sso login' with the corresponding profile." }); var h0e, g0e = s(() => { h0e = async (e, t = {}, r) => { let { SSOOIDCClient: o } = await Promise.resolve().then(() => ($c(), Mc)), n = a => t.clientConfig?.[a] ?? t.parentClientConfig?.[a] ?? r?.[a]; return new o(Object.assign({}, t.clientConfig ?? {}, { region: e ?? t.clientConfig?.region, logger: n("logger"), userAgentAppId: n("userAgentAppId") })) } }); var x0e, E0e = s(() => { g0e(); x0e = async (e, t, r = {}, o) => { let { CreateTokenCommand: n } = await Promise.resolve().then(() => ($c(), Mc)); return (await h0e(t, r, o)).send(new n({ clientId: e.clientId, clientSecret: e.clientSecret, refreshToken: e.refreshToken, grantType: "refresh_token" })) } }); var pF, y0e = s(() => { Z(); VA(); pF = e => { if (e.expiration && e.expiration.getTime() < Date.now()) throw new at(`Token is expired. ${ml}`, !1) } }); var Ga, S0e = s(() => { Z(); VA(); Ga = (e, t, r = !1) => { if (typeof t > "u") throw new at(`Value not present for '${e}' in SSO Token${r ? ". Cannot refresh" : ""}. ${ml}`, !1) } }); import { promises as qgt } from "fs"; var Vgt, _0e, C0e = s(() => { rn(); ({ writeFile: Vgt } = qgt), _0e = (e, t) => { let r = pA(e), o = JSON.stringify(t, null, 2); return Vgt(r, o) } }); var R0e, A0e, T0e = s(() => { Z(); rn(); VA(); E0e(); y0e(); S0e(); C0e(); R0e = new Date(0), A0e = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/token-providers - fromSso"); let r = await Ma(e), o = kn({ profile: e.profile ?? t?.profile }), n = r[o]; if (n) { if (!n.sso_session) throw new at(`Profile '${o}' is missing required property 'sso_session'.`) } else throw new at(`Profile '${o}' could not be found in shared credentials file.`, !1); let i = n.sso_session, c = (await hA(e))[i]; if (!c) throw new at(`Sso session '${i}' could not be found in shared credentials file.`, !1); for (let E of ["sso_start_url", "sso_region"]) if (!c[E]) throw new at(`Sso session '${i}' is missing required property '${E}'.`, !1); let p = c.sso_start_url, u = c.sso_region, l; try { l = await ng(i) } catch { throw new at(`The SSO session token associated with profile=${o} was not found or is invalid. ${ml}`, !1) } Ga("accessToken", l.accessToken), Ga("expiresAt", l.expiresAt); let { accessToken: m, expiresAt: f } = l, h = { token: m, expiration: new Date(f) }; if (h.expiration.getTime() - Date.now() > 3e5) return h; if (Date.now() - R0e.getTime() < 30 * 1e3) return pF(h), h; Ga("clientId", l.clientId, !0), Ga("clientSecret", l.clientSecret, !0), Ga("refreshToken", l.refreshToken, !0); try { R0e.setTime(Date.now()); let E = await x0e(l, u, e, t); Ga("accessToken", E.accessToken), Ga("expiresIn", E.expiresIn); let S = new Date(Date.now() + E.expiresIn * 1e3); try { await _0e(i, { ...l, accessToken: E.accessToken, expiresAt: S.toISOString(), refreshToken: E.refreshToken }) } catch { } return { token: E.accessToken, expiration: S } } catch { return pF(h), h } } }); var w0e = s(() => { }); var b0e = s(() => { }); var I0e = s(() => { f0e(); T0e(); w0e(); b0e() }); function Wgt(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "awsssoportal", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } function zA(e) { return { schemeId: "smithy.api#noAuth" } } var v0e, P0e, O0e, uF = s(() => { Ye(); gt(); v0e = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }); P0e = e => { let t = []; switch (e.operation) { case "GetRoleCredentials": { t.push(zA(e)); break } case "ListAccountRoles": { t.push(zA(e)); break } case "ListAccounts": { t.push(zA(e)); break } case "Logout": { t.push(zA(e)); break } default: t.push(Wgt(e)) }return t }, O0e = e => { let t = qr(e); return Object.assign(t, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var D0e, ja, ll = s(() => { D0e = e => Object.assign(e, { useDualstackEndpoint: e.useDualstackEndpoint ?? !1, useFipsEndpoint: e.useFipsEndpoint ?? !1, defaultSigningName: "awsssoportal" }), ja = { UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" } } }); var N0e, k0e = s(() => { N0e = { name: "@aws-sdk/client-sso", description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native", version: "3.958.0", scripts: { build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs", "build:cjs": "node ../../scripts/compilation/inline client-sso", "build:es": "tsc -p tsconfig.es.json", "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"', "build:types": "tsc -p tsconfig.types.json", "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4", clean: "rimraf ./dist-* && rimraf *.tsbuildinfo", "extract:docs": "api-extractor run --local", "generate:client": "node ../../scripts/generate-clients/single-service --solo sso", "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs" }, main: "./dist-cjs/index.js", types: "./dist-types/index.d.ts", module: "./dist-es/index.js", sideEffects: !1, dependencies: { "@aws-crypto/sha256-browser": "5.2.0", "@aws-crypto/sha256-js": "5.2.0", "@aws-sdk/core": "3.957.0", "@aws-sdk/middleware-host-header": "3.957.0", "@aws-sdk/middleware-logger": "3.957.0", "@aws-sdk/middleware-recursion-detection": "3.957.0", "@aws-sdk/middleware-user-agent": "3.957.0", "@aws-sdk/region-config-resolver": "3.957.0", "@aws-sdk/types": "3.957.0", "@aws-sdk/util-endpoints": "3.957.0", "@aws-sdk/util-user-agent-browser": "3.957.0", "@aws-sdk/util-user-agent-node": "3.957.0", "@smithy/config-resolver": "^4.4.5", "@smithy/core": "^3.20.0", "@smithy/fetch-http-handler": "^5.3.8", "@smithy/hash-node": "^4.2.7", "@smithy/invalid-dependency": "^4.2.7", "@smithy/middleware-content-length": "^4.2.7", "@smithy/middleware-endpoint": "^4.4.1", "@smithy/middleware-retry": "^4.4.17", "@smithy/middleware-serde": "^4.2.8", "@smithy/middleware-stack": "^4.2.7", "@smithy/node-config-provider": "^4.3.7", "@smithy/node-http-handler": "^4.4.7", "@smithy/protocol-http": "^5.3.7", "@smithy/smithy-client": "^4.10.2", "@smithy/types": "^4.11.0", "@smithy/url-parser": "^4.2.7", "@smithy/util-base64": "^4.3.0", "@smithy/util-body-length-browser": "^4.2.0", "@smithy/util-body-length-node": "^4.2.1", "@smithy/util-defaults-mode-browser": "^4.3.16", "@smithy/util-defaults-mode-node": "^4.2.19", "@smithy/util-endpoints": "^3.2.7", "@smithy/util-middleware": "^4.2.7", "@smithy/util-retry": "^4.2.7", "@smithy/util-utf8": "^4.2.0", tslib: "^2.6.2" }, devDependencies: { "@tsconfig/node18": "18.2.4", "@types/node": "^18.19.69", concurrently: "7.0.0", "downlevel-dts": "0.10.1", rimraf: "3.0.2", typescript: "~5.8.3" }, engines: { node: ">=18.0.0" }, typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } }, files: ["dist-*/**"], author: { name: "AWS SDK for JavaScript Team", url: "https://aws.amazon.com/javascript/" }, license: "Apache-2.0", browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" }, "react-native": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native" }, homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso", repository: { type: "git", url: "https://github.com/aws/aws-sdk-js-v3.git", directory: "clients/client-sso" } } }); var B0e, L0e = s(() => { B0e = { isCrtAvailable: !1 } }); var M0e, $0e = s(() => { L0e(); M0e = () => B0e.isCrtAvailable ? ["md/crt-avail"] : null }); import { platform as Qgt, release as Ygt } from "os"; import { env as F0e, versions as Xgt } from "process"; var WA, U0e = s(() => { $0e(); WA = ({ serviceId: e, clientVersion: t }) => async r => { let o = [["aws-sdk-js", t], ["ua", "2.1"], [`os/${Qgt()}`, Ygt()], ["lang/js"], ["md/nodejs", `${Xgt.node}`]], n = M0e(); n && o.push(n), e && o.push([`api/${e}`, t]), F0e.AWS_EXECUTION_ENV && o.push([`exec-env/${F0e.AWS_EXECUTION_ENV}`]); let i = await r?.userAgentAppId?.(); return i ? [...o, [`app/${i}`]] : [...o] } }); var Jgt, Zgt, ext, KA, H0e = s(() => { tA(); Jgt = "AWS_SDK_UA_APP_ID", Zgt = "sdk_ua_app_id", ext = "sdk-ua-app-id", KA = { environmentVariableSelector: e => e[Jgt], configFileSelector: e => e[Zgt] ?? e[ext], default: R$ } }); var mF = s(() => { U0e(); H0e() }); import { Buffer as lF } from "buffer"; var dF, G0e, j0e = s(() => { cr(); dF = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return lF.from(e, t, r) }, G0e = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? lF.from(e, t) : lF.from(e) } }); import { Buffer as fF } from "buffer"; var q0e, V0e, hF = s(() => { cr(); q0e = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return fF.from(e, t, r) }, V0e = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? fF.from(e, t) : fF.from(e) } }); var qa, gF = s(() => { hF(); qa = e => { let t = V0e(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var z0e, W0e = s(() => { gF(); z0e = e => typeof e == "string" ? qa(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) }); var QA, K0e = s(() => { hF(); QA = e => { if (typeof e == "string") return e; if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number") throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."); return q0e(e.buffer, e.byteOffset, e.byteLength).toString("utf8") } }); var hg = s(() => { gF(); W0e(); K0e() }); import { Buffer as txt } from "buffer"; import { createHash as rxt, createHmac as oxt } from "crypto"; function Q0e(e, t) { return txt.isBuffer(e) ? e : typeof e == "string" ? G0e(e, t) : ArrayBuffer.isView(e) ? dF(e.buffer, e.byteOffset, e.byteLength) : dF(e) } var tp, xF = s(() => { j0e(); hg(); tp = class { algorithmIdentifier; secret; hash; constructor(t, r) { this.algorithmIdentifier = t, this.secret = r, this.reset() } update(t, r) { this.hash.update(z0e(Q0e(t, r))) } digest() { return Promise.resolve(this.hash.digest()) } reset() { this.hash = this.secret ? oxt(this.algorithmIdentifier, Q0e(this.secret)) : rxt(this.algorithmIdentifier) } } }); var YA, nxt, Y0e = s(() => { YA = e => encodeURIComponent(e).replace(/[!'()*]/g, nxt), nxt = e => `%${e.charCodeAt(0).toString(16).toUpperCase()}` }); var X0e = s(() => { }); var J0e = s(() => { Y0e(); X0e() }); function Z0e(e) { let t = []; for (let r of Object.keys(e).sort()) { let o = e[r]; if (r = YA(r), Array.isArray(o)) for (let n = 0, i = o.length; n < i; n++)t.push(`${r}=${YA(o[n])}`); else { let n = r; (o || typeof o == "string") && (n += `=${YA(o)}`), t.push(n) } } return t.join("&") } var eIe = s(() => { J0e() }); var tIe, rIe = s(() => { tIe = ["ECONNRESET", "EPIPE", "ETIMEDOUT"] }); var oIe, nIe = s(() => { oIe = e => { let t = {}; for (let r of Object.keys(e)) { let o = e[r]; t[r] = Array.isArray(o) ? o.join(",") : o } return t } }); var hr, rp = s(() => { hr = { setTimeout: (e, t) => setTimeout(e, t), clearTimeout: e => clearTimeout(e) } }); var sIe, iIe, aIe = s(() => { rp(); sIe = 1e3, iIe = (e, t, r = 0) => { if (!r) return -1; let o = n => { let i = hr.setTimeout(() => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${r} ms.`), { name: "TimeoutError" })) }, r - n), a = c => { c?.connecting ? c.on("connect", () => { hr.clearTimeout(i) }) : hr.clearTimeout(i) }; e.socket ? a(e.socket) : e.on("socket", a) }; return r < 2e3 ? (o(0), 0) : hr.setTimeout(o.bind(null, sIe), sIe) } }); var cIe, pIe = s(() => { rp(); cIe = (e, t, r = 0, o, n) => r ? hr.setTimeout(() => { let i = `@smithy/node-http-handler - [${o ? "ERROR" : "WARN"}] a request has exceeded the configured ${r} ms requestTimeout.`; if (o) { let a = Object.assign(new Error(i), { name: "TimeoutError", code: "ETIMEDOUT" }); e.destroy(a), t(a) } else i += " Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.", n?.warn?.(i) }, r) : -1 }); var sxt, uIe, mIe = s(() => { rp(); sxt = 3e3, uIe = (e, { keepAlive: t, keepAliveMsecs: r }, o = sxt) => { if (t !== !0) return -1; let n = () => { e.socket ? e.socket.setKeepAlive(t, r || 0) : e.on("socket", i => { i.setKeepAlive(t, r || 0) }) }; return o === 0 ? (n(), 0) : hr.setTimeout(n, o) } }); var lIe, dIe, fIe = s(() => { rp(); lIe = 3e3, dIe = (e, t, r = 0) => { let o = n => { let i = r - n, a = () => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${r} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" })) }; e.socket ? (e.socket.setTimeout(i, a), e.on("close", () => e.socket?.removeListener("timeout", a))) : e.setTimeout(i, a) }; return 0 < r && r < 6e3 ? (o(0), 0) : hr.setTimeout(o.bind(null, r === 0 ? 0 : lIe), lIe) } }); import { Readable as ixt } from "stream"; async function gIe(e, t, r = hIe, o = !1) { let n = t.headers ?? {}, i = n.Expect || n.expect, a = -1, c = !0; !o && i === "100-continue" && (c = await Promise.race([new Promise(p => { a = Number(hr.setTimeout(() => p(!0), Math.max(hIe, r))) }), new Promise(p => { e.on("continue", () => { hr.clearTimeout(a), p(!0) }), e.on("response", () => { hr.clearTimeout(a), p(!1) }), e.on("error", () => { hr.clearTimeout(a), p(!1) }) })])), c && axt(e, t.body) } function axt(e, t) { if (t instanceof ixt) { t.pipe(e); return } if (t) { if (Buffer.isBuffer(t) || typeof t == "string") { e.end(t); return } let r = t; if (typeof r == "object" && r.buffer && typeof r.byteOffset == "number" && typeof r.byteLength == "number") { e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength)); return } e.end(Buffer.from(t)); return } e.end() } var hIe, xIe = s(() => { rp(); hIe = 6e3 }); import { Agent as EF, request as cxt } from "http"; import { Agent as yF, request as pxt } from "https"; var dl, EIe = s(() => {
  ki(); eIe(); rIe(); nIe(); aIe(); pIe(); mIe(); fIe(); rp(); xIe(); dl = class e {
    config; configProvider; socketWarningTimestamp = 0; externalAgent = !1; metadata = { handlerProtocol: "http/1.1" }; static create(t) { return typeof t?.handle == "function" ? t : new e(t) } static checkSocketUsage(t, r, o = console) {
      let { sockets: n, requests: i, maxSockets: a } = t; if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r) return r; if (n && i) for (let p in n) {
        let u = n[p]?.length ?? 0, l = i[p]?.length ?? 0; if (u >= a && l >= 2 * a) return o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${u} and ${l} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`), Date.now()
      } return r
    } constructor(t) { this.configProvider = new Promise((r, o) => { typeof t == "function" ? t().then(n => { r(this.resolveDefaultConfig(n)) }).catch(o) : r(this.resolveDefaultConfig(t)) }) } resolveDefaultConfig(t) { let { requestTimeout: r, connectionTimeout: o, socketTimeout: n, socketAcquisitionWarningTimeout: i, httpAgent: a, httpsAgent: c, throwOnRequestTimeout: p } = t || {}, u = !0, l = 50; return { connectionTimeout: o, requestTimeout: r, socketTimeout: n, socketAcquisitionWarningTimeout: i, throwOnRequestTimeout: p, httpAgent: a instanceof EF || typeof a?.destroy == "function" ? (this.externalAgent = !0, a) : new EF({ keepAlive: u, maxSockets: l, ...a }), httpsAgent: c instanceof yF || typeof c?.destroy == "function" ? (this.externalAgent = !0, c) : new yF({ keepAlive: u, maxSockets: l, ...c }), logger: console } } destroy() { this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy() } async handle(t, { abortSignal: r, requestTimeout: o } = {}) { return this.config || (this.config = await this.configProvider), new Promise((n, i) => { let a = this.config, c, p = [], u = async O => { await c, p.forEach(hr.clearTimeout), n(O) }, l = async O => { await c, p.forEach(hr.clearTimeout), i(O) }; if (r?.aborted) { let O = new Error("Request aborted"); O.name = "AbortError", l(O); return } let m = t.protocol === "https:", f = t.headers ?? {}, h = (f.Expect ?? f.expect) === "100-continue", E = m ? a.httpsAgent : a.httpAgent; h && !this.externalAgent && (E = new (m ? yF : EF)({ keepAlive: !1, maxSockets: 1 / 0 })), p.push(hr.setTimeout(() => { this.socketWarningTimestamp = e.checkSocketUsage(E, this.socketWarningTimestamp, a.logger) }, a.socketAcquisitionWarningTimeout ?? (a.requestTimeout ?? 2e3) + (a.connectionTimeout ?? 1e3))); let S = Z0e(t.query || {}), y; if (t.username != null || t.password != null) { let O = t.username ?? "", ie = t.password ?? ""; y = `${O}:${ie}` } let C = t.path; S && (C += `?${S}`), t.fragment && (C += `#${t.fragment}`); let b = t.hostname ?? ""; b[0] === "[" && b.endsWith("]") ? b = t.hostname.slice(1, -1) : b = t.hostname; let L = { headers: t.headers, host: b, method: t.method, path: C, port: t.port, agent: E, auth: y }, j = (m ? pxt : cxt)(L, O => { let ie = new el({ statusCode: O.statusCode || -1, reason: O.statusMessage, headers: oIe(O.headers), body: O }); u({ response: ie }) }); if (j.on("error", O => { tIe.includes(O.code) ? l(Object.assign(O, { name: "TimeoutError" })) : l(O) }), r) { let O = () => { j.destroy(); let ie = new Error("Request aborted"); ie.name = "AbortError", l(ie) }; if (typeof r.addEventListener == "function") { let ie = r; ie.addEventListener("abort", O, { once: !0 }), j.once("close", () => ie.removeEventListener("abort", O)) } else r.onabort = O } let re = o ?? a.requestTimeout; p.push(iIe(j, l, a.connectionTimeout)), p.push(cIe(j, l, re, a.throwOnRequestTimeout, a.logger ?? console)), p.push(dIe(j, l, a.socketTimeout)); let Ce = L.agent; typeof Ce == "object" && "keepAlive" in Ce && p.push(uIe(j, { keepAlive: Ce.keepAlive, keepAliveMsecs: Ce.keepAliveMsecs })), c = gIe(j, t, re, this.externalAgent).catch(O => (p.forEach(hr.clearTimeout), i(O))) }) } updateHttpClientConfig(t, r) { this.config = void 0, this.configProvider = this.configProvider.then(o => ({ ...o, [t]: r })) } httpHandlerConfigs() { return this.config ?? {} }
  }
}); var yIe = s(() => { }); import { Writable as uxt } from "stream"; var XA, SIe = s(() => { XA = class extends uxt { bufferedBytes = []; _write(t, r, o) { this.bufferedBytes.push(t), o() } } }); async function lxt(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } var JA, mxt, _Ie = s(() => { SIe(); JA = e => mxt(e) ? lxt(e) : new Promise((t, r) => { let o = new XA; e.pipe(o), e.on("error", n => { o.end(), r(n) }), o.on("error", r), o.on("finish", function () { let n = new Uint8Array(Buffer.concat(this.bufferedBytes)); t(n) }) }), mxt = e => typeof ReadableStream == "function" && e instanceof ReadableStream }); var SF = s(() => { EIe(); yIe(); _Ie() }); import { fstatSync as dxt, lstatSync as fxt, ReadStream as hxt } from "node:fs"; var ZA, CIe = s(() => { ZA = e => { if (!e) return 0; if (typeof e == "string") return Buffer.byteLength(e); if (typeof e.byteLength == "number") return e.byteLength; if (typeof e.size == "number") return e.size; if (typeof e.start == "number" && typeof e.end == "number") return e.end + 1 - e.start; if (e instanceof hxt) { if (e.path != null) return fxt(e.path).size; if (typeof e.fd == "number") return dxt(e.fd).size } throw new Error(`Body Length computation failed for ${e}`) } }); var _F = s(() => { CIe() }); var RIe, CF, RF, AIe, TIe, wIe, bIe = s(() => { RIe = "AWS_EXECUTION_ENV", CF = "AWS_REGION", RF = "AWS_DEFAULT_REGION", AIe = "AWS_EC2_METADATA_DISABLED", TIe = ["in-region", "cross-region", "mobile", "standard", "legacy"], wIe = "/latest/meta-data/placement/region" }); var gxt, xxt, IIe, vIe = s(() => { gxt = "AWS_DEFAULTS_MODE", xxt = "defaults_mode", IIe = { environmentVariableSelector: e => e[gxt], configFileSelector: e => e[xxt], default: "legacy" } }); var eT, Ext, yxt, PIe = s(() => { ol(); Jc(); Z(); bIe(); vIe(); eT = ({ region: e = Ut(rl), defaultsMode: t = Ut(IIe) } = {}) => jr(async () => { let r = typeof t == "function" ? await t() : t; switch (r?.toLowerCase()) { case "auto": return Ext(e); case "in-region": case "cross-region": case "mobile": case "standard": case "legacy": return Promise.resolve(r?.toLocaleLowerCase()); case void 0: return Promise.resolve("legacy"); default: throw new Error(`Invalid parameter for "defaultsMode", expect ${TIe.join(", ")}, got ${r}`) } }), Ext = async e => { if (e) { let t = typeof e == "function" ? await e() : e, r = await yxt(); return r ? t === r ? "in-region" : "cross-region" : "standard" } return "standard" }, yxt = async () => { if (process.env[RIe] && (process.env[CF] || process.env[RF])) return process.env[CF] ?? process.env[RF]; if (!process.env[AIe]) try { let { getInstanceMetadataEndpoint: e, httpRequest: t } = await Promise.resolve().then(() => (fg(), dg)), r = await e(); return (await t({ ...r, path: wIe })).toString() } catch { } } }); var AF = s(() => { PIe() }); import { Buffer as TF } from "buffer"; var OIe, DIe, wF = s(() => { cr(); OIe = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return TF.from(e, t, r) }, DIe = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? TF.from(e, t) : TF.from(e) } }); var Sxt, tT, kIe = s(() => { wF(); Sxt = /^[A-Za-z0-9+/]*={0,2}$/, tT = e => { if (e.length * 3 % 4 !== 0) throw new TypeError("Incorrect padding on base64 string."); if (!Sxt.exec(e)) throw new TypeError("Invalid base64 string."); let t = DIe(e, "base64"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength) } }); var rT, NIe = s(() => { wF(); hg(); rT = e => { let t; if (typeof e == "string" ? t = qa(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return OIe(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var bF = s(() => { kIe(); NIe() }); var qIe, Bn, Ln, gl, BIe, gg, fl, hl, Bi, IF, vF, LIe, MIe, $Ie, VIe, zIe, Nn, FIe, WIe, UIe, HIe, GIe, jIe, _xt, KIe, QIe = s(() => { qIe = "required", Bn = "fn", Ln = "argv", gl = "ref", BIe = "isSet", gg = "booleanEquals", fl = "error", hl = "endpoint", Bi = "tree", IF = "PartitionResult", vF = "getAttr", LIe = { [qIe]: !1, type: "string" }, MIe = { [qIe]: !0, default: !1, type: "boolean" }, $Ie = { [gl]: "Endpoint" }, VIe = { [Bn]: gg, [Ln]: [{ [gl]: "UseFIPS" }, !0] }, zIe = { [Bn]: gg, [Ln]: [{ [gl]: "UseDualStack" }, !0] }, Nn = {}, FIe = { [Bn]: vF, [Ln]: [{ [gl]: IF }, "supportsFIPS"] }, WIe = { [gl]: IF }, UIe = { [Bn]: gg, [Ln]: [!0, { [Bn]: vF, [Ln]: [WIe, "supportsDualStack"] }] }, HIe = [VIe], GIe = [zIe], jIe = [{ [gl]: "Region" }], _xt = { version: "1.0", parameters: { Region: LIe, UseDualStack: MIe, UseFIPS: MIe, Endpoint: LIe }, rules: [{ conditions: [{ [Bn]: BIe, [Ln]: [$Ie] }], rules: [{ conditions: HIe, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: fl }, { conditions: GIe, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: fl }, { endpoint: { url: $Ie, properties: Nn, headers: Nn }, type: hl }], type: Bi }, { conditions: [{ [Bn]: BIe, [Ln]: jIe }], rules: [{ conditions: [{ [Bn]: "aws.partition", [Ln]: jIe, assign: IF }], rules: [{ conditions: [VIe, zIe], rules: [{ conditions: [{ [Bn]: gg, [Ln]: [!0, FIe] }, UIe], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Nn, headers: Nn }, type: hl }], type: Bi }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: fl }], type: Bi }, { conditions: HIe, rules: [{ conditions: [{ [Bn]: gg, [Ln]: [FIe, !0] }], rules: [{ conditions: [{ [Bn]: "stringEquals", [Ln]: [{ [Bn]: vF, [Ln]: [WIe, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: Nn, headers: Nn }, type: hl }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: Nn, headers: Nn }, type: hl }], type: Bi }, { error: "FIPS is enabled but this partition does not support FIPS", type: fl }], type: Bi }, { conditions: GIe, rules: [{ conditions: [UIe], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Nn, headers: Nn }, type: hl }], type: Bi }, { error: "DualStack is enabled but this partition does not support DualStack", type: fl }], type: Bi }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: Nn, headers: Nn }, type: hl }], type: Bi }], type: Bi }, { error: "Invalid Configuration: Missing Region", type: fl }] }, KIe = _xt }); var Cxt, YIe, XIe = s(() => { YR(); Ft(); QIe(); Cxt = new Rr({ size: 50, params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"] }), YIe = (e, t = {}) => Cxt.get(e, () => Ur(KIe, { endpointParams: e, logger: t.logger })); Rt.aws = tg }); var JIe, ZIe = s(() => { Ye(); yn(); Ie(); Be(); rg(); bF(); hg(); uF(); XIe(); JIe = e => ({ apiVersion: "2019-06-10", base64Decoder: e?.base64Decoder ?? tT, base64Encoder: e?.base64Encoder ?? rT, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? YIe, extensions: e?.extensions ?? [], httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? P0e, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }, { schemeId: "smithy.api#noAuth", identityProvider: t => t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})), signer: new po }], logger: e?.logger ?? new Fa, protocol: e?.protocol ?? En, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.sso", version: "2019-06-10", serviceTarget: "SWBPortalService" }, serviceId: e?.serviceId ?? "SSO", urlParser: e?.urlParser ?? Qs, utf8Decoder: e?.utf8Decoder ?? qa, utf8Encoder: e?.utf8Encoder ?? QA }) }); var eve, tve = s(() => { k0e(); Ye(); mF(); ol(); xF(); ug(); Jc(); SF(); Be(); _F(); AF(); pg(); ZIe(); eve = e => { OA(process.version); let t = eT(e), r = () => t().then(PA), o = JIe(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, authSchemePreference: e?.authSchemePreference ?? Ut(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? ZA, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? WA({ serviceId: o.serviceId, clientVersion: N0e.version }), maxAttempts: e?.maxAttempts ?? Ut(TA, e), region: e?.region ?? Ut(rl, { ...nA, ...n }), requestHandler: dl.create(e?.requestHandler ?? r), retryMode: e?.retryMode ?? Ut({ ...bA, default: async () => (await r()).retryMode || il }, e), sha256: e?.sha256 ?? tp.bind(null, "sha256"), streamCollector: e?.streamCollector ?? JA, useDualstackEndpoint: e?.useDualstackEndpoint ?? Ut(rA, n), useFipsEndpoint: e?.useFipsEndpoint ?? Ut(oA, n), userAgentAppId: e?.userAgentAppId ?? Ut(KA, n) } } }); var rve, ove, nve = s(() => { rve = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, ove = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var sve, ive = s(() => { ps(); ki(); Be(); nve(); sve = (e, t) => { let r = Object.assign(Vr(e), DA(e), GR(e), rve(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), kA(r), jR(r), ove(r)) } }); var Ys, xg = s(() => { x$(); E$(); _$(); tA(); ol(); Ie(); Oe(); O$(); St(); ug(); Be(); uF(); ll(); tve(); ive(); Ys = class extends pl { config; constructor(...[t]) { let r = eve(t || {}); super(r), this.initConfig = r; let o = D0e(r), n = QR(o), i = wA(n), a = iA(i), c = a, p = yA(c), u = O0e(p), l = sve(u, t?.extensions || []); this.config = l, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(eA(this.config)), this.middlewareStack.use(NA(this.config)), this.middlewareStack.use(aA(this.config)), this.middlewareStack.use(qR(this.config)), this.middlewareStack.use(VR(this.config)), this.middlewareStack.use(zR(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: v0e, identityProviderConfigProvider: async m => new Cr({ "aws.auth#sigv4": m.credentials }) })), this.middlewareStack.use($r(this.config)) } destroy() { super.destroy() } } }); var Li, PF = s(() => { Be(); Li = class e extends ul { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var oT, nT, sT, iT, OF = s(() => { PF(); oT = class e extends Li { name = "InvalidRequestException"; $fault = "client"; constructor(t) { super({ name: "InvalidRequestException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, nT = class e extends Li { name = "ResourceNotFoundException"; $fault = "client"; constructor(t) { super({ name: "ResourceNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, sT = class e extends Li { name = "TooManyRequestsException"; $fault = "client"; constructor(t) { super({ name: "TooManyRequestsException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, iT = class e extends Li { name = "UnauthorizedException"; $fault = "client"; constructor(t) { super({ name: "UnauthorizedException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } } }); var Axt, Txt, wxt, bxt, Ixt, vxt, Pxt, Oxt, Dxt, kxt, Nxt, Bxt, Lxt, Mxt, $xt, Fxt, Uxt, Hxt, Gxt, jxt, qxt, Vxt, zxt, aT, Wxt, Kxt, Qxt, cT, ave, pT, uT, Yxt, Xxt, mT, lT, dT, op, fT, cve, pve, hT, uve, Jxt, Zxt, mve, eEt, lve, tEt, rEt, gT, Bt, xT, oEt, nEt, sEt, iEt, aEt, cEt, pEt, uEt, mEt, lEt, dEt, fEt, hEt, gEt, xEt, EEt, yEt, SEt, _Et, CEt, dve, fve, hve, gve, xl = s(() => { Oe(); OF(); PF(); Axt = "AccountInfo", Txt = "AccountListType", wxt = "AccessTokenType", bxt = "GetRoleCredentials", Ixt = "GetRoleCredentialsRequest", vxt = "GetRoleCredentialsResponse", Pxt = "InvalidRequestException", Oxt = "Logout", Dxt = "ListAccounts", kxt = "ListAccountsRequest", Nxt = "ListAccountRolesRequest", Bxt = "ListAccountRolesResponse", Lxt = "ListAccountsResponse", Mxt = "ListAccountRoles", $xt = "LogoutRequest", Fxt = "RoleCredentials", Uxt = "RoleInfo", Hxt = "RoleListType", Gxt = "ResourceNotFoundException", jxt = "SecretAccessKeyType", qxt = "SessionTokenType", Vxt = "TooManyRequestsException", zxt = "UnauthorizedException", aT = "accountId", Wxt = "accessKeyId", Kxt = "accountList", Qxt = "accountName", cT = "accessToken", ave = "account_id", pT = "client", uT = "error", Yxt = "emailAddress", Xxt = "expiration", mT = "http", lT = "httpError", dT = "httpHeader", op = "httpQuery", fT = "message", cve = "maxResults", pve = "max_result", hT = "nextToken", uve = "next_token", Jxt = "roleCredentials", Zxt = "roleList", mve = "roleName", eEt = "role_name", lve = "smithy.ts.sdk.synthetic.com.amazonaws.sso", tEt = "secretAccessKey", rEt = "sessionToken", gT = "x-amz-sso_bearer_token", Bt = "com.amazonaws.sso", xT = [0, Bt, wxt, 8, 0], oEt = [0, Bt, jxt, 8, 0], nEt = [0, Bt, qxt, 8, 0], sEt = [3, Bt, Axt, 0, [aT, Qxt, Yxt], [0, 0, 0]], iEt = [3, Bt, Ixt, 0, [mve, aT, cT], [[0, { [op]: eEt }], [0, { [op]: ave }], [() => xT, { [dT]: gT }]]], aEt = [3, Bt, vxt, 0, [Jxt], [[() => hEt, 0]]], cEt = [-3, Bt, Pxt, { [uT]: pT, [lT]: 400 }, [fT], [0]]; k.for(Bt).registerError(cEt, oT); pEt = [3, Bt, Nxt, 0, [hT, cve, cT, aT], [[0, { [op]: uve }], [1, { [op]: pve }], [() => xT, { [dT]: gT }], [0, { [op]: ave }]]], uEt = [3, Bt, Bxt, 0, [hT, Zxt], [0, () => CEt]], mEt = [3, Bt, kxt, 0, [hT, cve, cT], [[0, { [op]: uve }], [1, { [op]: pve }], [() => xT, { [dT]: gT }]]], lEt = [3, Bt, Lxt, 0, [hT, Kxt], [0, () => _Et]], dEt = [3, Bt, $xt, 0, [cT], [[() => xT, { [dT]: gT }]]], fEt = [-3, Bt, Gxt, { [uT]: pT, [lT]: 404 }, [fT], [0]]; k.for(Bt).registerError(fEt, nT); hEt = [3, Bt, Fxt, 0, [Wxt, tEt, rEt, Xxt], [0, [() => oEt, 0], [() => nEt, 0], 1]], gEt = [3, Bt, Uxt, 0, [mve, aT], [0, 0]], xEt = [-3, Bt, Vxt, { [uT]: pT, [lT]: 429 }, [fT], [0]]; k.for(Bt).registerError(xEt, sT); EEt = [-3, Bt, zxt, { [uT]: pT, [lT]: 401 }, [fT], [0]]; k.for(Bt).registerError(EEt, iT); yEt = "unit", SEt = [-3, lve, "SSOServiceException", 0, [], []]; k.for(lve).registerError(SEt, Li); _Et = [1, Bt, Txt, 0, () => sEt], CEt = [1, Bt, Hxt, 0, () => gEt], dve = [9, Bt, bxt, { [mT]: ["GET", "/federation/credentials", 200] }, () => iEt, () => aEt], fve = [9, Bt, Mxt, { [mT]: ["GET", "/assignment/roles", 200] }, () => pEt, () => uEt], hve = [9, Bt, Dxt, { [mT]: ["GET", "/assignment/accounts", 200] }, () => mEt, () => lEt], gve = [9, Bt, Oxt, { [mT]: ["POST", "/logout", 200] }, () => dEt, () => yEt] }); var El, DF = s(() => { St(); Be(); ll(); xl(); El = class extends Se.classBuilder().ep(ja).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").sc(dve).build() { } }); var yl, ET = s(() => { St(); Be(); ll(); xl(); yl = class extends Se.classBuilder().ep(ja).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").sc(fve).build() { } }); var Sl, yT = s(() => { St(); Be(); ll(); xl(); Sl = class extends Se.classBuilder().ep(ja).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").sc(hve).build() { } }); var ST, kF = s(() => { St(); Be(); ll(); xl(); ST = class extends Se.classBuilder().ep(ja).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").sc(gve).build() { } }); var REt, NF, xve = s(() => { Be(); DF(); ET(); yT(); kF(); xg(); REt = { GetRoleCredentialsCommand: El, ListAccountRolesCommand: yl, ListAccountsCommand: Sl, LogoutCommand: ST }, NF = class extends Ys { }; vA(REt, NF) }); var Eve = s(() => { DF(); ET(); yT(); kF() }); var yve = s(() => { }); var Lro, Sve = s(() => { Ie(); ET(); xg(); Lro = qe(Ys, yl, "nextToken", "nextToken", "maxResults") }); var Hro, _ve = s(() => { Ie(); yT(); xg(); Hro = qe(Ys, Sl, "nextToken", "nextToken", "maxResults") }); var Cve = s(() => { yve(); Sve(); _ve() }); var Rve = s(() => { }); var Ave = s(() => { xg(); xve(); Eve(); xl(); Cve(); OF(); Rve() }); var Tve = {}; Qe(Tve, { GetRoleCredentialsCommand: () => El, SSOClient: () => Ys }); var wve = s(() => { Ave() }); var Eg, BF, bve = s(() => { He(); I0e(); Z(); rn(); Eg = !1, BF = async ({ ssoStartUrl: e, ssoSession: t, ssoAccountId: r, ssoRegion: o, ssoRoleName: n, ssoClient: i, clientConfig: a, parentClientConfig: c, callerClientConfig: p, profile: u, filepath: l, configFilepath: m, ignoreCache: f, logger: h }) => { let E, S = "To refresh this SSO session run aws sso login with the corresponding profile."; if (t) try { let dt = await A0e({ profile: u, filepath: l, configFilepath: m, ignoreCache: f })(); E = { accessToken: dt.token, expiresAt: new Date(dt.expiration).toISOString() } } catch (dt) { throw new I(dt.message, { tryNextLink: Eg, logger: h }) } else try { E = await ng(e) } catch { throw new I(`The SSO session associated with this profile is invalid. ${S}`, { tryNextLink: Eg, logger: h }) } if (new Date(E.expiresAt).getTime() - Date.now() <= 0) throw new I(`The SSO session associated with this profile has expired. ${S}`, { tryNextLink: Eg, logger: h }); let { accessToken: y } = E, { SSOClient: C, GetRoleCredentialsCommand: b } = await Promise.resolve().then(() => (wve(), Tve)), L = i || new C(Object.assign({}, a ?? {}, { logger: a?.logger ?? p?.logger ?? c?.logger, region: a?.region ?? o, userAgentAppId: a?.userAgentAppId ?? p?.userAgentAppId ?? c?.userAgentAppId })), N; try { N = await L.send(new b({ accountId: r, roleName: n, accessToken: y })) } catch (dt) { throw new I(dt, { tryNextLink: Eg, logger: h }) } let { roleCredentials: { accessKeyId: j, secretAccessKey: re, sessionToken: Ce, expiration: O, credentialScope: ie, accountId: st } = {} } = N; if (!j || !re || !Ce || !O) throw new I("SSO returns an invalid temporary credential.", { tryNextLink: Eg, logger: h }); let Ct = { accessKeyId: j, secretAccessKey: re, sessionToken: Ce, expiration: new Date(O), ...ie && { credentialScope: ie }, ...st && { accountId: st } }; return t ? ee(Ct, "CREDENTIALS_SSO", "s") : ee(Ct, "CREDENTIALS_SSO_LEGACY", "u"), Ct } }); var LF, MF = s(() => {
  Z(); LF = (e, t) => {
    let { sso_start_url: r, sso_account_id: o, sso_region: n, sso_role_name: i } = e; if (!r || !o || !n || !i) throw new I(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: !1, logger: t }); return e
  }
}); var AEt, Ive = s(() => { Z(); rn(); cF(); bve(); MF(); AEt = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO"); let { ssoStartUrl: r, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoSession: a } = e, { ssoClient: c } = e, p = kn({ profile: e.profile ?? t?.profile }); if (!r && !o && !n && !i && !a) { let l = (await Ma(e))[p]; if (!l) throw new I(`Profile ${p} was not found.`, { logger: e.logger }); if (!aF(l)) throw new I(`Profile ${p} is not configured with SSO credentials.`, { logger: e.logger }); if (l?.sso_session) { let C = (await hA(e))[l.sso_session], b = ` configurations in profile ${p} and sso-session ${l.sso_session}`; if (n && n !== C.sso_region) throw new I("Conflicting SSO region" + b, { tryNextLink: !1, logger: e.logger }); if (r && r !== C.sso_start_url) throw new I("Conflicting SSO start_url" + b, { tryNextLink: !1, logger: e.logger }); l.sso_region = C.sso_region, l.sso_start_url = C.sso_start_url } let { sso_start_url: m, sso_account_id: f, sso_region: h, sso_role_name: E, sso_session: S } = LF(l, e.logger); return BF({ ssoStartUrl: m, ssoSession: S, ssoAccountId: f, ssoRegion: h, ssoRoleName: E, ssoClient: c, clientConfig: e.clientConfig, parentClientConfig: e.parentClientConfig, callerClientConfig: e.callerClientConfig, profile: p, filepath: e.filepath, configFilepath: e.configFilepath, ignoreCache: e.ignoreCache, logger: e.logger }) } else { if (!r || !o || !n || !i) throw new I('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', { tryNextLink: !1, logger: e.logger }); return BF({ ssoStartUrl: r, ssoSession: a, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoClient: c, clientConfig: e.clientConfig, parentClientConfig: e.parentClientConfig, callerClientConfig: e.callerClientConfig, profile: p, filepath: e.filepath, configFilepath: e.configFilepath, ignoreCache: e.ignoreCache, logger: e.logger }) } } }); var vve = s(() => { }); var $F = {}; Qe($F, { fromSSO: () => AEt, isSsoProfile: () => aF, validateSsoProfile: () => LF }); var FF = s(() => { Ive(); cF(); vve(); MF() }); var Pve, UF, Ove = s(() => { He(); Z(); Pve = (e, t, r) => { let o = { EcsContainer: async n => { let { fromHttp: i } = await Promise.resolve().then(() => (vc(), Ic)), { fromContainerMetadata: a } = await Promise.resolve().then(() => (fg(), dg)); return r?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"), async () => sr(i(n ?? {}), a(n))().then(UF) }, Ec2InstanceMetadata: async n => { r?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata"); let { fromInstanceMetadata: i } = await Promise.resolve().then(() => (fg(), dg)); return async () => i(n)().then(UF) }, Environment: async n => { r?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment"); let { fromEnv: i } = await Promise.resolve().then(() => (J$(), Kbe)); return async () => i(n)().then(UF) } }; if (e in o) return o[e]; throw new I(`Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger: r }) }, UF = e => ee(e, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p") }); var kve, TEt, wEt, Nve, Dve, Bve = s(() => { He(); Z(); rn(); Ove(); kve = (e, { profile: t = "default", logger: r } = {}) => !!e && typeof e == "object" && typeof e.role_arn == "string" && ["undefined", "string"].indexOf(typeof e.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof e.external_id) > -1 && ["undefined", "string"].indexOf(typeof e.mfa_serial) > -1 && (TEt(e, { profile: t, logger: r }) || wEt(e, { profile: t, logger: r })), TEt = (e, { profile: t, logger: r }) => { let o = typeof e.source_profile == "string" && typeof e.credential_source > "u"; return o && r?.debug?.(`    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`), o }, wEt = (e, { profile: t, logger: r }) => { let o = typeof e.credential_source == "string" && typeof e.source_profile > "u"; return o && r?.debug?.(`    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`), o }, Nve = async (e, t, r, o, n = {}, i) => { r.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)"); let a = t[e], { source_profile: c, region: p } = a; if (!r.roleAssumer) { let { getDefaultRoleAssumer: l } = await Promise.resolve().then(() => (Qc(), Kc)); r.roleAssumer = l({ ...r.clientConfig, credentialProviderLogger: r.logger, parentClientConfig: { ...o, ...r?.parentClientConfig, region: p ?? r?.parentClientConfig?.region ?? o?.region } }, r.clientPlugins) } if (c && c in n) throw new I(`Detected a cycle attempting to resolve credentials for profile ${kn(r)}. Profiles visited: ` + Object.keys(n).join(", "), { logger: r.logger }); r.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${c ? `source_profile=[${c}]` : `profile=[${e}]`}`); let u = c ? i(c, t, r, o, { ...n, [c]: !0 }, Dve(t[c] ?? {})) : (await Pve(a.credential_source, e, r.logger)(r))(); if (Dve(a)) return u.then(l => ee(l, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")); { let l = { RoleArn: a.role_arn, RoleSessionName: a.role_session_name || `aws-sdk-js-${Date.now()}`, ExternalId: a.external_id, DurationSeconds: parseInt(a.duration_seconds || "3600", 10) }, { mfa_serial: m } = a; if (m) { if (!r.mfaCodeProvider) throw new I(`Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`, { logger: r.logger, tryNextLink: !1 }); l.SerialNumber = m, l.TokenCode = await r.mfaCodeProvider(m) } let f = await u; return r.roleAssumer(f, l).then(h => ee(h, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")) } }, Dve = e => !e.role_arn && !!e.credential_source }); var Lve, Mve, $ve = s(() => { He(); NC(); Lve = e => !!(e && e.login_session), Mve = async (e, t, r) => { let o = await qm({ ...t, profile: e })({ callerClientConfig: r }); return ee(o, "CREDENTIALS_PROFILE_LOGIN", "AC") } }); var Fve, Uve = s(() => { He(); Fve = (e, t, r) => { if (t.Version !== 1) throw Error(`Profile ${e} credential_process did not return Version 1.`); if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0) throw Error(`Profile ${e} credential_process returned invalid credentials.`); if (t.Expiration) { let i = new Date; if (new Date(t.Expiration) < i) throw Error(`Profile ${e} credential_process returned expired credentials.`) } let o = t.AccountId; !o && r?.[e]?.aws_account_id && (o = r[e].aws_account_id); let n = { accessKeyId: t.AccessKeyId, secretAccessKey: t.SecretAccessKey, ...t.SessionToken && { sessionToken: t.SessionToken }, ...t.Expiration && { expiration: new Date(t.Expiration) }, ...t.CredentialScope && { credentialScope: t.CredentialScope }, ...o && { accountId: o } }; return ee(n, "CREDENTIALS_PROCESS", "w"), n } }); import { exec as bEt } from "child_process"; import { promisify as IEt } from "util"; var Hve, Gve = s(() => { Z(); rn(); Uve(); Hve = async (e, t, r) => { let o = t[e]; if (t[e]) { let n = o.credential_process; if (n !== void 0) { let i = IEt(cg?.getTokenRecord?.().exec ?? bEt); try { let { stdout: a } = await i(n), c; try { c = JSON.parse(a.trim()) } catch { throw Error(`Profile ${e} credential_process returned invalid JSON.`) } return Fve(e, c, t) } catch (a) { throw new I(a.message, { logger: r }) } } else throw new I(`Profile ${e} did not contain credential_process.`, { logger: r }) } else throw new I(`Profile ${e} could not be found in shared credentials file.`, { logger: r }) } }); var vEt, jve = s(() => { rn(); Gve(); vEt = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess"); let r = await Ma(e); return Hve(kn({ profile: e.profile ?? t?.profile }), r, e.logger) } }); var HF = {}; Qe(HF, { fromProcess: () => vEt }); var GF = s(() => { jve() }); var qve, Vve, zve = s(() => { He(); qve = e => !!e && typeof e == "object" && typeof e.credential_process == "string", Vve = async (e, t) => Promise.resolve().then(() => (GF(), HF)).then(({ fromProcess: r }) => r({ ...e, profile: t })().then(o => ee(o, "CREDENTIALS_PROFILE_PROCESS", "v"))) }); var Wve, Kve, Qve = s(() => { He(); Wve = async (e, t, r = {}, o) => { let { fromSSO: n } = await Promise.resolve().then(() => (FF(), $F)); return n({ profile: e, logger: r.logger, parentClientConfig: r.parentClientConfig, clientConfig: r.clientConfig })({ callerClientConfig: o }).then(i => t.sso_session ? ee(i, "CREDENTIALS_PROFILE_SSO", "r") : ee(i, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")) }, Kve = e => e && (typeof e.sso_start_url == "string" || typeof e.sso_account_id == "string" || typeof e.sso_session == "string" || typeof e.sso_region == "string" || typeof e.sso_role_name == "string") }); var jF, qF, Yve = s(() => { He(); jF = e => !!e && typeof e == "object" && typeof e.aws_access_key_id == "string" && typeof e.aws_secret_access_key == "string" && ["undefined", "string"].indexOf(typeof e.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof e.aws_account_id) > -1, qF = async (e, t) => { t?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials"); let r = { accessKeyId: e.aws_access_key_id, secretAccessKey: e.aws_secret_access_key, sessionToken: e.aws_session_token, ...e.aws_credential_scope && { credentialScope: e.aws_credential_scope }, ...e.aws_account_id && { accountId: e.aws_account_id } }; return ee(r, "CREDENTIALS_PROFILE", "n") } }); var VF, zF = s(() => { VF = e => async t => { e.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken"); let { roleArn: r, roleSessionName: o, webIdentityToken: n, providerId: i, policyArns: a, policy: c, durationSeconds: p } = e, { roleAssumerWithWebIdentity: u } = e; if (!u) { let { getDefaultRoleAssumerWithWebIdentity: l } = await Promise.resolve().then(() => (Qc(), Kc)); u = l({ ...e.clientConfig, credentialProviderLogger: e.logger, parentClientConfig: { ...t?.callerClientConfig, ...e.parentClientConfig } }, e.clientPlugins) } return u({ RoleArn: r, RoleSessionName: o ?? `aws-sdk-js-session-${Date.now()}`, WebIdentityToken: n, ProviderId: i, PolicyArns: a, Policy: c, DurationSeconds: p }) } }); import { readFileSync as PEt } from "fs"; var Xve, OEt, DEt, kEt, Jve = s(() => { He(); Z(); rn(); zF(); Xve = "AWS_WEB_IDENTITY_TOKEN_FILE", OEt = "AWS_ROLE_ARN", DEt = "AWS_ROLE_SESSION_NAME", kEt = (e = {}) => async t => { e.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile"); let r = e?.webIdentityTokenFile ?? process.env[Xve], o = e?.roleArn ?? process.env[OEt], n = e?.roleSessionName ?? process.env[DEt]; if (!r || !o) throw new I("Web identity configuration not specified", { logger: e.logger }); let i = await VF({ ...e, webIdentityToken: cg?.getTokenRecord?.()[r] ?? PEt(r, { encoding: "ascii" }), roleArn: o, roleSessionName: n })(t); return r === process.env[Xve] && ee(i, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h"), i } }); var WF = {}; Qe(WF, { fromTokenFile: () => kEt, fromWebToken: () => VF }); var KF = s(() => { Jve(); zF() }); var Zve, ePe, tPe = s(() => { He(); Zve = e => !!e && typeof e == "object" && typeof e.web_identity_token_file == "string" && typeof e.role_arn == "string" && ["undefined", "string"].indexOf(typeof e.role_session_name) > -1, ePe = async (e, t, r) => Promise.resolve().then(() => (KF(), WF)).then(({ fromTokenFile: o }) => o({ webIdentityTokenFile: e.web_identity_token_file, roleArn: e.role_arn, roleSessionName: e.role_session_name, roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity, logger: t.logger, parentClientConfig: t.parentClientConfig })({ callerClientConfig: r }).then(n => ee(n, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))) }); var QF, rPe = s(() => { Z(); Bve(); $ve(); zve(); Qve(); Yve(); tPe(); QF = async (e, t, r, o, n = {}, i = !1) => { let a = t[e]; if (Object.keys(n).length > 0 && jF(a)) return qF(a, r); if (i || kve(a, { profile: e, logger: r.logger })) return Nve(e, t, r, o, n, QF); if (jF(a)) return qF(a, r); if (Zve(a)) return ePe(a, r, o); if (qve(a)) return Vve(r, e); if (Kve(a)) return await Wve(e, a, r, o); if (Lve(a)) return Mve(e, r, o); throw new I(`Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`, { logger: r.logger }) } }); var NEt, oPe = s(() => { rn(); rPe(); NEt = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-ini - fromIni"); let r = await Ma(e); return QF(kn({ profile: e.profile ?? t?.profile }), r, e, t) } }); var nPe = {}; Qe(nPe, { fromIni: () => NEt }); var sPe = s(() => { oPe() }); var iPe, aPe, BEt, cPe = s(() => {
  J$(); Z(); rn(); m0e(); d0e(); iPe = !1, aPe = (e = {}) => l0e([async () => {
    if (e.profile ?? process.env[N$]) throw process.env[BA] && process.env[LA] && (iPe || ((e.logger?.warn && e.logger?.constructor?.name !== "NoOpLogger" ? e.logger.warn.bind(e.logger) : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`), iPe = !0)), new I("AWS_PROFILE is set, skipping fromEnv provider.", { logger: e.logger, tryNextLink: !0 }); return e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv"), X$(e)()
  }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO"); let { ssoStartUrl: r, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoSession: a } = e; if (!r && !o && !n && !i && !a) throw new I("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: e.logger }); let { fromSSO: c } = await Promise.resolve().then(() => (FF(), $F)); return c(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni"); let { fromIni: r } = await Promise.resolve().then(() => (sPe(), nPe)); return r(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess"); let { fromProcess: r } = await Promise.resolve().then(() => (GF(), HF)); return r(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile"); let { fromTokenFile: r } = await Promise.resolve().then(() => (KF(), WF)); return r(e)(t) }, async () => (e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"), (await u0e(e))()), async () => { throw new I("Could not load credentials from any providers", { tryNextLink: !1, logger: e.logger }) }], BEt), BEt = e => e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5
}); var pPe = s(() => { cPe() }); var yPe, $n, Fn, Rl, uPe, yg, _l, Cl, Mi, YF, XF, mPe, lPe, dPe, SPe, _Pe, Mn, fPe, CPe, hPe, gPe, xPe, EPe, LEt, RPe, APe = s(() => { yPe = "required", $n = "fn", Fn = "argv", Rl = "ref", uPe = "isSet", yg = "booleanEquals", _l = "error", Cl = "endpoint", Mi = "tree", YF = "PartitionResult", XF = "getAttr", mPe = { [yPe]: !1, type: "string" }, lPe = { [yPe]: !0, default: !1, type: "boolean" }, dPe = { [Rl]: "Endpoint" }, SPe = { [$n]: yg, [Fn]: [{ [Rl]: "UseFIPS" }, !0] }, _Pe = { [$n]: yg, [Fn]: [{ [Rl]: "UseDualStack" }, !0] }, Mn = {}, fPe = { [$n]: XF, [Fn]: [{ [Rl]: YF }, "supportsFIPS"] }, CPe = { [Rl]: YF }, hPe = { [$n]: yg, [Fn]: [!0, { [$n]: XF, [Fn]: [CPe, "supportsDualStack"] }] }, gPe = [SPe], xPe = [_Pe], EPe = [{ [Rl]: "Region" }], LEt = { version: "1.0", parameters: { Region: mPe, UseDualStack: lPe, UseFIPS: lPe, Endpoint: mPe }, rules: [{ conditions: [{ [$n]: uPe, [Fn]: [dPe] }], rules: [{ conditions: gPe, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: _l }, { conditions: xPe, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: _l }, { endpoint: { url: dPe, properties: Mn, headers: Mn }, type: Cl }], type: Mi }, { conditions: [{ [$n]: uPe, [Fn]: EPe }], rules: [{ conditions: [{ [$n]: "aws.partition", [Fn]: EPe, assign: YF }], rules: [{ conditions: [SPe, _Pe], rules: [{ conditions: [{ [$n]: yg, [Fn]: [!0, fPe] }, hPe], rules: [{ endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Mn, headers: Mn }, type: Cl }], type: Mi }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: _l }], type: Mi }, { conditions: gPe, rules: [{ conditions: [{ [$n]: yg, [Fn]: [fPe, !0] }], rules: [{ conditions: [{ [$n]: "stringEquals", [Fn]: [{ [$n]: XF, [Fn]: [CPe, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sqs.{Region}.amazonaws.com", properties: Mn, headers: Mn }, type: Cl }, { endpoint: { url: "https://sqs-fips.{Region}.{PartitionResult#dnsSuffix}", properties: Mn, headers: Mn }, type: Cl }], type: Mi }, { error: "FIPS is enabled but this partition does not support FIPS", type: _l }], type: Mi }, { conditions: xPe, rules: [{ conditions: [hPe], rules: [{ endpoint: { url: "https://sqs.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Mn, headers: Mn }, type: Cl }], type: Mi }, { error: "DualStack is enabled but this partition does not support DualStack", type: _l }], type: Mi }, { endpoint: { url: "https://sqs.{Region}.{PartitionResult#dnsSuffix}", properties: Mn, headers: Mn }, type: Cl }], type: Mi }], type: Mi }, { error: "Invalid Configuration: Missing Region", type: _l }] }, RPe = LEt }); var MEt, TPe, wPe = s(() => { YR(); Ft(); APe(); MEt = new Rr({ size: 50, params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"] }), TPe = (e, t = {}) => MEt.get(e, () => Ur(RPe, { endpointParams: e, logger: t.logger })); Rt.aws = tg }); var bPe, IPe = s(() => { Ye(); yn(); Be(); rg(); bF(); hg(); Y$(); wPe(); bPe = e => ({ apiVersion: "2012-11-05", base64Decoder: e?.base64Decoder ?? tT, base64Encoder: e?.base64Encoder ?? rT, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? TPe, extensions: e?.extensions ?? [], httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? $be, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }], logger: e?.logger ?? new Fa, protocol: e?.protocol ?? du, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.sqs", version: "2012-11-05", serviceTarget: "AmazonSQS", awsQueryCompatible: !0 }, serviceId: e?.serviceId ?? "SQS", urlParser: e?.urlParser ?? Qs, utf8Decoder: e?.utf8Decoder ?? qa, utf8Encoder: e?.utf8Encoder ?? QA }) }); var vPe, PPe = s(() => { Hbe(); Ye(); pPe(); mF(); ol(); xF(); ug(); Jc(); SF(); Be(); _F(); AF(); pg(); IPe(); vPe = e => { OA(process.version); let t = eT(e), r = () => t().then(PA), o = bPe(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, authSchemePreference: e?.authSchemePreference ?? Ut(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? ZA, credentialDefaultProvider: e?.credentialDefaultProvider ?? aPe, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? WA({ serviceId: o.serviceId, clientVersion: Gbe.version }), maxAttempts: e?.maxAttempts ?? Ut(TA, e), md5: e?.md5 ?? tp.bind(null, "md5"), region: e?.region ?? Ut(rl, { ...nA, ...n }), requestHandler: dl.create(e?.requestHandler ?? r), retryMode: e?.retryMode ?? Ut({ ...bA, default: async () => (await r()).retryMode || il }, e), sha256: e?.sha256 ?? tp.bind(null, "sha256"), streamCollector: e?.streamCollector ?? JA, useDualstackEndpoint: e?.useDualstackEndpoint ?? Ut(rA, n), useFipsEndpoint: e?.useFipsEndpoint ?? Ut(oA, n), userAgentAppId: e?.userAgentAppId ?? Ut(KA, n) } } }); var OPe, DPe, kPe = s(() => { OPe = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, DPe = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var NPe, BPe = s(() => { ps(); ki(); Be(); kPe(); NPe = (e, t) => { let r = Object.assign(Vr(e), DA(e), GR(e), OPe(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), kA(r), jR(r), DPe(r)) } }); var Xs, Sg = s(() => { x$(); E$(); _$(); eg(); tA(); ol(); Ie(); Oe(); O$(); St(); ug(); Be(); Y$(); zt(); PPe(); BPe(); Xs = class extends pl { config; constructor(...[t]) { let r = vPe(t || {}); super(r), this.initConfig = r; let o = Ube(r), n = QR(o), i = wA(n), a = iA(i), c = a, p = yA(c), u = kAe(p), l = Fbe(u), m = NPe(l, t?.extensions || []); this.config = m, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(eA(this.config)), this.middlewareStack.use(NA(this.config)), this.middlewareStack.use(aA(this.config)), this.middlewareStack.use(qR(this.config)), this.middlewareStack.use(VR(this.config)), this.middlewareStack.use(zR(this.config)), this.middlewareStack.use(NAe(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: Mbe, identityProviderConfigProvider: async f => new Cr({ "aws.auth#sigv4": f.credentials }) })), this.middlewareStack.use($r(this.config)) } destroy() { super.destroy() } } }); var nt, JF = s(() => { Be(); nt = class e extends ul { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var _T, CT, RT, AT, TT, wT, bT, IT, vT, PT, OT, DT, kT, NT, BT, LT, MT, $T, FT, UT, HT, GT, jT, qT, VT, zT, WT, KT, ZF = s(() => { JF(); _T = class e extends nt { name = "InvalidAddress"; $fault = "client"; constructor(t) { super({ name: "InvalidAddress", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, CT = class e extends nt { name = "InvalidSecurity"; $fault = "client"; constructor(t) { super({ name: "InvalidSecurity", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, RT = class e extends nt { name = "OverLimit"; $fault = "client"; constructor(t) { super({ name: "OverLimit", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, AT = class e extends nt { name = "QueueDoesNotExist"; $fault = "client"; constructor(t) { super({ name: "QueueDoesNotExist", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, TT = class e extends nt { name = "RequestThrottled"; $fault = "client"; constructor(t) { super({ name: "RequestThrottled", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, wT = class e extends nt { name = "UnsupportedOperation"; $fault = "client"; constructor(t) { super({ name: "UnsupportedOperation", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, bT = class e extends nt { name = "ResourceNotFoundException"; $fault = "client"; constructor(t) { super({ name: "ResourceNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, IT = class e extends nt { name = "MessageNotInflight"; $fault = "client"; constructor(t) { super({ name: "MessageNotInflight", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, vT = class e extends nt { name = "ReceiptHandleIsInvalid"; $fault = "client"; constructor(t) { super({ name: "ReceiptHandleIsInvalid", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, PT = class e extends nt { name = "BatchEntryIdsNotDistinct"; $fault = "client"; constructor(t) { super({ name: "BatchEntryIdsNotDistinct", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, OT = class e extends nt { name = "EmptyBatchRequest"; $fault = "client"; constructor(t) { super({ name: "EmptyBatchRequest", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, DT = class e extends nt { name = "InvalidBatchEntryId"; $fault = "client"; constructor(t) { super({ name: "InvalidBatchEntryId", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, kT = class e extends nt { name = "TooManyEntriesInBatchRequest"; $fault = "client"; constructor(t) { super({ name: "TooManyEntriesInBatchRequest", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, NT = class e extends nt { name = "InvalidAttributeName"; $fault = "client"; constructor(t) { super({ name: "InvalidAttributeName", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, BT = class e extends nt { name = "InvalidAttributeValue"; $fault = "client"; constructor(t) { super({ name: "InvalidAttributeValue", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, LT = class e extends nt { name = "QueueDeletedRecently"; $fault = "client"; constructor(t) { super({ name: "QueueDeletedRecently", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, MT = class e extends nt { name = "QueueNameExists"; $fault = "client"; constructor(t) { super({ name: "QueueNameExists", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, $T = class e extends nt { name = "InvalidIdFormat"; $fault = "client"; constructor(t) { super({ name: "InvalidIdFormat", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, FT = class e extends nt { name = "PurgeQueueInProgress"; $fault = "client"; constructor(t) { super({ name: "PurgeQueueInProgress", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, UT = class e extends nt { name = "KmsAccessDenied"; $fault = "client"; constructor(t) { super({ name: "KmsAccessDenied", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, HT = class e extends nt { name = "KmsDisabled"; $fault = "client"; constructor(t) { super({ name: "KmsDisabled", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, GT = class e extends nt { name = "KmsInvalidKeyUsage"; $fault = "client"; constructor(t) { super({ name: "KmsInvalidKeyUsage", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, jT = class e extends nt { name = "KmsInvalidState"; $fault = "client"; constructor(t) { super({ name: "KmsInvalidState", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, qT = class e extends nt { name = "KmsNotFound"; $fault = "client"; constructor(t) { super({ name: "KmsNotFound", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, VT = class e extends nt { name = "KmsOptInRequired"; $fault = "client"; constructor(t) { super({ name: "KmsOptInRequired", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, zT = class e extends nt { name = "KmsThrottled"; $fault = "client"; constructor(t) { super({ name: "KmsThrottled", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, WT = class e extends nt { name = "InvalidMessageContents"; $fault = "client"; constructor(t) { super({ name: "InvalidMessageContents", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, KT = class e extends nt { name = "BatchRequestTooLong"; $fault = "client"; constructor(t) { super({ name: "BatchRequestTooLong", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } } }); var $Et, FEt, MPe, UEt, $Pe, eU, HEt, GEt, jEt, qEt, QT, YT, VEt, zEt, WEt, FPe, tU, XT, KEt, QEt, UPe, YEt, XEt, JEt, ZEt, eyt, tyt, ryt, HPe, oyt, nyt, GPe, syt, iyt, ayt, cyt, pyt, jPe, uyt, myt, lyt, qPe, dyt, fyt, VPe, hyt, gyt, xyt, Eyt, zPe, WPe, rU, yyt, oU, Syt, _yt, Cyt, Ryt, Ayt, Tyt, wyt, np, byt, Iyt, vyt, Pyt, Oyt, Dyt, kyt, Nyt, Byt, Lyt, Myt, $yt, Fyt, Uyt, Hyt, KPe, Gyt, jyt, qyt, Vyt, zyt, QPe, Wyt, LPe, Kyt, Qyt, Yyt, Xyt, Jyt, Zyt, nU, sU, eSt, tSt, rSt, iU, YPe, oSt, nSt, XPe, sSt, aU, JPe, ZPe, eOe, cU, iSt, aSt, cSt, tOe, pU, rOe, pSt, uSt, mSt, oOe, lSt, JT, ZT, dSt, fSt, hSt, gSt, xSt, ESt, ySt, nOe, SSt, _St, CSt, gr, RSt, ASt, _g, TSt, wSt, bSt, ISt, vSt, PSt, OSt, DSt, kSt, uU, mU, NSt, BSt, sOe, lU, LSt, MSt, $St, iOe, FSt, USt, aOe, HSt, GSt, jSt, qSt, VSt, zSt, cOe, WSt, KSt, QSt, pOe, YSt, dU, fU, XSt, JSt, ZSt, e_t, t_t, r_t, uOe, o_t, n_t, s_t, Cg, hU, i_t, Zt, vt, Pt, er, Ht, a_t, mOe, c_t, We, Ae, D, p_t, u_t, m_t, l_t, d_t, f_t, h_t, g_t, x_t, E_t, y_t, S_t, __t, C_t, R_t, A_t, T_t, w_t, b_t, I_t, v_t, P_t, O_t, D_t, k_t, N_t, B_t, L_t, M_t, $_t, F_t, U_t, H_t, G_t, j_t, q_t, V_t, z_t, W_t, K_t, Q_t, Y_t, X_t, J_t, Z_t, eCt, tCt, rCt, oCt, nCt, sCt, iCt, aCt, cCt, pCt, uCt, mCt, lCt, dCt, fCt, hCt, gCt, xCt, ECt, yCt, SCt, _Ct, CCt, RCt, ACt, TCt, wCt, bCt, ICt, vCt, PCt, $i, OCt, gU, lOe, DCt, kCt, NCt, BCt, LCt, MCt, $Ct, FCt, dOe, xU, fOe, UCt, EU, yU, hOe, gOe, xOe, EOe, yOe, SOe, _Oe, COe, ROe, AOe, TOe, wOe, bOe, IOe, vOe, POe, OOe, DOe, kOe, NOe, BOe, LOe, MOe, Wt = s(() => { Oe(); ZF(); JF(); $Et = "Actions", FEt = "ActionName", MPe = "ApproximateNumberOfMessagesMoved", UEt = "ApproximateNumberOfMessagesToMove", $Pe = "AttributeNames", eU = "AttributeName", HEt = "AddPermission", GEt = "AddPermissionRequest", jEt = "AWSAccountIds", qEt = "AWSAccountId", QT = "Attributes", YT = "Attribute", VEt = "Body", zEt = "BatchEntryIdsNotDistinct", WEt = "BinaryList", FPe = "BinaryListValues", tU = "BinaryListValue", XT = "BatchResultErrorEntry", KEt = "BatchResultErrorEntryList", QEt = "BatchRequestTooLong", UPe = "BinaryValue", YEt = "Code", XEt = "CancelMessageMoveTask", JEt = "CancelMessageMoveTaskRequest", ZEt = "CancelMessageMoveTaskResult", eyt = "ChangeMessageVisibility", tyt = "ChangeMessageVisibilityBatch", ryt = "ChangeMessageVisibilityBatchRequest", HPe = "ChangeMessageVisibilityBatchRequestEntry", oyt = "ChangeMessageVisibilityBatchRequestEntryList", nyt = "ChangeMessageVisibilityBatchResultEntryList", GPe = "ChangeMessageVisibilityBatchResultEntry", syt = "ChangeMessageVisibilityBatchResult", iyt = "ChangeMessageVisibilityRequest", ayt = "CreateQueue", cyt = "CreateQueueRequest", pyt = "CreateQueueResult", jPe = "DestinationArn", uyt = "DeleteMessage", myt = "DeleteMessageBatch", lyt = "DeleteMessageBatchRequest", qPe = "DeleteMessageBatchRequestEntry", dyt = "DeleteMessageBatchRequestEntryList", fyt = "DeleteMessageBatchResultEntryList", VPe = "DeleteMessageBatchResultEntry", hyt = "DeleteMessageBatchResult", gyt = "DeleteMessageRequest", xyt = "DeleteQueue", Eyt = "DeleteQueueRequest", zPe = "DelaySeconds", WPe = "DataType", rU = "Entries", yyt = "EmptyBatchRequest", oU = "Failed", Syt = "FailureReason", _yt = "GetQueueAttributes", Cyt = "GetQueueAttributesRequest", Ryt = "GetQueueAttributesResult", Ayt = "GetQueueUrl", Tyt = "GetQueueUrlRequest", wyt = "GetQueueUrlResult", np = "Id", byt = "InvalidAddress", Iyt = "InvalidAttributeName", vyt = "InvalidAttributeValue", Pyt = "InvalidBatchEntryId", Oyt = "InvalidIdFormat", Dyt = "InvalidMessageContents", kyt = "InvalidSecurity", Nyt = "Key", Byt = "KmsAccessDenied", Lyt = "KmsDisabled", Myt = "KmsInvalidKeyUsage", $yt = "KmsInvalidState", Fyt = "KmsNotFound", Uyt = "KmsOptInRequired", Hyt = "KmsThrottled", KPe = "Label", Gyt = "ListDeadLetterSourceQueues", jyt = "ListDeadLetterSourceQueuesRequest", qyt = "ListDeadLetterSourceQueuesResult", Vyt = "ListMessageMoveTasks", zyt = "ListMessageMoveTasksRequest", QPe = "ListMessageMoveTasksResultEntry", Wyt = "ListMessageMoveTasksResultEntryList", LPe = "ListMessageMoveTasksResult", Kyt = "ListQueues", Qyt = "ListQueuesRequest", Yyt = "ListQueuesResult", Xyt = "ListQueueTags", Jyt = "ListQueueTagsRequest", Zyt = "ListQueueTagsResult", nU = "Message", sU = "MessageAttributes", eSt = "MessageAttributeNames", tSt = "MessageAttributeName", rSt = "MessageAttributeValue", iU = "MessageAttribute", YPe = "MessageBody", oSt = "MessageBodyAttributeMap", nSt = "MessageBodySystemAttributeMap", XPe = "MessageDeduplicationId", sSt = "MD5OfBody", aU = "MD5OfMessageAttributes", JPe = "MD5OfMessageBody", ZPe = "MD5OfMessageSystemAttributes", eOe = "MessageGroupId", cU = "MessageId", iSt = "MessageList", aSt = "MessageNotInflight", cSt = "MaxNumberOfMessages", tOe = "MaxNumberOfMessagesPerSecond", pU = "MaxResults", rOe = "MessageSystemAttributes", pSt = "MessageSystemAttributeMap", uSt = "MessageSystemAttributeNames", mSt = "MessageSystemAttributeValue", oOe = "MessageSystemAttribute", lSt = "Messages", JT = "Name", ZT = "NextToken", dSt = "OverLimit", fSt = "PurgeQueue", hSt = "PurgeQueueInProgress", gSt = "PurgeQueueRequest", xSt = "QueueAttributeMap", ESt = "QueueDoesNotExist", ySt = "QueueDeletedRecently", nOe = "QueueName", SSt = "QueueNameExists", _St = "QueueNamePrefix", CSt = "QueueOwnerAWSAccountId", gr = "QueueUrl", RSt = "QueueUrls", ASt = "Results", _g = "ReceiptHandle", TSt = "ReceiptHandleIsInvalid", wSt = "ReceiveMessage", bSt = "ReceiveMessageRequest", ISt = "ReceiveMessageResult", vSt = "ResourceNotFoundException", PSt = "RemovePermission", OSt = "RemovePermissionRequest", DSt = "ReceiveRequestAttemptId", kSt = "RequestThrottled", uU = "Successful", mU = "SourceArn", NSt = "SenderFault", BSt = "StringList", sOe = "StringListValues", lU = "StringListValue", LSt = "SendMessage", MSt = "SendMessageBatch", $St = "SendMessageBatchRequest", iOe = "SendMessageBatchRequestEntry", FSt = "SendMessageBatchRequestEntryList", USt = "SendMessageBatchResultEntryList", aOe = "SendMessageBatchResultEntry", HSt = "SendMessageBatchResult", GSt = "StartMessageMoveTask", jSt = "StartMessageMoveTaskRequest", qSt = "StartMessageMoveTaskResult", VSt = "SendMessageRequest", zSt = "SendMessageResult", cOe = "SequenceNumber", WSt = "SetQueueAttributes", KSt = "SetQueueAttributesRequest", QSt = "StartedTimestamp", pOe = "StringValue", YSt = "Status", dU = "Tag", fU = "TaskHandle", XSt = "TagKeys", JSt = "TagKey", ZSt = "TagMap", e_t = "TooManyEntriesInBatchRequest", t_t = "TagQueue", r_t = "TagQueueRequest", uOe = "Tags", o_t = "UnsupportedOperation", n_t = "UntagQueue", s_t = "UntagQueueRequest", Cg = "Value", hU = "VisibilityTimeout", i_t = "WaitTimeSeconds", Zt = "awsQueryError", vt = "client", Pt = "error", er = "httpError", Ht = "message", a_t = "queueUrls", mOe = "smithy.ts.sdk.synthetic.com.amazonaws.sqs", c_t = "tags", We = "xmlFlattened", Ae = "xmlName", D = "com.amazonaws.sqs", p_t = [3, D, GEt, 0, [gr, KPe, jEt, $Et], [0, 0, [64, { [We]: 1, [Ae]: qEt }], [64, { [We]: 1, [Ae]: FEt }]]], u_t = [-3, D, zEt, { [Zt]: ["AWS.SimpleQueueService.BatchEntryIdsNotDistinct", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(u_t, PT); m_t = [-3, D, QEt, { [Zt]: ["AWS.SimpleQueueService.BatchRequestTooLong", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(m_t, KT); l_t = [3, D, XT, 0, [np, NSt, YEt, nU], [0, 2, 0, 0]], d_t = [3, D, JEt, 0, [fU], [0]], f_t = [3, D, ZEt, 0, [MPe], [1]], h_t = [3, D, ryt, 0, [gr, rU], [0, [() => DCt, { [We]: 1, [Ae]: HPe }]]], g_t = [3, D, HPe, 0, [np, _g, hU], [0, 0, 1]], x_t = [3, D, syt, 0, [uU, oU], [[() => kCt, { [We]: 1, [Ae]: GPe }], [() => gU, { [We]: 1, [Ae]: XT }]]], E_t = [3, D, GPe, 0, [np], [0]], y_t = [3, D, iyt, 0, [gr, _g, hU], [0, 0, 1]], S_t = [3, D, cyt, 0, [nOe, QT, c_t], [0, [() => EU, { [We]: 1, [Ae]: YT }], [() => yU, { [We]: 1, [Ae]: dU }]]], __t = [3, D, pyt, 0, [gr], [0]], C_t = [3, D, lyt, 0, [gr, rU], [0, [() => NCt, { [We]: 1, [Ae]: qPe }]]], R_t = [3, D, qPe, 0, [np, _g], [0, 0]], A_t = [3, D, hyt, 0, [uU, oU], [[() => BCt, { [We]: 1, [Ae]: VPe }], [() => gU, { [We]: 1, [Ae]: XT }]]], T_t = [3, D, VPe, 0, [np], [0]], w_t = [3, D, gyt, 0, [gr, _g], [0, 0]], b_t = [3, D, Eyt, 0, [gr], [0]], I_t = [-3, D, yyt, { [Zt]: ["AWS.SimpleQueueService.EmptyBatchRequest", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(I_t, OT); v_t = [3, D, Cyt, 0, [gr, $Pe], [0, [64, { [We]: 1, [Ae]: eU }]]], P_t = [3, D, Ryt, 0, [QT], [[() => EU, { [We]: 1, [Ae]: YT }]]], O_t = [3, D, Tyt, 0, [nOe, CSt], [0, 0]], D_t = [3, D, wyt, 0, [gr], [0]], k_t = [-3, D, byt, { [Zt]: ["InvalidAddress", 404], [Pt]: vt, [er]: 404 }, [Ht], [0]]; k.for(D).registerError(k_t, _T); N_t = [-3, D, Iyt, { [Pt]: vt }, [Ht], [0]]; k.for(D).registerError(N_t, NT); B_t = [-3, D, vyt, { [Pt]: vt }, [Ht], [0]]; k.for(D).registerError(B_t, BT); L_t = [-3, D, Pyt, { [Zt]: ["AWS.SimpleQueueService.InvalidBatchEntryId", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(L_t, DT); M_t = [-3, D, Oyt, { [Pt]: vt }, [], []]; k.for(D).registerError(M_t, $T); $_t = [-3, D, Dyt, { [Pt]: vt }, [Ht], [0]]; k.for(D).registerError($_t, WT); F_t = [-3, D, kyt, { [Zt]: ["InvalidSecurity", 403], [Pt]: vt, [er]: 403 }, [Ht], [0]]; k.for(D).registerError(F_t, CT); U_t = [-3, D, Byt, { [Zt]: ["KMS.AccessDeniedException", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(U_t, UT); H_t = [-3, D, Lyt, { [Zt]: ["KMS.DisabledException", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(H_t, HT); G_t = [-3, D, Myt, { [Zt]: ["KMS.InvalidKeyUsageException", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(G_t, GT); j_t = [-3, D, $yt, { [Zt]: ["KMS.InvalidStateException", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(j_t, jT); q_t = [-3, D, Fyt, { [Zt]: ["KMS.NotFoundException", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(q_t, qT); V_t = [-3, D, Uyt, { [Zt]: ["KMS.OptInRequired", 403], [Pt]: vt, [er]: 403 }, [Ht], [0]]; k.for(D).registerError(V_t, VT); z_t = [-3, D, Hyt, { [Zt]: ["KMS.ThrottlingException", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(z_t, zT); W_t = [3, D, jyt, 0, [gr, ZT, pU], [0, 0, 1]], K_t = [3, D, qyt, 0, [a_t, ZT], [[64, { [We]: 1, [Ae]: gr }], 0]], Q_t = [3, D, zyt, 0, [mU, pU], [0, 1]], Y_t = [3, D, LPe, { [Ae]: LPe }, [ASt], [[() => LCt, { [We]: 1, [Ae]: QPe }]]], X_t = [3, D, QPe, 0, [fU, YSt, mU, jPe, tOe, MPe, UEt, Syt, QSt], [0, 0, 0, 0, 1, 1, 1, 0, 1]], J_t = [3, D, Qyt, 0, [_St, ZT, pU], [0, 0, 1]], Z_t = [3, D, Yyt, 0, [RSt, ZT], [[64, { [We]: 1, [Ae]: gr }], 0]], eCt = [3, D, Jyt, 0, [gr], [0]], tCt = [3, D, Zyt, 0, [uOe], [[() => yU, { [We]: 1, [Ae]: dU }]]], rCt = [3, D, nU, 0, [cU, _g, sSt, VEt, QT, aU, sU], [0, 0, 0, 0, [() => UCt, { [We]: 1, [Ae]: YT }], 0, [() => xU, { [We]: 1, [Ae]: iU }]]], oCt = [3, D, rSt, 0, [pOe, UPe, sOe, FPe, WPe], [0, 21, [() => dOe, { [We]: 1, [Ae]: lU }], [() => lOe, { [We]: 1, [Ae]: tU }], 0]], nCt = [-3, D, aSt, { [Zt]: ["AWS.SimpleQueueService.MessageNotInflight", 400], [Pt]: vt, [er]: 400 }, [], []]; k.for(D).registerError(nCt, IT); sCt = [3, D, mSt, 0, [pOe, UPe, sOe, FPe, WPe], [0, 21, [() => dOe, { [We]: 1, [Ae]: lU }], [() => lOe, { [We]: 1, [Ae]: tU }], 0]], iCt = [-3, D, dSt, { [Zt]: ["OverLimit", 403], [Pt]: vt, [er]: 403 }, [Ht], [0]]; k.for(D).registerError(iCt, RT); aCt = [-3, D, hSt, { [Zt]: ["AWS.SimpleQueueService.PurgeQueueInProgress", 403], [Pt]: vt, [er]: 403 }, [Ht], [0]]; k.for(D).registerError(aCt, FT); cCt = [3, D, gSt, 0, [gr], [0]], pCt = [-3, D, ySt, { [Zt]: ["AWS.SimpleQueueService.QueueDeletedRecently", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(pCt, LT); uCt = [-3, D, ESt, { [Zt]: ["AWS.SimpleQueueService.NonExistentQueue", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(uCt, AT); mCt = [-3, D, SSt, { [Zt]: ["QueueAlreadyExists", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(mCt, MT); lCt = [-3, D, TSt, { [Zt]: ["ReceiptHandleIsInvalid", 404], [Pt]: vt, [er]: 404 }, [Ht], [0]]; k.for(D).registerError(lCt, vT); dCt = [3, D, bSt, 0, [gr, $Pe, uSt, eSt, cSt, hU, i_t, DSt], [0, [64, { [We]: 1, [Ae]: eU }], [64, { [We]: 1, [Ae]: eU }], [64, { [We]: 1, [Ae]: tSt }], 1, 1, 1, 0]], fCt = [3, D, ISt, 0, [lSt], [[() => MCt, { [We]: 1, [Ae]: nU }]]], hCt = [3, D, OSt, 0, [gr, KPe], [0, 0]], gCt = [-3, D, kSt, { [Zt]: ["RequestThrottled", 403], [Pt]: vt, [er]: 403 }, [Ht], [0]]; k.for(D).registerError(gCt, TT); xCt = [-3, D, vSt, { [Zt]: ["ResourceNotFoundException", 404], [Pt]: vt, [er]: 404 }, [Ht], [0]]; k.for(D).registerError(xCt, bT); ECt = [3, D, $St, 0, [gr, rU], [0, [() => $Ct, { [We]: 1, [Ae]: iOe }]]], yCt = [3, D, iOe, 0, [np, YPe, zPe, sU, rOe, XPe, eOe], [0, 0, 1, [() => xU, { [We]: 1, [Ae]: iU }], [() => fOe, { [We]: 1, [Ae]: oOe }], 0, 0]], SCt = [3, D, HSt, 0, [uU, oU], [[() => FCt, { [We]: 1, [Ae]: aOe }], [() => gU, { [We]: 1, [Ae]: XT }]]], _Ct = [3, D, aOe, 0, [np, cU, JPe, aU, ZPe, cOe], [0, 0, 0, 0, 0, 0]], CCt = [3, D, VSt, 0, [gr, YPe, zPe, sU, rOe, XPe, eOe], [0, 0, 1, [() => xU, { [We]: 1, [Ae]: iU }], [() => fOe, { [We]: 1, [Ae]: oOe }], 0, 0]], RCt = [3, D, zSt, 0, [JPe, aU, ZPe, cU, cOe], [0, 0, 0, 0, 0]], ACt = [3, D, KSt, 0, [gr, QT], [0, [() => EU, { [We]: 1, [Ae]: YT }]]], TCt = [3, D, jSt, 0, [mU, jPe, tOe], [0, 0, 1]], wCt = [3, D, qSt, 0, [fU], [0]], bCt = [3, D, r_t, 0, [gr, uOe], [0, [() => yU, { [We]: 1, [Ae]: dU }]]], ICt = [-3, D, e_t, { [Zt]: ["AWS.SimpleQueueService.TooManyEntriesInBatchRequest", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(ICt, kT); vCt = [-3, D, o_t, { [Zt]: ["AWS.SimpleQueueService.UnsupportedOperation", 400], [Pt]: vt, [er]: 400 }, [Ht], [0]]; k.for(D).registerError(vCt, wT); PCt = [3, D, s_t, 0, [gr, XSt], [0, [64, { [We]: 1, [Ae]: JSt }]]], $i = "unit", OCt = [-3, mOe, "SQSServiceException", 0, [], []]; k.for(mOe).registerError(OCt, nt); gU = [1, D, KEt, 0, () => l_t], lOe = [1, D, WEt, 0, [21, { [Ae]: tU }]], DCt = [1, D, oyt, 0, () => g_t], kCt = [1, D, nyt, 0, () => E_t], NCt = [1, D, dyt, 0, () => R_t], BCt = [1, D, fyt, 0, () => T_t], LCt = [1, D, Wyt, 0, () => X_t], MCt = [1, D, iSt, 0, [() => rCt, 0]], $Ct = [1, D, FSt, 0, [() => yCt, 0]], FCt = [1, D, USt, 0, () => _Ct], dOe = [1, D, BSt, 0, [0, { [Ae]: lU }]], xU = [2, D, oSt, 0, [0, { [Ae]: JT }], [() => oCt, { [Ae]: Cg }]], fOe = [2, D, nSt, 0, [0, { [Ae]: JT }], [() => sCt, { [Ae]: Cg }]], UCt = [2, D, pSt, 0, [0, { [Ae]: JT }], [0, { [Ae]: Cg }]], EU = [2, D, xSt, 0, [0, { [Ae]: JT }], [0, { [Ae]: Cg }]], yU = [2, D, ZSt, 0, [0, { [Ae]: Nyt }], [0, { [Ae]: Cg }]], hOe = [9, D, HEt, 0, () => p_t, () => $i], gOe = [9, D, XEt, 0, () => d_t, () => f_t], xOe = [9, D, eyt, 0, () => y_t, () => $i], EOe = [9, D, tyt, 0, () => h_t, () => x_t], yOe = [9, D, ayt, 0, () => S_t, () => __t], SOe = [9, D, uyt, 0, () => w_t, () => $i], _Oe = [9, D, myt, 0, () => C_t, () => A_t], COe = [9, D, xyt, 0, () => b_t, () => $i], ROe = [9, D, _yt, 0, () => v_t, () => P_t], AOe = [9, D, Ayt, 0, () => O_t, () => D_t], TOe = [9, D, Gyt, 0, () => W_t, () => K_t], wOe = [9, D, Vyt, 0, () => Q_t, () => Y_t], bOe = [9, D, Kyt, 0, () => J_t, () => Z_t], IOe = [9, D, Xyt, 0, () => eCt, () => tCt], vOe = [9, D, fSt, 0, () => cCt, () => $i], POe = [9, D, wSt, 0, () => dCt, () => fCt], OOe = [9, D, PSt, 0, () => hCt, () => $i], DOe = [9, D, LSt, 0, () => CCt, () => RCt], kOe = [9, D, MSt, 0, () => ECt, () => SCt], NOe = [9, D, WSt, 0, () => ACt, () => $i], BOe = [9, D, GSt, 0, () => TCt, () => wCt], LOe = [9, D, t_t, 0, () => bCt, () => $i], MOe = [9, D, n_t, 0, () => PCt, () => $i] }); var ew, SU = s(() => { St(); Be(); zt(); Wt(); ew = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "AddPermission", {}).n("SQSClient", "AddPermissionCommand").sc(hOe).build() { } }); var tw, _U = s(() => { St(); Be(); zt(); Wt(); tw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "CancelMessageMoveTask", {}).n("SQSClient", "CancelMessageMoveTaskCommand").sc(gOe).build() { } }); var rw, CU = s(() => { St(); Be(); zt(); Wt(); rw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "ChangeMessageVisibilityBatch", {}).n("SQSClient", "ChangeMessageVisibilityBatchCommand").sc(EOe).build() { } }); var ow, RU = s(() => { St(); Be(); zt(); Wt(); ow = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "ChangeMessageVisibility", {}).n("SQSClient", "ChangeMessageVisibilityCommand").sc(xOe).build() { } }); var nw, AU = s(() => { St(); Be(); zt(); Wt(); nw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "CreateQueue", {}).n("SQSClient", "CreateQueueCommand").sc(yOe).build() { } }); var sw, TU = s(() => { St(); Be(); zt(); Wt(); sw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "DeleteMessageBatch", {}).n("SQSClient", "DeleteMessageBatchCommand").sc(_Oe).build() { } }); var iw, wU = s(() => { St(); Be(); zt(); Wt(); iw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "DeleteMessage", {}).n("SQSClient", "DeleteMessageCommand").sc(SOe).build() { } }); var aw, bU = s(() => { St(); Be(); zt(); Wt(); aw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "DeleteQueue", {}).n("SQSClient", "DeleteQueueCommand").sc(COe).build() { } }); var cw, IU = s(() => { St(); Be(); zt(); Wt(); cw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "GetQueueAttributes", {}).n("SQSClient", "GetQueueAttributesCommand").sc(ROe).build() { } }); var pw, vU = s(() => { St(); Be(); zt(); Wt(); pw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "GetQueueUrl", {}).n("SQSClient", "GetQueueUrlCommand").sc(AOe).build() { } }); var Al, uw = s(() => { St(); Be(); zt(); Wt(); Al = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "ListDeadLetterSourceQueues", {}).n("SQSClient", "ListDeadLetterSourceQueuesCommand").sc(TOe).build() { } }); var mw, PU = s(() => { St(); Be(); zt(); Wt(); mw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "ListMessageMoveTasks", {}).n("SQSClient", "ListMessageMoveTasksCommand").sc(wOe).build() { } }); var Tl, lw = s(() => { St(); Be(); zt(); Wt(); Tl = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "ListQueues", {}).n("SQSClient", "ListQueuesCommand").sc(bOe).build() { } }); var dw, OU = s(() => { St(); Be(); zt(); Wt(); dw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "ListQueueTags", {}).n("SQSClient", "ListQueueTagsCommand").sc(IOe).build() { } }); var fw, DU = s(() => { St(); Be(); zt(); Wt(); fw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "PurgeQueue", {}).n("SQSClient", "PurgeQueueCommand").sc(vOe).build() { } }); var hw, kU = s(() => { eg(); St(); Be(); zt(); Wt(); hw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions()), GAe(o)] }).s("AmazonSQS", "ReceiveMessage", {}).n("SQSClient", "ReceiveMessageCommand").sc(POe).build() { } }); var gw, NU = s(() => { St(); Be(); zt(); Wt(); gw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "RemovePermission", {}).n("SQSClient", "RemovePermissionCommand").sc(OOe).build() { } }); var xw, BU = s(() => { eg(); St(); Be(); zt(); Wt(); xw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions()), zAe(o)] }).s("AmazonSQS", "SendMessageBatch", {}).n("SQSClient", "SendMessageBatchCommand").sc(kOe).build() { } }); var wl, LU = s(() => { eg(); St(); Be(); zt(); Wt(); wl = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions()), qAe(o)] }).s("AmazonSQS", "SendMessage", {}).n("SQSClient", "SendMessageCommand").sc(DOe).build() { } }); var Ew, MU = s(() => { St(); Be(); zt(); Wt(); Ew = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "SetQueueAttributes", {}).n("SQSClient", "SetQueueAttributesCommand").sc(NOe).build() { } }); var yw, $U = s(() => { St(); Be(); zt(); Wt(); yw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "StartMessageMoveTask", {}).n("SQSClient", "StartMessageMoveTaskCommand").sc(BOe).build() { } }); var Sw, FU = s(() => { St(); Be(); zt(); Wt(); Sw = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "TagQueue", {}).n("SQSClient", "TagQueueCommand").sc(LOe).build() { } }); var _w, UU = s(() => { St(); Be(); zt(); Wt(); _w = class extends Se.classBuilder().ep(ve).m(function (t, r, o, n) { return [_e(o, t.getEndpointParameterInstructions())] }).s("AmazonSQS", "UntagQueue", {}).n("SQSClient", "UntagQueueCommand").sc(MOe).build() { } }); var HCt, HU, $Oe = s(() => { Be(); SU(); _U(); CU(); RU(); AU(); TU(); wU(); bU(); IU(); vU(); uw(); PU(); lw(); OU(); DU(); kU(); NU(); BU(); LU(); MU(); $U(); FU(); UU(); Sg(); HCt = { AddPermissionCommand: ew, CancelMessageMoveTaskCommand: tw, ChangeMessageVisibilityCommand: ow, ChangeMessageVisibilityBatchCommand: rw, CreateQueueCommand: nw, DeleteMessageCommand: iw, DeleteMessageBatchCommand: sw, DeleteQueueCommand: aw, GetQueueAttributesCommand: cw, GetQueueUrlCommand: pw, ListDeadLetterSourceQueuesCommand: Al, ListMessageMoveTasksCommand: mw, ListQueuesCommand: Tl, ListQueueTagsCommand: dw, PurgeQueueCommand: fw, ReceiveMessageCommand: hw, RemovePermissionCommand: gw, SendMessageCommand: wl, SendMessageBatchCommand: xw, SetQueueAttributesCommand: Ew, StartMessageMoveTaskCommand: yw, TagQueueCommand: Sw, UntagQueueCommand: _w }, HU = class extends Xs { }; vA(HCt, HU) }); var FOe = s(() => { SU(); _U(); CU(); RU(); AU(); TU(); wU(); bU(); IU(); vU(); uw(); PU(); OU(); lw(); DU(); kU(); NU(); BU(); LU(); MU(); $U(); FU(); UU() }); var UOe = s(() => { }); var Uco, HOe = s(() => { Ie(); uw(); Sg(); Uco = qe(Xs, Al, "NextToken", "NextToken", "MaxResults") }); var Vco, GOe = s(() => { Ie(); lw(); Sg(); Vco = qe(Xs, Tl, "NextToken", "NextToken", "MaxResults") }); var jOe = s(() => { UOe(); HOe(); GOe() }); var qOe = s(() => { }); var VOe = s(() => { }); var zOe = s(() => { Sg(); $Oe(); FOe(); Wt(); jOe(); qOe(); ZF(); VOe() }); var WOe = {}; Qe(WOe, { default: () => zCt }); var GCt, jCt, qCt, VCt, zCt, KOe = s(() => { zOe(); vr(); ({ REVALIDATION_QUEUE_REGION: GCt, REVALIDATION_QUEUE_URL: jCt } = process.env), qCt = new Xs({ region: GCt, logger: vp }), VCt = { send: async ({ MessageBody: e, MessageDeduplicationId: t, MessageGroupId: r }) => { await qCt.send(new wl({ QueueUrl: jCt, MessageBody: JSON.stringify(e), MessageDeduplicationId: t, MessageGroupId: r })) }, name: "sqs" }, zCt = VCt }); var QOe = s(() => { }); var YOe = s(() => { QOe() }); var XOe = s(() => { }); var JOe = s(() => { }); var ZOe = s(() => { }); function WCt(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var Cw, eDe = s(() => { Cw = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = WCt(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var tDe = s(() => { }); var rDe = s(() => { }); var oDe = s(() => { }); var nDe = s(() => { YOe(); XOe(); JOe(); ZOe(); eDe(); tDe(); rDe(); oDe() }); function KCt(e) { return t => async r => { let { request: o } = r; if (e.expectContinueHeader !== !1 && Cw.isInstance(o) && o.body && e.runtime === "node" && e.requestHandler?.constructor?.name !== "FetchHttpHandler") { let n = !0; if (typeof e.expectContinueHeader == "number") try { n = (Number(o.headers?.["content-length"]) ?? e.bodyLengthChecker?.(o.body) ?? 1 / 0) >= e.expectContinueHeader } catch { } else n = !!e.expectContinueHeader; n && (o.headers.Expect = "100-continue") } return t({ ...r, request: o }) } } var QCt, sDe, iDe = s(() => { nDe(); QCt = { step: "build", tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"], name: "addExpectContinueMiddleware", override: !0 }, sDe = e => ({ applyToStack: t => { t.add(KCt(e), QCt) } }) }); var Un, Rw, sp, Aw, mt, aDe, Rg, Hn = s(() => { Un = { WHEN_SUPPORTED: "WHEN_SUPPORTED", WHEN_REQUIRED: "WHEN_REQUIRED" }, Rw = Un.WHEN_SUPPORTED, sp = { WHEN_SUPPORTED: "WHEN_SUPPORTED", WHEN_REQUIRED: "WHEN_REQUIRED" }, Aw = Un.WHEN_SUPPORTED; (function (e) { e.MD5 = "MD5", e.CRC32 = "CRC32", e.CRC32C = "CRC32C", e.CRC64NVME = "CRC64NVME", e.SHA1 = "SHA1", e.SHA256 = "SHA256" })(mt || (mt = {})); (function (e) { e.HEADER = "header", e.TRAILER = "trailer" })(aDe || (aDe = {})); Rg = mt.CRC32 }); var Va, bl, GU = s(() => { (function (e) { e.ENV = "env", e.CONFIG = "shared config entry" })(Va || (Va = {})); bl = (e, t, r, o) => { if (!(t in e)) return; let n = e[t].toUpperCase(); if (!Object.values(r).includes(n)) throw new TypeError(`Cannot load ${o} '${t}'. Expected one of ${Object.values(r)}, got '${e[t]}'.`); return n } }); var YCt, XCt, cDe, pDe = s(() => { Hn(); GU(); YCt = "AWS_REQUEST_CHECKSUM_CALCULATION", XCt = "request_checksum_calculation", cDe = { environmentVariableSelector: e => bl(e, YCt, Un, Va.ENV), configFileSelector: e => bl(e, XCt, Un, Va.CONFIG), default: Rw } }); var JCt, ZCt, uDe, mDe = s(() => { Hn(); GU(); JCt = "AWS_RESPONSE_CHECKSUM_VALIDATION", ZCt = "response_checksum_validation", uDe = { environmentVariableSelector: e => bl(e, JCt, sp, Va.ENV), configFileSelector: e => bl(e, ZCt, sp, Va.CONFIG), default: Aw } }); var lDe = s(() => { }); var dDe = s(() => { lDe() }); var fDe = s(() => { }); var hDe = s(() => { }); var gDe = s(() => { }); function eRt(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var Il, xDe = s(() => { Il = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = eRt(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var EDe = s(() => { }); var yDe = s(() => { }); var SDe = s(() => { }); var jU = s(() => { dDe(); fDe(); hDe(); gDe(); xDe(); EDe(); yDe(); SDe() }); import { Buffer as tRt } from "buffer"; var _De, CDe = s(() => { cr(); _De = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return tRt.from(e, t, r) } }); var RDe = s(() => { }); import { Buffer as ADe } from "buffer"; var TDe, wDe = s(() => { TDe = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? ADe.from(e, t) : ADe.from(e) } }); var Tw, qU = s(() => { wDe(); Tw = e => { let t = TDe(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var bDe, IDe = s(() => { qU(); bDe = e => typeof e == "string" ? Tw(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) }); var vDe = s(() => { }); var VU = s(() => { qU(); IDe(); vDe() }); var ww, PDe = s(() => { CDe(); VU(); ww = e => { let t; if (typeof e == "string" ? t = Tw(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return _De(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var zU = s(() => { RDe(); PDe() }); var ODe = s(() => { }); import { Duplex as rRt } from "stream"; var bw, WU = s(() => { zU(); bw = class extends rRt { expectedChecksum; checksumSourceLocation; checksum; source; base64Encoder; constructor({ expectedChecksum: t, checksum: r, source: o, checksumSourceLocation: n, base64Encoder: i }) { if (super(), typeof o.pipe == "function") this.source = o; else throw new Error(`@smithy/util-stream: unsupported source type ${o?.constructor?.name ?? o} in ChecksumStream.`); this.base64Encoder = i ?? ww, this.expectedChecksum = t, this.checksum = r, this.checksumSourceLocation = n, this.source.pipe(this) } _read(t) { } _write(t, r, o) { try { this.checksum.update(t), this.push(t) } catch (n) { return o(n) } return o() } async _final(t) { try { let r = await this.checksum.digest(), o = this.base64Encoder(r); if (this.expectedChecksum !== o) return t(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${o}" in response header "${this.checksumSourceLocation}".`)) } catch (r) { return t(r) } return this.push(null), t() } } }); var vl, Ag = s(() => { vl = e => typeof ReadableStream == "function" && (e?.constructor?.name === ReadableStream.name || e instanceof ReadableStream) }); var oRt, Iw, DDe = s(() => { oRt = typeof ReadableStream == "function" ? ReadableStream : function () { }, Iw = class extends oRt { } }); var kDe, NDe = s(() => { zU(); Ag(); DDe(); kDe = ({ expectedChecksum: e, checksum: t, source: r, checksumSourceLocation: o, base64Encoder: n }) => { if (!vl(r)) throw new Error(`@smithy/util-stream: unsupported source type ${r?.constructor?.name ?? r} in ChecksumStream.`); let i = n ?? ww; if (typeof TransformStream != "function") throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream."); let a = new TransformStream({ start() { }, async transform(p, u) { t.update(p), u.enqueue(p) }, async flush(p) { let u = await t.digest(), l = i(u); if (e !== l) { let m = new Error(`Checksum mismatch: expected "${e}" but received "${l}" in response header "${o}".`); p.error(m) } else p.terminate() } }); r.pipeThrough(a); let c = a.readable; return Object.setPrototypeOf(c, Iw.prototype), c } }); function BDe(e) { return typeof ReadableStream == "function" && vl(e.source) ? kDe(e) : new bw(e) } var LDe = s(() => { Ag(); WU(); NDe() }); var ip, KU = s(() => { ip = class { allocByteArray; byteLength = 0; byteArrays = []; constructor(t) { this.allocByteArray = t } push(t) { this.byteArrays.push(t), this.byteLength += t.byteLength } flush() { if (this.byteArrays.length === 1) { let o = this.byteArrays[0]; return this.reset(), o } let t = this.allocByteArray(this.byteLength), r = 0; for (let o = 0; o < this.byteArrays.length; ++o) { let n = this.byteArrays[o]; t.set(n, r), r += n.byteLength } return this.reset(), t } reset() { this.byteArrays = [], this.byteLength = 0 } } }); function MDe(e, t, r) { let o = e.getReader(), n = !1, i = 0, a = ["", new ip(u => new Uint8Array(u))], c = -1, p = async u => { let { value: l, done: m } = await o.read(), f = l; if (m) { if (c !== -1) { let h = ap(a, c); Fi(h) > 0 && u.enqueue(h) } u.close() } else { let h = YU(f, !1); if (c !== h && (c >= 0 && u.enqueue(ap(a, c)), c = h), c === -1) { u.enqueue(f); return } let E = Fi(f); i += E; let S = Fi(a[c]); if (E >= t && S === 0) u.enqueue(f); else { let y = QU(a, c, f); !n && i > t * 2 && (n = !0, r?.warn(`@smithy/util-stream - stream chunk size ${E} is below threshold of ${t}, automatically buffering.`)), y >= t ? u.enqueue(ap(a, c)) : await p(u) } } }; return new ReadableStream({ pull: p }) } function QU(e, t, r) { switch (t) { case 0: return e[0] += r, Fi(e[0]); case 1: case 2: return e[t].push(r), Fi(e[t]) } } function ap(e, t) { switch (t) { case 0: let r = e[0]; return e[0] = "", r; case 1: case 2: return e[t].flush() }throw new Error(`@smithy/util-stream - invalid index ${t} given to flush()`) } function Fi(e) { return e?.byteLength ?? e?.length ?? 0 } function YU(e, t = !0) { return t && typeof Buffer < "u" && e instanceof Buffer ? 2 : e instanceof Uint8Array ? 1 : typeof e == "string" ? 0 : -1 } var $De = s(() => { KU() }); import { Readable as nRt } from "node:stream"; function FDe(e, t, r) { if (vl(e)) return MDe(e, t, r); let o = new nRt({ read() { } }), n = !1, i = 0, a = ["", new ip(p => new Uint8Array(p)), new ip(p => Buffer.from(new Uint8Array(p)))], c = -1; return e.on("data", p => { let u = YU(p, !0); if (c !== u && (c >= 0 && o.push(ap(a, c)), c = u), c === -1) { o.push(p); return } let l = Fi(p); i += l; let m = Fi(a[c]); if (l >= t && m === 0) o.push(p); else { let f = QU(a, c, p); !n && i > t * 2 && (n = !0, r?.warn(`@smithy/util-stream - stream chunk size ${l} is below threshold of ${t}, automatically buffering.`)), f >= t && o.push(ap(a, c)) } }), e.on("end", () => { if (c !== -1) { let p = ap(a, c); Fi(p) > 0 && o.push(p) } o.push(null) }), o } var UDe = s(() => { KU(); $De(); Ag() }); var HDe = s(() => { }); var GDe = s(() => { }); var jDe = s(() => { }); var qDe = s(() => { }); var XU = s(() => { ODe(); WU(); LDe(); UDe(); HDe(); GDe(); jDe(); qDe(); Ag() }); var Tg, VDe, JU = s(() => { Hn(); Tg = [mt.CRC32, mt.CRC32C, mt.CRC64NVME, mt.SHA1, mt.SHA256], VDe = [mt.SHA256, mt.SHA1, mt.CRC32, mt.CRC32C, mt.CRC64NVME] }); var zDe, WDe = s(() => { Hn(); JU(); zDe = (e, { requestChecksumRequired: t, requestAlgorithmMember: r, requestChecksumCalculation: o }) => { if (!r) return o === Un.WHEN_SUPPORTED || t ? Rg : void 0; if (!e[r]) return; let n = e[r]; if (!Tg.includes(n)) throw new Error(`The checksum algorithm "${n}" is not supported by the client. Select one of ${Tg}.`); return n } }); var Pl, vw = s(() => { Hn(); Pl = e => e === mt.MD5 ? "content-md5" : `x-amz-checksum-${e.toLowerCase()}` }); var KDe, QDe = s(() => { KDe = (e, t) => { let r = e.toLowerCase(); for (let o of Object.keys(t)) if (r === o.toLowerCase()) return !0; return !1 } }); var YDe, XDe = s(() => { YDe = (e, t) => { let r = e.toLowerCase(); for (let o of Object.keys(t)) if (o.toLowerCase().startsWith(r)) return !0; return !1 } }); var Pw, ZU = s(() => { cr(); Pw = e => e !== void 0 && typeof e != "string" && !ArrayBuffer.isView(e) && !Le(e) }); function Ow(e, t, r, o) { function n(i) { return i instanceof r ? i : new r(function (a) { a(i) }) } return new (r || (r = Promise))(function (i, a) { function c(l) { try { u(o.next(l)) } catch (m) { a(m) } } function p(l) { try { u(o.throw(l)) } catch (m) { a(m) } } function u(l) { l.done ? i(l.value) : n(l.value).then(c, p) } u((o = o.apply(e, t || [])).next()) }) } function Dw(e, t) { var r = { label: 0, sent: function () { if (i[0] & 1) throw i[1]; return i[1] }, trys: [], ops: [] }, o, n, i, a = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype); return a.next = c(0), a.throw = c(1), a.return = c(2), typeof Symbol == "function" && (a[Symbol.iterator] = function () { return this }), a; function c(u) { return function (l) { return p([u, l]) } } function p(u) { if (o) throw new TypeError("Generator is already executing."); for (; a && (a = 0, u[0] && (r = 0)), r;)try { if (o = 1, n && (i = u[0] & 2 ? n.return : u[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, u[1])).done) return i; switch (n = 0, i && (u = [u[0] & 2, i.value]), u[0]) { case 0: case 1: i = u; break; case 4: return r.label++, { value: u[1], done: !1 }; case 5: r.label++, n = u[1], u = [0]; continue; case 7: u = r.ops.pop(), r.trys.pop(); continue; default: if (i = r.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) { r = 0; continue } if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) { r.label = u[1]; break } if (u[0] === 6 && r.label < i[1]) { r.label = i[1], i = u; break } if (i && r.label < i[2]) { r.label = i[2], r.ops.push(u); break } i[2] && r.ops.pop(), r.trys.pop(); continue }u = t.call(e, r) } catch (l) { u = [6, l], n = 0 } finally { o = i = 0 } if (u[0] & 5) throw u[1]; return { value: u[0] ? u[1] : void 0, done: !0 } } } function kw(e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], o = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && o >= e.length && (e = void 0), { value: e && e[o++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } var wg = s(() => { }); var JDe = s(() => { }); import { Buffer as ZDe } from "buffer"; var Nw, bg = s(() => { JDe(); Nw = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? ZDe.from(e, t) : ZDe.from(e) } }); var Ig, e1 = s(() => { bg(); Ig = e => { let t = Nw(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var eke = s(() => { e1() }); var tke = s(() => { bg() }); var t1 = s(() => { e1(); eke(); tke() }); function r1(e) { return e instanceof Uint8Array ? e : typeof e == "string" ? iRt(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) } var iRt, rke = s(() => { t1(); iRt = typeof Buffer < "u" && Buffer.from ? function (e) { return Buffer.from(e, "utf8") } : Ig }); function o1(e) { return typeof e == "string" ? e.length === 0 : e.byteLength === 0 } var oke = s(() => { }); function n1(e) { return new Uint8Array([(e & 4278190080) >> 24, (e & 16711680) >> 16, (e & 65280) >> 8, e & 255]) } var nke = s(() => { }); function s1(e) { if (!Uint32Array.from) { for (var t = new Uint32Array(e.length), r = 0; r < e.length;)t[r] = e[r], r += 1; return t } return Uint32Array.from(e) } var ske = s(() => { }); var i1 = s(() => { rke(); oke(); nke(); ske() }); var c1, ike = s(() => { wg(); i1(); p1(); c1 = function () { function e() { this.crc32c = new a1 } return e.prototype.update = function (t) { o1(t) || this.crc32c.update(r1(t)) }, e.prototype.digest = function () { return Ow(this, void 0, void 0, function () { return Dw(this, function (t) { return [2, n1(this.crc32c.digest())] }) }) }, e.prototype.reset = function () { this.crc32c = new a1 }, e }() }); var a1, aRt, cRt, p1 = s(() => { wg(); i1(); ike(); a1 = function () { function e() { this.checksum = 4294967295 } return e.prototype.update = function (t) { var r, o; try { for (var n = kw(t), i = n.next(); !i.done; i = n.next()) { var a = i.value; this.checksum = this.checksum >>> 8 ^ cRt[(this.checksum ^ a) & 255] } } catch (c) { r = { error: c } } finally { try { i && !i.done && (o = n.return) && o.call(n) } finally { if (r) throw r.error } } return this }, e.prototype.digest = function () { return (this.checksum ^ 4294967295) >>> 0 }, e }(), aRt = [0, 4067132163, 3778769143, 324072436, 3348797215, 904991772, 648144872, 3570033899, 2329499855, 2024987596, 1809983544, 2575936315, 1296289744, 3207089363, 2893594407, 1578318884, 274646895, 3795141740, 4049975192, 51262619, 3619967088, 632279923, 922689671, 3298075524, 2592579488, 1760304291, 2075979607, 2312596564, 1562183871, 2943781820, 3156637768, 1313733451, 549293790, 3537243613, 3246849577, 871202090, 3878099393, 357341890, 102525238, 4101499445, 2858735121, 1477399826, 1264559846, 3107202533, 1845379342, 2677391885, 2361733625, 2125378298, 820201905, 3263744690, 3520608582, 598981189, 4151959214, 85089709, 373468761, 3827903834, 3124367742, 1213305469, 1526817161, 2842354314, 2107672161, 2412447074, 2627466902, 1861252501, 1098587580, 3004210879, 2688576843, 1378610760, 2262928035, 1955203488, 1742404180, 2511436119, 3416409459, 969524848, 714683780, 3639785095, 205050476, 4266873199, 3976438427, 526918040, 1361435347, 2739821008, 2954799652, 1114974503, 2529119692, 1691668175, 2005155131, 2247081528, 3690758684, 697762079, 986182379, 3366744552, 476452099, 3993867776, 4250756596, 255256311, 1640403810, 2477592673, 2164122517, 1922457750, 2791048317, 1412925310, 1197962378, 3037525897, 3944729517, 427051182, 170179418, 4165941337, 746937522, 3740196785, 3451792453, 1070968646, 1905808397, 2213795598, 2426610938, 1657317369, 3053634322, 1147748369, 1463399397, 2773627110, 4215344322, 153784257, 444234805, 3893493558, 1021025245, 3467647198, 3722505002, 797665321, 2197175160, 1889384571, 1674398607, 2443626636, 1164749927, 3070701412, 2757221520, 1446797203, 137323447, 4198817972, 3910406976, 461344835, 3484808360, 1037989803, 781091935, 3705997148, 2460548119, 1623424788, 1939049696, 2180517859, 1429367560, 2807687179, 3020495871, 1180866812, 410100952, 3927582683, 4182430767, 186734380, 3756733383, 763408580, 1053836080, 3434856499, 2722870694, 1344288421, 1131464017, 2971354706, 1708204729, 2545590714, 2229949006, 1988219213, 680717673, 3673779818, 3383336350, 1002577565, 4010310262, 493091189, 238226049, 4233660802, 2987750089, 1082061258, 1395524158, 2705686845, 1972364758, 2279892693, 2494862625, 1725896226, 952904198, 3399985413, 3656866545, 731699698, 4283874585, 222117402, 510512622, 3959836397, 3280807620, 837199303, 582374963, 3504198960, 68661723, 4135334616, 3844915500, 390545967, 1230274059, 3141532936, 2825850620, 1510247935, 2395924756, 2091215383, 1878366691, 2644384480, 3553878443, 565732008, 854102364, 3229815391, 340358836, 3861050807, 4117890627, 119113024, 1493875044, 2875275879, 3090270611, 1247431312, 2660249211, 1828433272, 2141937292, 2378227087, 3811616794, 291187481, 34330861, 4032846830, 615137029, 3603020806, 3314634738, 939183345, 1776939221, 2609017814, 2295496738, 2058945313, 2926798794, 1545135305, 1330124605, 3173225534, 4084100981, 17165430, 307568514, 3762199681, 888469610, 3332340585, 3587147933, 665062302, 2042050490, 2346497209, 2559330125, 1793573966, 3190661285, 1279665062, 1595330642, 2910671697], cRt = s1(aRt) }); var pRt, u1, vg, m1, l1, d1, f1, h1, g1, x1, uRt, Bw, ake = s(() => { pRt = () => { let t = new Array(8); for (let r = 0; r < 8; r++) { let o = new Array(512); for (let n = 0; n < 256; n++) { let i = BigInt(n); for (let a = 0; a < 8 * (r + 1); a++)i & 1n ? i = i >> 1n ^ 0x9a6c9329ac4bc9b5n : i = i >> 1n; o[n * 2] = Number(i >> 32n & 0xffffffffn), o[n * 2 + 1] = Number(i & 0xffffffffn) } t[r] = new Uint32Array(o) } return t }, uRt = () => { u1 || (u1 = pRt(), [vg, m1, l1, d1, f1, h1, g1, x1] = u1) }, Bw = class { c1 = 0; c2 = 0; constructor() { uRt(), this.reset() } update(t) { let r = t.length, o = 0, n = this.c1, i = this.c2; for (; o + 8 <= r;) { let a = ((i ^ t[o++]) & 255) << 1, c = ((i >>> 8 ^ t[o++]) & 255) << 1, p = ((i >>> 16 ^ t[o++]) & 255) << 1, u = ((i >>> 24 ^ t[o++]) & 255) << 1, l = ((n ^ t[o++]) & 255) << 1, m = ((n >>> 8 ^ t[o++]) & 255) << 1, f = ((n >>> 16 ^ t[o++]) & 255) << 1, h = ((n >>> 24 ^ t[o++]) & 255) << 1; n = x1[a] ^ g1[c] ^ h1[p] ^ f1[u] ^ d1[l] ^ l1[m] ^ m1[f] ^ vg[h], i = x1[a + 1] ^ g1[c + 1] ^ h1[p + 1] ^ f1[u + 1] ^ d1[l + 1] ^ l1[m + 1] ^ m1[f + 1] ^ vg[h + 1] } for (; o < r;) { let a = ((i ^ t[o]) & 255) << 1; i = (i >>> 8 | (n & 255) << 24) >>> 0, n = n >>> 8 ^ vg[a], i ^= vg[a + 1], o++ } this.c1 = n, this.c2 = i } async digest() { let t = this.c1 ^ 4294967295, r = this.c2 ^ 4294967295; return new Uint8Array([t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255, r >>> 24, r >>> 16 & 255, r >>> 8 & 255, r & 255]) } reset() { this.c1 = 4294967295, this.c2 = 4294967295 } } }); var E1, cke = s(() => { E1 = { CrtCrc64Nvme: null } }); var pke = s(() => { ake(); cke() }); function y1(e) { return e instanceof Uint8Array ? e : typeof e == "string" ? mRt(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) } var mRt, uke = s(() => { t1(); mRt = typeof Buffer < "u" && Buffer.from ? function (e) { return Buffer.from(e, "utf8") } : Ig }); function S1(e) { return typeof e == "string" ? e.length === 0 : e.byteLength === 0 } var mke = s(() => { }); function _1(e) { return new Uint8Array([(e & 4278190080) >> 24, (e & 16711680) >> 16, (e & 65280) >> 8, e & 255]) } var lke = s(() => { }); function C1(e) { if (!Uint32Array.from) { for (var t = new Uint32Array(e.length), r = 0; r < e.length;)t[r] = e[r], r += 1; return t } return Uint32Array.from(e) } var dke = s(() => { }); var R1 = s(() => { uke(); mke(); lke(); dke() }); var A1, fke = s(() => { wg(); R1(); Pg(); A1 = function () { function e() { this.crc32 = new cp } return e.prototype.update = function (t) { S1(t) || this.crc32.update(y1(t)) }, e.prototype.digest = function () { return Ow(this, void 0, void 0, function () { return Dw(this, function (t) { return [2, _1(this.crc32.digest())] }) }) }, e.prototype.reset = function () { this.crc32 = new cp }, e }() }); var cp, lRt, dRt, Pg = s(() => { wg(); R1(); fke(); cp = function () { function e() { this.checksum = 4294967295 } return e.prototype.update = function (t) { var r, o; try { for (var n = kw(t), i = n.next(); !i.done; i = n.next()) { var a = i.value; this.checksum = this.checksum >>> 8 ^ dRt[(this.checksum ^ a) & 255] } } catch (c) { r = { error: c } } finally { try { i && !i.done && (o = n.return) && o.call(n) } finally { if (r) throw r.error } } return this }, e.prototype.digest = function () { return (this.checksum ^ 4294967295) >>> 0 }, e }(), lRt = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117], dRt = C1(lRt) }); var T1, w1 = s(() => { bg(); T1 = e => { let t = Nw(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var hke = s(() => { w1() }); var gke = s(() => { bg() }); var xke = s(() => { w1(); hke(); gke() }); var blo, Eke = s(() => { xke(); blo = typeof Buffer < "u" && Buffer.from ? function (e) { return Buffer.from(e, "utf8") } : T1 }); var yke = s(() => { }); function b1(e) { return new Uint8Array([(e & 4278190080) >> 24, (e & 16711680) >> 16, (e & 65280) >> 8, e & 255]) } var Ske = s(() => { }); var _ke = s(() => { }); var Cke = s(() => { Eke(); yke(); Ske(); _ke() }); import *as v1 from "zlib"; var I1, Rke, Ake = s(() => { Pg(); Cke(); I1 = class { checksum = 0; update(t) { this.checksum = v1.crc32(t, this.checksum) } async digest() { return b1(this.checksum) } reset() { this.checksum = 0 } }, Rke = () => typeof v1.crc32 > "u" ? A1 : I1 }); var Lw, P1 = s(() => { p1(); pke(); Hn(); Ake(); Lw = (e, t) => { switch (e) { case mt.MD5: return t.md5; case mt.CRC32: return Rke(); case mt.CRC32C: return c1; case mt.CRC64NVME: return typeof E1.CrtCrc64Nvme != "function" ? Bw : E1.CrtCrc64Nvme; case mt.SHA1: return t.sha1; case mt.SHA256: return t.sha256; default: throw new Error(`Unsupported checksum algorithm: ${e}`) } } }); var Mw, O1 = s(() => { VU(); Mw = (e, t) => { let r = new e; return r.update(bDe(t || "")), r.digest() } }); var Tke, wke, D1 = s(() => { Ye(); jU(); XU(); Hn(); WDe(); vw(); QDe(); XDe(); ZU(); P1(); O1(); Tke = { name: "flexibleChecksumsMiddleware", step: "build", tags: ["BODY_CHECKSUM"], override: !0 }, wke = (e, t) => (r, o) => async n => { if (!Il.isInstance(n.request) || YDe("x-amz-checksum-", n.request.headers)) return r(n); let { request: i, input: a } = n, { body: c, headers: p } = i, { base64Encoder: u, streamHasher: l } = e, { requestChecksumRequired: m, requestAlgorithmMember: f } = t, h = await e.requestChecksumCalculation(), E = f?.name, S = f?.httpHeader; E && !a[E] && (h === Un.WHEN_SUPPORTED || m) && (a[E] = Rg, S && (p[S] = Rg)); let y = zDe(a, { requestChecksumRequired: m, requestAlgorithmMember: f?.name, requestChecksumCalculation: h }), C = c, b = p; if (y) { switch (y) { case mt.CRC32: ye(o, "FLEXIBLE_CHECKSUMS_REQ_CRC32", "U"); break; case mt.CRC32C: ye(o, "FLEXIBLE_CHECKSUMS_REQ_CRC32C", "V"); break; case mt.CRC64NVME: ye(o, "FLEXIBLE_CHECKSUMS_REQ_CRC64", "W"); break; case mt.SHA1: ye(o, "FLEXIBLE_CHECKSUMS_REQ_SHA1", "X"); break; case mt.SHA256: ye(o, "FLEXIBLE_CHECKSUMS_REQ_SHA256", "Y"); break }let L = Pl(y), N = Lw(y, e); if (Pw(c)) { let { getAwsChunkedEncodingStream: j, bodyLengthChecker: re } = e; C = j(typeof e.requestStreamBufferSize == "number" && e.requestStreamBufferSize >= 8 * 1024 ? FDe(c, e.requestStreamBufferSize, o.logger) : c, { base64Encoder: u, bodyLengthChecker: re, checksumLocationName: L, checksumAlgorithmFn: N, streamHasher: l }), b = { ...p, "content-encoding": p["content-encoding"] ? `${p["content-encoding"]},aws-chunked` : "aws-chunked", "transfer-encoding": "chunked", "x-amz-decoded-content-length": p["content-length"], "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER", "x-amz-trailer": L }, delete b["content-length"] } else if (!KDe(L, p)) { let j = await Mw(N, c); b = { ...p, [L]: u(j) } } } try { return await r({ ...n, request: { ...i, headers: b, body: C } }) } catch (L) { if (L instanceof Error && L.name === "InvalidChunkSizeError") try { L.message.endsWith(".") || (L.message += "."), L.message += " Set [requestStreamBufferSize=number e.g. 65_536] in client constructor to instruct AWS SDK to buffer your input stream." } catch { } throw L } } }); var bke, Ike, vke = s(() => { Ye(); Hn(); bke = { name: "flexibleChecksumsInputMiddleware", toMiddleware: "serializerMiddleware", relation: "before", tags: ["BODY_CHECKSUM"], override: !0 }, Ike = (e, t) => (r, o) => async n => { let i = n.input, { requestValidationModeMember: a } = t, c = await e.requestChecksumCalculation(), p = await e.responseChecksumValidation(); switch (c) { case Un.WHEN_REQUIRED: ye(o, "FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED", "a"); break; case Un.WHEN_SUPPORTED: ye(o, "FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED", "Z"); break }switch (p) { case sp.WHEN_REQUIRED: ye(o, "FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED", "c"); break; case sp.WHEN_SUPPORTED: ye(o, "FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED", "b"); break }return a && !i[a] && p === sp.WHEN_SUPPORTED && (i[a] = "ENABLED"), r(n) } }); var $w, k1 = s(() => { JU(); $w = (e = []) => { let t = []; for (let r of VDe) !e.includes(r) || !Tg.includes(r) || t.push(r); return t } }); var Pke, Oke = s(() => { Pke = e => { let t = e.lastIndexOf("-"); if (t !== -1) { let r = e.slice(t + 1); if (!r.startsWith("0")) { let o = parseInt(r, 10); if (!isNaN(o) && o >= 1 && o <= 1e4) return !0 } } return !1 } }); var Dke, kke = s(() => { O1(); Dke = async (e, { checksumAlgorithmFn: t, base64Encoder: r }) => r(await Mw(t, e)) }); var Nke, Bke = s(() => { XU(); Hn(); kke(); k1(); vw(); ZU(); P1(); Nke = async (e, { config: t, responseAlgorithms: r, logger: o }) => { let n = $w(r), { body: i, headers: a } = e; for (let c of n) { let p = Pl(c), u = a[p]; if (u) { let l; try { l = Lw(c, t) } catch (h) { if (c === mt.CRC64NVME) { o?.warn(`Skipping ${mt.CRC64NVME} checksum validation: ${h.message}`); continue } throw h } let { base64Encoder: m } = t; if (Pw(i)) { e.body = BDe({ expectedChecksum: u, checksumSourceLocation: p, checksum: new l, source: i, base64Encoder: m }); return } let f = await Dke(i, { checksumAlgorithmFn: l, base64Encoder: m }); if (f === u) break; throw new Error(`Checksum mismatch: expected "${f}" but received "${u}" in response header "${p}".`) } } } }); var Lke, Mke, $ke = s(() => { jU(); k1(); vw(); Oke(); Bke(); Lke = { name: "flexibleChecksumsResponseMiddleware", toMiddleware: "deserializerMiddleware", relation: "after", tags: ["BODY_CHECKSUM"], override: !0 }, Mke = (e, t) => (r, o) => async n => { if (!Il.isInstance(n.request)) return r(n); let i = n.input, a = await r(n), c = a.response, { requestValidationModeMember: p, responseAlgorithms: u } = t; if (p && i[p] === "ENABLED") { let { clientName: l, commandName: m } = o; if (l === "S3Client" && m === "GetObjectCommand" && $w(u).every(h => { let E = Pl(h), S = c.headers[E]; return !S || Pke(S) })) return a; await Nke(c, { config: e, responseAlgorithms: u, logger: o.logger }) } return a } }); var Ee, Fke = s(() => { vke(); D1(); $ke(); Ee = (e, t) => ({ applyToStack: r => { r.add(wke(e, t), Tke), r.addRelativeTo(Ike(e, t), bke), r.addRelativeTo(Mke(e, t), Lke) } }) }); var Uke, Hke = s(() => { gt(); Hn(); Uke = e => { let { requestChecksumCalculation: t, responseChecksumValidation: r, requestStreamBufferSize: o } = e; return Object.assign(e, { requestChecksumCalculation: le(t ?? Rw), responseChecksumValidation: le(r ?? Aw), requestStreamBufferSize: Number(o ?? 0) }) } }); var lt = s(() => { pDe(); mDe(); Hn(); D1(); Fke(); Hke() }); var Fw, Uw, Gke = s(() => { Fw = e => ({ setHttpHandler(t) { e.httpHandler = t }, httpHandler() { return e.httpHandler }, updateHttpClientConfig(t, r) { e.httpHandler?.updateHttpClientConfig(t, r) }, httpHandlerConfigs() { return e.httpHandler.httpHandlerConfigs() } }), Uw = e => ({ httpHandler: e.httpHandler() }) }); var jke = s(() => { Gke() }); var qke = s(() => { }); var Vke, zke = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Vke || (Vke = {})) }); var Wke, Kke = s(() => { (function (e) { e.HEADER = "header", e.QUERY = "query" })(Wke || (Wke = {})) }); var Qke = s(() => { }); var Yke = s(() => { }); var Xke = s(() => { }); var Jke = s(() => { }); var Zke = s(() => { zke(); Kke(); Qke(); Yke(); Xke(); Jke() }); var eNe = s(() => { }); var tNe = s(() => { }); var rNe = s(() => { }); var oNe = s(() => { }); var nNe = s(() => { }); var sNe = s(() => { }); var iNe = s(() => { }); var aNe = s(() => { nNe(); sNe(); iNe() }); var cNe = s(() => { }); var pNe = s(() => { }); var uNe, mNe = s(() => { (function (e) { e.HTTP = "http", e.HTTPS = "https" })(uNe || (uNe = {})) }); var lNe = s(() => { }); var dNe = s(() => { }); var fNe = s(() => { }); var hNe = s(() => { }); var gNe = s(() => { }); var xNe = s(() => { lNe(); dNe(); fNe(); hNe(); gNe() }); var ENe = s(() => { }); var Ol, yNe = s(() => { (function (e) { e.MD5 = "md5", e.CRC32 = "crc32", e.CRC32C = "crc32c", e.SHA1 = "sha1", e.SHA256 = "sha256" })(Ol || (Ol = {})) }); var SNe = s(() => { }); var _Ne = s(() => { }); var CNe = s(() => { SNe(); _Ne(); yNe() }); var RNe = s(() => { }); var ANe, TNe = s(() => { (function (e) { e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER" })(ANe || (ANe = {})) }); var wNe = s(() => { }); var bNe = s(() => { }); var INe = s(() => { }); var vNe = s(() => { }); var PNe = s(() => { }); var ONe = s(() => { bNe(); INe(); vNe(); PNe() }); var DNe = s(() => { }); var kNe, NNe = s(() => { kNe = "__smithy_context" }); var BNe = s(() => { }); var Ui, LNe = s(() => { (function (e) { e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services" })(Ui || (Ui = {})) }); var MNe = s(() => { }); var $Ne = s(() => { }); var FNe = s(() => { }); var UNe = s(() => { }); var HNe = s(() => { }); var GNe = s(() => { }); var jNe = s(() => { }); var qNe = s(() => { }); var VNe = s(() => { }); var zNe = s(() => { }); var WNe = s(() => { }); var KNe = s(() => { }); var QNe = s(() => { }); var YNe = s(() => { }); var XNe, JNe = s(() => { (function (e) { e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0" })(XNe || (XNe = {})) }); var ZNe = s(() => { }); var eBe = s(() => { }); var tBe = s(() => { }); var rBe = s(() => { }); var oBe = s(() => { }); var nBe = s(() => { }); var sBe = s(() => { }); var Dl = s(() => { qke(); Zke(); eNe(); tNe(); rNe(); oNe(); aNe(); cNe(); pNe(); mNe(); xNe(); ENe(); CNe(); RNe(); TNe(); wNe(); ONe(); DNe(); NNe(); BNe(); LNe(); MNe(); $Ne(); FNe(); UNe(); HNe(); GNe(); jNe(); qNe(); VNe(); zNe(); WNe(); KNe(); QNe(); YNe(); JNe(); ZNe(); eBe(); tBe(); rBe(); oBe(); nBe(); sBe() }); var iBe = s(() => { }); var aBe = s(() => { }); var cBe = s(() => { }); function fRt(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var Gn, pBe = s(() => { Gn = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = fRt(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var kl, uBe = s(() => { kl = class { statusCode; reason; headers; body; constructor(t) { this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body } static isInstance(t) { if (!t) return !1; let r = t; return typeof r.statusCode == "number" && typeof r.headers == "object" } } }); var mBe = s(() => { }); var lBe = s(() => { }); var Hi = s(() => { jke(); iBe(); aBe(); cBe(); pBe(); uBe(); mBe(); lBe() }); var hRt, gRt, Hw, N1 = s(() => { Hi(); hRt = e => t => async r => { if (!Gn.isInstance(r.request)) return t(r); let { request: o } = r, { handlerProtocol: n = "" } = e.requestHandler.metadata || {}; if (n.indexOf("h2") >= 0 && !o.headers[":authority"]) delete o.headers.host, o.headers[":authority"] = o.hostname + (o.port ? ":" + o.port : ""); else if (!o.headers.host) { let i = o.hostname; o.port != null && (i += `:${o.port}`), o.headers.host = i } return t(r) }, gRt = { name: "hostHeaderMiddleware", step: "build", priority: "low", tags: ["HOST"], override: !0 }, Hw = e => ({ applyToStack: t => { t.add(hRt(e), gRt) } }) }); var xRt, ERt, Gw, dBe = s(() => { xRt = () => (e, t) => async r => { try { let o = await e(r), { clientName: n, commandName: i, logger: a, dynamoDbDocumentClientOptions: c = {} } = t, { overrideInputFilterSensitiveLog: p, overrideOutputFilterSensitiveLog: u } = c, l = p ?? t.inputFilterSensitiveLog, m = u ?? t.outputFilterSensitiveLog, { $metadata: f, ...h } = o.output; return a?.info?.({ clientName: n, commandName: i, input: l(r.input), output: m(h), metadata: f }), o } catch (o) { let { clientName: n, commandName: i, logger: a, dynamoDbDocumentClientOptions: c = {} } = t, { overrideInputFilterSensitiveLog: p } = c, u = p ?? t.inputFilterSensitiveLog; throw a?.error?.({ clientName: n, commandName: i, input: u(r.input), error: o, metadata: o.$metadata }), o } }, ERt = { name: "loggerMiddleware", tags: ["LOGGER"], step: "initialize", override: !0 }, Gw = e => ({ applyToStack: t => { t.add(xRt(), ERt) } }) }); var B1 = s(() => { dBe() }); var fBe, hBe = s(() => { fBe = { step: "build", tags: ["RECURSION_DETECTION"], name: "recursionDetectionMiddleware", override: !0, priority: "low" } }); var L1, yRt, SRt, gBe, M1 = s(() => { xf(); Hi(); L1 = "X-Amzn-Trace-Id", yRt = "AWS_LAMBDA_FUNCTION_NAME", SRt = "_X_AMZN_TRACE_ID", gBe = () => e => async t => { let { request: r } = t; if (!Gn.isInstance(r)) return e(t); let o = Object.keys(r.headers ?? {}).find(l => l.toLowerCase() === L1.toLowerCase()) ?? L1; if (r.headers.hasOwnProperty(o)) return e(t); let n = process.env[yRt], i = process.env[SRt], p = (await Cs.getInstanceAsync())?.getXRayTraceId() ?? i, u = l => typeof l == "string" && l.length > 0; return u(n) && u(p) && (r.headers[L1] = p), e({ ...t, request: r }) } }); var jw, xBe = s(() => { hBe(); M1(); jw = e => ({ applyToStack: t => { t.add(gBe(), fBe) } }) }); var $1 = s(() => { xBe(); M1() }); var EBe = s(() => { }); var yBe = s(() => { EBe() }); var SBe = s(() => { }); var _Be = s(() => { }); var CBe = s(() => { }); function _Rt(e) { return Object.keys(e).reduce((t, r) => { let o = e[r]; return { ...t, [r]: Array.isArray(o) ? [...o] : o } }, {}) } var za, RBe = s(() => { za = class e { method; protocol; hostname; port; path; query; headers; username; password; fragment; body; constructor(t) { this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment } static clone(t) { let r = new e({ ...t, headers: { ...t.headers } }); return r.query && (r.query = _Rt(r.query)), r } static isInstance(t) { if (!t) return !1; let r = t; return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object" } clone() { return e.clone(this) } } }); var Nl, ABe = s(() => { Nl = class { statusCode; reason; headers; body; constructor(t) { this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body } static isInstance(t) { if (!t) return !1; let r = t; return typeof r.statusCode == "number" && typeof r.headers == "object" } } }); var TBe = s(() => { }); var wBe = s(() => { }); var Bl = s(() => { yBe(); SBe(); _Be(); CBe(); RBe(); ABe(); TBe(); wBe() }); var bBe = s(() => { }); var IBe = s(() => { }); var vBe = s(() => { }); var PBe = s(() => { }); var OBe = s(() => { }); var DBe = s(() => { }); var kBe = s(() => { }); var NBe = s(() => { }); var BBe = s(() => { }); var LBe = s(() => { }); var MBe = s(() => { }); var $Be = s(() => { MBe() }); var FBe = s(() => { }); var UBe = s(() => { }); var HBe = s(() => { }); var qw, GBe = s(() => { qw = class { trace() { } debug() { } info() { } warn() { } error() { } } }); var jBe = s(() => { }); var qBe = s(() => { }); var VBe = s(() => { }); var zBe = s(() => { }); var F1 = s(() => { bBe(); IBe(); vBe(); PBe(); OBe(); kBe(); NBe(); BBe(); DBe(); LBe(); $Be(); FBe(); UBe(); HBe(); GBe(); jBe(); qBe(); VBe(); zBe(); Pr() }); function ARt() { return (e, t) => async r => { let { request: o } = r; if (za.isInstance(o) && !(CRt in o.headers) && !(RRt in o.headers)) { let n = "Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage."; typeof t?.logger?.warn == "function" && !(t.logger instanceof qw) ? t.logger.warn(n) : console.warn(n) } return e({ ...r }) } } var CRt, RRt, TRt, WBe, KBe = s(() => { Bl(); F1(); CRt = "content-length", RRt = "x-amz-decoded-content-length"; TRt = { step: "finalizeRequest", tags: ["CHECK_CONTENT_LENGTH_HEADER"], name: "getCheckContentLengthHeaderPlugin", override: !0 }, WBe = e => ({ applyToStack: t => { t.add(ARt(), TRt) } }) }); var QBe, YBe, U1 = s(() => { QBe = e => (t, r) => async o => { let n = await e.region(), i = e.region, a = () => { }; r.__s3RegionRedirect && (Object.defineProperty(e, "region", { writable: !1, value: async () => r.__s3RegionRedirect }), a = () => Object.defineProperty(e, "region", { writable: !0, value: i })); try { let c = await t(o); if (r.__s3RegionRedirect) { a(); let p = await e.region(); if (n !== p) throw new Error("Region was not restored following S3 region redirect.") } return c } catch (c) { throw a(), c } }, YBe = { tags: ["REGION_REDIRECT", "S3"], name: "regionRedirectEndpointMiddleware", override: !0, relation: "before", toMiddleware: "endpointV2Middleware" } }); function wRt(e) { return (t, r) => async o => { try { return await t(o) } catch (n) { if (e.followRegionRedirects) { let i = n?.$metadata?.httpStatusCode, a = r.commandName === "HeadBucketCommand", c = n?.$response?.headers?.["x-amz-bucket-region"]; if (c && (i === 301 || i === 400 && (n?.name === "IllegalLocationConstraintException" || a))) { try { let p = c; r.logger?.debug(`Redirecting from ${await e.region()} to ${p}`), r.__s3RegionRedirect = p } catch (p) { throw new Error("Region redirect failed: " + p) } return t(o) } } throw n } } } var bRt, XBe, JBe = s(() => { U1(); bRt = { step: "initialize", tags: ["REGION_REDIRECT", "S3"], name: "regionRedirectMiddleware", override: !0 }, XBe = e => ({ applyToStack: t => { t.add(wRt(e), bRt), t.addRelativeTo(QBe(e), YBe) } }) }); var IRt, vRt, Vw, ZBe = s(() => { Bl(); F1(); IRt = e => (t, r) => async o => { let n = await t(o), { response: i } = n; if (Nl.isInstance(i) && i.headers.expires) { i.headers.expiresstring = i.headers.expires; try { hE(i.headers.expires) } catch (a) { r.logger?.warn(`AWS SDK Warning for ${r.clientName}::${r.commandName} response parsing (${i.headers.expires}): ${a}`), delete i.headers.expires } } return n }, vRt = { tags: ["S3"], name: "s3ExpiresMiddleware", override: !0, relation: "after", toMiddleware: "deserializerMiddleware" }, Vw = e => ({ applyToStack: t => { t.addRelativeTo(IRt(e), vRt) } }) }); var zw, eLe = s(() => { zw = class e { data; lastPurgeTime = Date.now(); static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4; constructor(t = {}) { this.data = t } get(t) { let r = this.data[t]; if (r) return r } set(t, r) { return this.data[t] = r, r } delete(t) { delete this.data[t] } async purgeExpired() { let t = Date.now(); if (!(this.lastPurgeTime + e.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > t)) for (let r in this.data) { let o = this.data[r]; if (!o.isRefreshing) { let n = await o.identity; n.expiration && n.expiration.getTime() < t && delete this.data[r] } } } } }); var Ll, tLe = s(() => { Ll = class { _identity; isRefreshing; accessed; constructor(t, r = !1, o = Date.now()) { this._identity = t, this.isRefreshing = r, this.accessed = o } get identity() { return this.accessed = Date.now(), this._identity } } }); var Og, rLe = s(() => {
  eLe(); tLe(); Og = class e {
    createSessionFn; cache; static REFRESH_WINDOW_MS = 6e4; constructor(t, r = new zw) { this.createSessionFn = t, this.cache = r } async getS3ExpressIdentity(t, r) { let o = r.Bucket, { cache: n } = this, i = n.get(o); return i ? i.identity.then(a => (a.expiration?.getTime() ?? 0) < Date.now() ? n.set(o, new Ll(this.getIdentity(o))).identity : ((a.expiration?.getTime() ?? 0) < Date.now() + e.REFRESH_WINDOW_MS && !i.isRefreshing && (i.isRefreshing = !0, this.getIdentity(o).then(u => { n.set(o, new Ll(Promise.resolve(u))) })), a)) : n.set(o, new Ll(this.getIdentity(o))).identity } async getIdentity(t) {
      await this.cache.purgeExpired().catch(n => {
        console.warn(`Error while clearing expired entries in S3ExpressIdentityCache: 
`+ n)
      }); let r = await this.createSessionFn(t); if (!r.Credentials?.AccessKeyId || !r.Credentials?.SecretAccessKey) throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey."); return { accessKeyId: r.Credentials.AccessKeyId, secretAccessKey: r.Credentials.SecretAccessKey, sessionToken: r.Credentials.SessionToken, expiration: r.Credentials.Expiration ? new Date(r.Credentials.Expiration) : void 0 }
    }
  }
}); var oLe, nLe, sLe, Ww, Dg, PRt, ORt, H1, Kw = s(() => { os(); oLe = "Directory", nLe = "S3Express", sLe = "sigv4-s3express", Ww = "X-Amz-S3session-Token", Dg = Ww.toLowerCase(), PRt = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH", ORt = "s3_disable_express_session_auth", H1 = { environmentVariableSelector: e => xt(e, PRt, ct.ENV), configFileSelector: e => xt(e, ORt, ct.CONFIG), default: !1 } }); function iLe(e) { return { accessKeyId: e.accessKeyId, secretAccessKey: e.secretAccessKey, expiration: e.expiration } } function aLe(e, t) { let r = setTimeout(() => { throw new Error("SignatureV4S3Express credential override was created but not called.") }, 10), o = e.credentialProvider, n = () => (clearTimeout(r), e.credentialProvider = o, Promise.resolve(t)); e.credentialProvider = n } var kg, cLe = s(() => { LE(); Kw(); kg = class extends xc { async signWithCredentials(t, r, o) { let n = iLe(r); t.headers[Dg] = r.sessionToken; let i = this; return aLe(i, n), i.signRequest(t, o ?? {}) } async presignWithCredentials(t, r, o) { let n = iLe(r); return delete t.headers[Dg], t.headers[Ww] = r.sessionToken, t.query = t.query ?? {}, t.query[Ww] = r.sessionToken, aLe(this, n), this.presign(t, o) } } }); var pLe, uLe, G1, mLe = s(() => { Ye(); Bl(); Kw(); pLe = e => (t, r) => async o => { if (r.endpointV2) { let n = r.endpointV2, i = n.properties?.authSchemes?.[0]?.name === sLe; if ((n.properties?.backend === nLe || n.properties?.bucketType === oLe) && (ye(r, "S3_EXPRESS_BUCKET", "J"), r.isS3ExpressBucket = !0), i) { let c = o.input.Bucket; if (c) { let p = await e.s3ExpressIdentityProvider.getS3ExpressIdentity(await e.credentials(), { Bucket: c }); r.s3ExpressIdentity = p, za.isInstance(o.request) && p.sessionToken && (o.request.headers[Dg] = p.sessionToken) } } } return t(o) }, uLe = { name: "s3ExpressMiddleware", step: "build", tags: ["S3", "S3_EXPRESS"], override: !0 }, G1 = e => ({ applyToStack: t => { t.add(pLe(e), uLe) } }) }); var lLe, dLe = s(() => { lLe = async (e, t, r, o) => { let n = await o.signWithCredentials(r, e, {}); if (n.headers["X-Amz-Security-Token"] || n.headers["x-amz-security-token"]) throw new Error("X-Amz-Security-Token must not be set for s3-express requests."); return n } }); var DRt, kRt, fLe, j1, hLe = s(() => { Ie(); Bl(); gt(); dLe(); DRt = e => t => { throw t }, kRt = (e, t) => { }, fLe = e => (t, r) => async o => { if (!za.isInstance(o.request)) return t(o); let i = je(r).selectedHttpAuthScheme; if (!i) throw new Error("No HttpAuthScheme was selected: unable to sign request"); let { httpAuthOption: { signingProperties: a = {} }, identity: c, signer: p } = i, u; r.s3ExpressIdentity ? u = await lLe(r.s3ExpressIdentity, a, o.request, await e.signer()) : u = await p.sign(o.request, c, a); let l = await t({ ...o, request: u }).catch((p.errorHandler || DRt)(a)); return (p.successHandler || kRt)(l.response, a), l }, j1 = e => ({ applyToStack: t => { t.addRelativeTo(fLe(e), xO) } }) }); var q1 = s(() => { rLe(); cLe(); Kw(); mLe(); hLe() }); var gLe, xLe = s(() => { q1(); gLe = (e, { session: t }) => { let [r, o] = t, { forcePathStyle: n, useAccelerateEndpoint: i, disableMultiregionAccessPoints: a, followRegionRedirects: c, s3ExpressIdentityProvider: p, bucketEndpoint: u, expectContinueHeader: l } = e; return Object.assign(e, { forcePathStyle: n ?? !1, useAccelerateEndpoint: i ?? !1, disableMultiregionAccessPoints: a ?? !1, followRegionRedirects: c ?? !1, s3ExpressIdentityProvider: p ?? new Og(async m => r().send(new o({ Bucket: m }))), bucketEndpoint: u ?? !1, expectContinueHeader: l ?? 2097152 }) } }); var ELe = s(() => { }); var yLe = s(() => { }); var Qw, SLe, Yw = s(() => { Qw = e => typeof ReadableStream == "function" && (e?.constructor?.name === ReadableStream.name || e instanceof ReadableStream), SLe = e => typeof Blob == "function" && (e?.constructor?.name === Blob.name || e instanceof Blob) }); var _Le = s(() => { }); var CLe = s(() => { }); var RLe = s(() => { }); async function ALe(e, t) { let r = 0, o = [], n = e.getReader(), i = !1; for (; !i;) { let { done: p, value: u } = await n.read(); if (u && (o.push(u), r += u?.byteLength ?? 0), r >= t) break; i = p } n.releaseLock(); let a = new Uint8Array(Math.min(t, r)), c = 0; for (let p of o) { if (p.byteLength > a.byteLength - c) { a.set(p.subarray(0, a.byteLength - c), c); break } else a.set(p, c); c += p.length } return a } var TLe = s(() => { }); import { Writable as NRt } from "stream"; var wLe, V1, bLe = s(() => { TLe(); Yw(); wLe = (e, t) => Qw(e) ? ALe(e, t) : new Promise((r, o) => { let n = new V1; n.limit = t, e.pipe(n), e.on("error", i => { n.end(), o(i) }), n.on("error", o), n.on("finish", function () { let i = new Uint8Array(Buffer.concat(this.buffers)); r(i) }) }), V1 = class extends NRt { buffers = []; limit = 1 / 0; bytesBuffered = 0; _write(t, r, o) { if (this.buffers.push(t), this.bytesBuffered += t.byteLength ?? 0, this.bytesBuffered >= this.limit) { let n = this.bytesBuffered - this.limit, i = this.buffers[this.buffers.length - 1]; this.buffers[this.buffers.length - 1] = i.subarray(0, i.byteLength - n), this.emit("finish") } o() } } }); var ILe = s(() => { }); async function vLe(e) { return typeof e.stream == "function" && (e = e.stream()), e.tee() } var PLe = s(() => { }); import { PassThrough as OLe } from "stream"; async function DLe(e) { if (Qw(e) || SLe(e)) return vLe(e); let t = new OLe, r = new OLe; return e.pipe(t), e.pipe(r), [t, r] } var kLe = s(() => { PLe(); Yw() }); var NLe = s(() => { ELe(); yLe(); _Le(); CLe(); RLe(); bLe(); ILe(); kLe(); Yw() }); var BRt, LRt, MRt, $Rt, FRt, M, BLe = s(() => { Bl(); NLe(); BRt = { CopyObjectCommand: !0, UploadPartCopyCommand: !0, CompleteMultipartUploadCommand: !0 }, LRt = 3e3, MRt = e => (t, r) => async o => { let n = await t(o), { response: i } = n; if (!Nl.isInstance(i)) return n; let { statusCode: a, body: c } = i; if (a < 200 || a >= 300 || !(typeof c?.stream == "function" || typeof c?.pipe == "function" || typeof c?.tee == "function")) return n; let u = c, l = c; c && typeof c == "object" && !(c instanceof Uint8Array) && ([u, l] = await DLe(c)), i.body = l; let m = await $Rt(u, { streamCollector: async h => wLe(h, LRt) }); typeof u?.destroy == "function" && u.destroy(); let f = e.utf8Encoder(m.subarray(m.length - 16)); if (m.length === 0 && BRt[r.commandName]) { let h = new Error("S3 aborted request"); throw h.name = "InternalError", h } return f && f.endsWith("</Error>") && (i.statusCode = 400), n }, $Rt = (e = new Uint8Array, t) => e instanceof Uint8Array ? Promise.resolve(e) : t.streamCollector(e) || Promise.resolve(new Uint8Array), FRt = { relation: "after", toMiddleware: "deserializerMiddleware", tags: ["THROW_200_EXCEPTIONS", "S3"], name: "throw200ExceptionsMiddleware", override: !0 }, M = e => ({ applyToStack: t => { t.addRelativeTo(MRt(e), FRt) } }) }); var LLe, MLe = s(() => { LLe = e => typeof e == "string" && e.indexOf("arn:") === 0 && e.split(":").length >= 6 }); function $Le(e) { return (t, r) => async o => { if (e.bucketEndpoint) { let n = r.endpointV2; if (n) { let i = o.input.Bucket; if (typeof i == "string") try { let a = new URL(i); r.endpointV2 = { ...n, url: a } } catch (a) { let c = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${i} could not be parsed as URL.`; throw r.logger?.constructor?.name === "NoOpLogger" ? console.warn(c) : r.logger?.warn?.(c), a } } } return t(o) } } var FLe, ULe = s(() => { FLe = { name: "bucketEndpointMiddleware", override: !0, relation: "after", toMiddleware: "endpointV2Middleware" } }); function URt({ bucketEndpoint: e }) { return t => async r => { let { input: { Bucket: o } } = r; if (!e && typeof o == "string" && !LLe(o) && o.indexOf("/") >= 0) { let n = new Error(`Bucket name shouldn't contain '/', received '${o}'`); throw n.name = "InvalidBucketName", n } return t({ ...r }) } } var HRt, HLe, GLe = s(() => { MLe(); ULe(); HRt = { step: "initialize", tags: ["VALIDATE_BUCKET_NAME"], name: "validateBucketNameMiddleware", override: !0 }, HLe = e => ({ applyToStack: t => { t.add(URt(e), HRt), t.addRelativeTo($Le(e), FLe) } }) }); var pe = s(() => { KBe(); U1(); JBe(); ZBe(); q1(); xLe(); BLe(); GLe() }); function GRt(e) { return e === void 0 ? !0 : typeof e == "string" && e.length <= 50 } function Xw(e) { let t = yo(e.userAgentAppId ?? z1), { customUserAgent: r } = e; return Object.assign(e, { customUserAgent: typeof r == "string" ? [[r]] : r, userAgentAppId: async () => { let o = await t(); if (!GRt(o)) { let n = e.logger?.constructor?.name === "NoOpLogger" || !e.logger ? console : e.logger; typeof o != "string" ? n?.warn("userAgentAppId must be a string or undefined.") : o.length > 50 && n?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.") } return o } }) } var z1, jLe = s(() => { Ie(); z1 = void 0 }); var W1 = s(() => { Ft() }); var K1, qLe = s(() => { Ft(); W1(); K1 = (e, t = !1) => { if (t) { for (let r of e.split(".")) if (!K1(r)) return !1; return !0 } return !(!Or(e) || e.length < 3 || e.length > 63 || e !== e.toLowerCase() || No(e)) } }); var VLe, jRt, zLe, WLe = s(() => { VLe = ":", jRt = "/", zLe = e => { let t = e.split(VLe); if (t.length < 6) return null; let [r, o, n, i, a, ...c] = t; if (r !== "arn" || o === "" || n === "" || c.join(VLe) === "") return null; let p = c.map(u => u.split(jRt)).flat(); return { partition: o, service: n, region: i, accountId: a, resourceId: p } } }); var QLe, KLe = s(() => { QLe = { partitions: [{ id: "aws", outputs: { dnsSuffix: "amazonaws.com", dualStackDnsSuffix: "api.aws", implicitGlobalRegion: "us-east-1", name: "aws", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$", regions: { "af-south-1": { description: "Africa (Cape Town)" }, "ap-east-1": { description: "Asia Pacific (Hong Kong)" }, "ap-east-2": { description: "Asia Pacific (Taipei)" }, "ap-northeast-1": { description: "Asia Pacific (Tokyo)" }, "ap-northeast-2": { description: "Asia Pacific (Seoul)" }, "ap-northeast-3": { description: "Asia Pacific (Osaka)" }, "ap-south-1": { description: "Asia Pacific (Mumbai)" }, "ap-south-2": { description: "Asia Pacific (Hyderabad)" }, "ap-southeast-1": { description: "Asia Pacific (Singapore)" }, "ap-southeast-2": { description: "Asia Pacific (Sydney)" }, "ap-southeast-3": { description: "Asia Pacific (Jakarta)" }, "ap-southeast-4": { description: "Asia Pacific (Melbourne)" }, "ap-southeast-5": { description: "Asia Pacific (Malaysia)" }, "ap-southeast-6": { description: "Asia Pacific (New Zealand)" }, "ap-southeast-7": { description: "Asia Pacific (Thailand)" }, "aws-global": { description: "aws global region" }, "ca-central-1": { description: "Canada (Central)" }, "ca-west-1": { description: "Canada West (Calgary)" }, "eu-central-1": { description: "Europe (Frankfurt)" }, "eu-central-2": { description: "Europe (Zurich)" }, "eu-north-1": { description: "Europe (Stockholm)" }, "eu-south-1": { description: "Europe (Milan)" }, "eu-south-2": { description: "Europe (Spain)" }, "eu-west-1": { description: "Europe (Ireland)" }, "eu-west-2": { description: "Europe (London)" }, "eu-west-3": { description: "Europe (Paris)" }, "il-central-1": { description: "Israel (Tel Aviv)" }, "me-central-1": { description: "Middle East (UAE)" }, "me-south-1": { description: "Middle East (Bahrain)" }, "mx-central-1": { description: "Mexico (Central)" }, "sa-east-1": { description: "South America (Sao Paulo)" }, "us-east-1": { description: "US East (N. Virginia)" }, "us-east-2": { description: "US East (Ohio)" }, "us-west-1": { description: "US West (N. California)" }, "us-west-2": { description: "US West (Oregon)" } } }, { id: "aws-cn", outputs: { dnsSuffix: "amazonaws.com.cn", dualStackDnsSuffix: "api.amazonwebservices.com.cn", implicitGlobalRegion: "cn-northwest-1", name: "aws-cn", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^cn\\-\\w+\\-\\d+$", regions: { "aws-cn-global": { description: "aws-cn global region" }, "cn-north-1": { description: "China (Beijing)" }, "cn-northwest-1": { description: "China (Ningxia)" } } }, { id: "aws-eusc", outputs: { dnsSuffix: "amazonaws.eu", dualStackDnsSuffix: "api.amazonwebservices.eu", implicitGlobalRegion: "eusc-de-east-1", name: "aws-eusc", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$", regions: { "eusc-de-east-1": { description: "EU (Germany)" } } }, { id: "aws-iso", outputs: { dnsSuffix: "c2s.ic.gov", dualStackDnsSuffix: "api.aws.ic.gov", implicitGlobalRegion: "us-iso-east-1", name: "aws-iso", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-iso\\-\\w+\\-\\d+$", regions: { "aws-iso-global": { description: "aws-iso global region" }, "us-iso-east-1": { description: "US ISO East" }, "us-iso-west-1": { description: "US ISO WEST" } } }, { id: "aws-iso-b", outputs: { dnsSuffix: "sc2s.sgov.gov", dualStackDnsSuffix: "api.aws.scloud", implicitGlobalRegion: "us-isob-east-1", name: "aws-iso-b", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-isob\\-\\w+\\-\\d+$", regions: { "aws-iso-b-global": { description: "aws-iso-b global region" }, "us-isob-east-1": { description: "US ISOB East (Ohio)" }, "us-isob-west-1": { description: "US ISOB West" } } }, { id: "aws-iso-e", outputs: { dnsSuffix: "cloud.adc-e.uk", dualStackDnsSuffix: "api.cloud-aws.adc-e.uk", implicitGlobalRegion: "eu-isoe-west-1", name: "aws-iso-e", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$", regions: { "aws-iso-e-global": { description: "aws-iso-e global region" }, "eu-isoe-west-1": { description: "EU ISOE West" } } }, { id: "aws-iso-f", outputs: { dnsSuffix: "csp.hci.ic.gov", dualStackDnsSuffix: "api.aws.hci.ic.gov", implicitGlobalRegion: "us-isof-south-1", name: "aws-iso-f", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-isof\\-\\w+\\-\\d+$", regions: { "aws-iso-f-global": { description: "aws-iso-f global region" }, "us-isof-east-1": { description: "US ISOF EAST" }, "us-isof-south-1": { description: "US ISOF SOUTH" } } }, { id: "aws-us-gov", outputs: { dnsSuffix: "amazonaws.com", dualStackDnsSuffix: "api.aws", implicitGlobalRegion: "us-gov-west-1", name: "aws-us-gov", supportsDualStack: !0, supportsFIPS: !0 }, regionRegex: "^us\\-gov\\-\\w+\\-\\d+$", regions: { "aws-us-gov-global": { description: "aws-us-gov global region" }, "us-gov-east-1": { description: "AWS GovCloud (US-East)" }, "us-gov-west-1": { description: "AWS GovCloud (US-West)" } } }], version: "1.1" } }); var VRt, zRt, YLe, XLe, Q1 = s(() => { KLe(); VRt = QLe, zRt = "", YLe = e => { let { partitions: t } = VRt; for (let o of t) { let { regions: n, outputs: i } = o; for (let [a, c] of Object.entries(n)) if (a === e) return { ...i, ...c } } for (let o of t) { let { regionRegex: n, outputs: i } = o; if (new RegExp(n).test(e)) return { ...i } } let r = t.find(o => o.id === "aws"); if (!r) throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."); return { ...r.outputs } }, XLe = () => zRt }); var Ng, JLe = s(() => { Ft(); qLe(); WLe(); Q1(); Ng = { isVirtualHostableS3Bucket: K1, parseArn: zLe, partition: YLe }; Rt.aws = Ng }); function ZLe(e) { let t = {}; if (e = e.replace(/^\?/, ""), e) for (let r of e.split("&")) { let [o, n = null] = r.split("="); o = decodeURIComponent(o), n && (n = decodeURIComponent(n)), o in t ? Array.isArray(t[o]) ? t[o].push(n) : t[o] = [t[o], n] : t[o] = n } return t } var eMe = s(() => { }); var Js, Bg = s(() => { eMe(); Js = e => { if (typeof e == "string") return Js(new URL(e)); let { hostname: t, pathname: r, port: o, protocol: n, search: i } = e, a; return i && (a = ZLe(i)), { hostname: t, port: o ? parseInt(o) : void 0, protocol: n, path: r, query: a } } }); var tMe = s(() => { }); var rMe = s(() => { }); var oMe = s(() => { }); var nMe = s(() => { }); var sMe = s(() => { }); var iMe = s(() => { }); var aMe = s(() => { }); var cMe = s(() => { }); var pMe = s(() => { oMe(); nMe(); sMe(); iMe(); aMe(); cMe() }); var Jw = s(() => { JLe(); Q1(); W1(); tMe(); rMe(); pMe() }); async function uMe(e, t, r) { if (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" && ye(e, "PROTOCOL_RPC_V2_CBOR", "M"), typeof t.retryStrategy == "function") { let i = await t.retryStrategy(); typeof i.acquireInitialRetryToken == "function" ? i.constructor?.name?.includes("Adaptive") ? ye(e, "RETRY_MODE_ADAPTIVE", "F") : ye(e, "RETRY_MODE_STANDARD", "E") : ye(e, "RETRY_MODE_LEGACY", "D") } if (typeof t.accountIdEndpointMode == "function") { let i = e.endpointV2; switch (String(i?.url?.hostname).match(WRt) && ye(e, "ACCOUNT_ID_ENDPOINT", "O"), await t.accountIdEndpointMode?.()) { case "disabled": ye(e, "ACCOUNT_ID_MODE_DISABLED", "Q"); break; case "preferred": ye(e, "ACCOUNT_ID_MODE_PREFERRED", "P"); break; case "required": ye(e, "ACCOUNT_ID_MODE_REQUIRED", "R"); break } } let n = e.__smithy_context?.selectedHttpAuthScheme?.identity; if (n?.$source) { let i = n; i.accountId && ye(e, "RESOLVED_ACCOUNT_ID", "T"); for (let [a, c] of Object.entries(i.$source ?? {})) ye(e, a, c) } } var WRt, mMe = s(() => { Ye(); WRt = /\d{12}\.ddb/ }); var Y1, Zw, X1, eb, lMe, dMe, J1, fMe = s(() => { Y1 = "user-agent", Zw = "x-amz-user-agent", X1 = " ", eb = "/", lMe = /[^!$%&'*+\-.^_`|~\w]/g, dMe = /[^!$%&'*+\-.^_`|~\w#]/g, J1 = "-" }); function hMe(e) { let t = ""; for (let r in e) { let o = e[r]; if (t.length + o.length + 1 <= 1024) { t.length ? t += "," + o : t += o; continue } break } return t } var gMe = s(() => { }); var KRt, tb, QRt, rb, xMe = s(() => { Jw(); Hi(); mMe(); fMe(); gMe(); KRt = e => (t, r) => async o => { let { request: n } = o; if (!Gn.isInstance(n)) return t(o); let { headers: i } = n, a = r?.userAgent?.map(tb) || [], c = (await e.defaultUserAgentProvider()).map(tb); await uMe(r, e, o); let p = r; c.push(`m/${hMe(Object.assign({}, r.__smithy_context?.features, p.__aws_sdk_context?.features))}`); let u = e?.customUserAgent?.map(tb) || [], l = await e.userAgentAppId(); l && c.push(tb(["app", `${l}`])); let m = XLe(), f = (m ? [m] : []).concat([...c, ...a, ...u]).join(X1), h = [...c.filter(E => E.startsWith("aws-sdk-")), ...u].join(X1); return e.runtime !== "browser" ? (h && (i[Zw] = i[Zw] ? `${i[Y1]} ${h}` : h), i[Y1] = f) : i[Zw] = f, t({ ...o, request: n }) }, tb = e => { let t = e[0].split(eb).map(a => a.replace(lMe, J1)).join(eb), r = e[1]?.replace(dMe, J1), o = t.indexOf(eb), n = t.substring(0, o), i = t.substring(o + 1); return n === "api" && (i = i.toLowerCase()), [n, i, r].filter(a => a && a.length > 0).reduce((a, c, p) => { switch (p) { case 0: return c; case 1: return `${a}/${c}`; default: return `${a}#${c}` } }, "") }, QRt = { name: "getUserAgentMiddleware", step: "build", priority: "low", tags: ["SET_USER_AGENT", "USER_AGENT"], override: !0 }, rb = e => ({ applyToStack: t => { t.add(KRt(e), QRt) } }) }); var ob = s(() => { jLe(); xMe() }); var YRt, XRt, nb, EMe = s(() => { os(); YRt = "AWS_USE_DUALSTACK_ENDPOINT", XRt = "use_dualstack_endpoint", nb = { environmentVariableSelector: e => xt(e, YRt, ct.ENV), configFileSelector: e => xt(e, XRt, ct.CONFIG), default: !1 } }); var JRt, ZRt, sb, yMe = s(() => { os(); JRt = "AWS_USE_FIPS_ENDPOINT", ZRt = "use_fips_endpoint", sb = { environmentVariableSelector: e => xt(e, JRt, ct.ENV), configFileSelector: e => xt(e, ZRt, ct.CONFIG), default: !1 } }); var SMe = s(() => { }); var _Me = s(() => { }); var CMe = s(() => { EMe(); yMe(); SMe(); _Me() }); var eAt, tAt, Ml, ib, RMe = s(() => { eAt = "AWS_REGION", tAt = "region", Ml = { environmentVariableSelector: e => e[eAt], configFileSelector: e => e[tAt], default: () => { throw new Error("Region is missing") } }, ib = { preferredFile: "credentials" } }); var AMe, TMe, wMe = s(() => { Ft(); AMe = new Set, TMe = (e, t = Or) => { if (!AMe.has(e) && !t(e)) if (e === "*") console.warn('@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.'); else throw new Error(`Region not accepted: region="${e}" is not a valid hostname component.`); else AMe.add(e) } }); var ab, Z1 = s(() => { ab = e => typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")) }); var bMe, IMe = s(() => { Z1(); bMe = e => ab(e) ? ["fips-aws-global", "aws-fips"].includes(e) ? "us-east-1" : e.replace(/fips-(dkr-|prod-)?|-fips/, "") : e }); var cb, vMe = s(() => { wMe(); IMe(); Z1(); cb = e => { let { region: t, useFipsEndpoint: r } = e; if (!t) throw new Error("Region is missing"); return Object.assign(e, { region: async () => { let o = typeof t == "function" ? await t() : t, n = bMe(o); return TMe(n), n }, useFipsEndpoint: async () => { let o = typeof t == "string" ? t : await t(); return ab(o) ? !0 : typeof r != "function" ? Promise.resolve(!!r) : r() } }) } }); var PMe = s(() => { RMe(); vMe() }); var OMe = s(() => { }); var DMe = s(() => { }); var kMe = s(() => { }); var NMe = s(() => { OMe(); DMe(); kMe() }); var $l = s(() => { CMe(); PMe(); NMe() }); var BMe, LMe = s(() => { BMe = e => Object.assign(e, { eventStreamMarshaller: e.eventStreamSerdeProvider(e) }) }); var MMe = s(() => { LMe() }); function rAt(e) { return t => async r => { let o = r.request; if (Gn.isInstance(o)) { let { body: n, headers: i } = o; if (n && Object.keys(i).map(a => a.toLowerCase()).indexOf($Me) === -1) try { let a = e(n); o.headers = { ...o.headers, [$Me]: String(a) } } catch { } } return t({ ...r, request: o }) } } var $Me, oAt, pb, e3 = s(() => { Hi(); $Me = "content-length"; oAt = { step: "build", tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"], name: "contentLengthMiddleware", override: !0 }, pb = e => ({ applyToStack: t => { t.add(rAt(e.bodyLengthChecker), oAt) } }) }); var FMe, nAt, sAt, iAt, aAt, cAt, UMe = s(() => { FMe = async e => { let t = e?.Bucket || ""; if (typeof e.Bucket == "string" && (e.Bucket = t.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), cAt(t)) { if (e.ForcePathStyle === !0) throw new Error("Path-style addressing cannot be used with ARN buckets") } else (!aAt(t) || t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:") || t.toLowerCase() !== t || t.length < 3) && (e.ForcePathStyle = !0); return e.DisableMultiRegionAccessPoints && (e.disableMultiRegionAccessPoints = !0, e.DisableMRAP = !0), e }, nAt = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, sAt = /(\d+\.){3}\d+/, iAt = /\.\./, aAt = e => nAt.test(e) && !sAt.test(e) && !iAt.test(e), cAt = e => { let [t, r, o, , , n] = e.split(":"), i = t === "arn" && e.split(":").length >= 6, a = !!(i && r && o && n); if (i && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`); return a } }); var HMe = s(() => { UMe() }); var GMe, jMe = s(() => { GMe = (e, t, r, o = !1) => { let n = async () => { let i; return o ? i = r.clientContextParams?.[e] ?? r[e] ?? r[t] : i = r[e] ?? r[t], typeof i == "function" ? i() : i }; return e === "credentialScope" || t === "CredentialScope" ? async () => { let i = typeof r.credentials == "function" ? await r.credentials() : r.credentials; return i?.credentialScope ?? i?.CredentialScope } : e === "accountId" || t === "AccountId" ? async () => { let i = typeof r.credentials == "function" ? await r.credentials() : r.credentials; return i?.accountId ?? i?.AccountId } : e === "endpoint" || t === "endpoint" ? async () => { if (r.isCustomEndpoint === !1) return; let i = await n(); if (i && typeof i == "object") { if ("url" in i) return i.url.href; if ("hostname" in i) { let { protocol: a, hostname: c, port: p, path: u } = i; return `${a}//${c}${p ? ":" + p : ""}${u}` } } return i } : n } }); function ub(e) { try { let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? [])); return t.delete("CONFIG"), t.delete("CONFIG_PREFIX_SEPARATOR"), t.delete("ENV"), [...t].join(", ") } catch { return e } } var t3 = s(() => { }); var qMe, VMe = s(() => { Z(); t3(); qMe = (e, t) => async () => { try { let r = e(process.env, t); if (r === void 0) throw new Error; return r } catch (r) { throw new I(r.message || `Not found in ENV: ${ub(e.toString())}`, { logger: t?.logger }) } } }); import { homedir as pAt } from "os"; import { sep as uAt } from "path"; var r3, mAt, Wa, Fl = s(() => { r3 = {}, mAt = () => process && process.geteuid ? `${process.geteuid()}` : "DEFAULT", Wa = () => { let { HOME: e, USERPROFILE: t, HOMEPATH: r, HOMEDRIVE: o = `C:${uAt}` } = process.env; if (e) return e; if (t) return t; if (r) return `${o}${r}`; let n = mAt(); return r3[n] || (r3[n] = pAt()), r3[n] } }); var o3, lAt, jn, zMe = s(() => { o3 = "AWS_PROFILE", lAt = "default", jn = e => e.profile || process.env[o3] || lAt }); import { createHash as dAt } from "crypto"; import { join as fAt } from "path"; var mb, n3 = s(() => { Fl(); mb = e => { let r = dAt("sha1").update(e).digest("hex"); return fAt(Wa(), ".aws", "sso", "cache", `${r}.json`) } }); import { readFile as hAt } from "fs/promises"; var Lg, Mg, s3 = s(() => { n3(); Lg = {}, Mg = async e => { if (Lg[e]) return Lg[e]; let t = mb(e), r = await hAt(t, "utf8"); return JSON.parse(r) } }); var on, lb = s(() => { on = "." }); var WMe, KMe = s(() => { Dl(); lb(); WMe = e => Object.entries(e).filter(([t]) => { let r = t.indexOf(on); return r === -1 ? !1 : Object.values(Ui).includes(t.substring(0, r)) }).reduce((t, [r, o]) => { let n = r.indexOf(on), i = r.substring(0, n) === Ui.PROFILE ? r.substring(n + 1) : r; return t[i] = o, t }, { ...e.default && { default: e.default } }) }); import { join as gAt } from "path"; var xAt, db, i3 = s(() => { Fl(); xAt = "AWS_CONFIG_FILE", db = () => process.env[xAt] || gAt(Wa(), ".aws", "config") }); import { join as EAt } from "path"; var yAt, QMe, YMe = s(() => { Fl(); yAt = "AWS_SHARED_CREDENTIALS_FILE", QMe = () => process.env[yAt] || EAt(Wa(), ".aws", "credentials") }); var SAt, _At, $g, a3 = s(() => { Dl(); lb(); SAt = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/, _At = ["__proto__", "profile __proto__"], $g = e => { let t = {}, r, o; for (let n of e.split(/\r?\n/)) { let i = n.split(/(^|\s)[;#]/)[0].trim(); if (i[0] === "[" && i[i.length - 1] === "]") { r = void 0, o = void 0; let c = i.substring(1, i.length - 1), p = SAt.exec(c); if (p) { let [, u, , l] = p; Object.values(Ui).includes(u) && (r = [u, l].join(on)) } else r = c; if (_At.includes(c)) throw new Error(`Found invalid profile name "${c}"`) } else if (r) { let c = i.indexOf("="); if (![0, -1].includes(c)) { let [p, u] = [i.substring(0, c).trim(), i.substring(c + 1).trim()]; if (u === "") o = p; else { o && n.trimStart() === n && (o = void 0), t[r] = t[r] || {}; let l = o ? [o, p].join(on) : p; t[r][l] = u } } } } return t } }); import { readFile as CAt } from "node:fs/promises"; var c3, Fg, Ug, fb = s(() => { c3 = {}, Fg = {}, Ug = (e, t) => Fg[e] !== void 0 ? Fg[e] : ((!c3[e] || t?.ignoreCache) && (c3[e] = CAt(e, "utf8")), c3[e]) }); import { join as XMe } from "path"; var JMe, hb, gb = s(() => { KMe(); i3(); YMe(); Fl(); a3(); fb(); lb(); JMe = () => ({}), hb = async (e = {}) => { let { filepath: t = QMe(), configFilepath: r = db() } = e, o = Wa(), n = "~/", i = t; t.startsWith(n) && (i = XMe(o, t.slice(2))); let a = r; r.startsWith(n) && (a = XMe(o, r.slice(2))); let c = await Promise.all([Ug(a, { ignoreCache: e.ignoreCache }).then($g).then(WMe).catch(JMe), Ug(i, { ignoreCache: e.ignoreCache }).then($g).catch(JMe)]); return { configFile: c[0], credentialsFile: c[1] } } }); var ZMe, e$e = s(() => { Dl(); gb(); ZMe = e => Object.entries(e).filter(([t]) => t.startsWith(Ui.SSO_SESSION + on)).reduce((t, [r, o]) => ({ ...t, [r.substring(r.indexOf(on) + 1)]: o }), {}) }); var RAt, xb, t$e = s(() => { i3(); e$e(); a3(); fb(); RAt = () => ({}), xb = async (e = {}) => Ug(e.configFilepath ?? db()).then($g).then(ZMe).catch(RAt) }); var r$e, o$e = s(() => { r$e = (...e) => { let t = {}; for (let r of e) for (let [o, n] of Object.entries(r)) t[o] !== void 0 ? Object.assign(t[o], n) : t[o] = n; return t } }); var Ka, n$e = s(() => { gb(); o$e(); Ka = async e => { let t = await hb(e); return r$e(t.configFile, t.credentialsFile) } }); var Hg, s$e = s(() => { s3(); fb(); Hg = { getFileRecord() { return Fg }, interceptFile(e, t) { Fg[e] = Promise.resolve(t) }, getTokenRecord() { return Lg }, interceptToken(e, t) { Lg[e] = t } } }); var i$e = s(() => { }); var nn = s(() => { Fl(); zMe(); n3(); s3(); gb(); t$e(); n$e(); s$e(); i$e() }); var a$e, c$e = s(() => { Z(); nn(); t3(); a$e = (e, { preferredFile: t = "config", ...r } = {}) => async () => { let o = jn(r), { configFile: n, credentialsFile: i } = await hb(r), a = i[o] || {}, c = n[o] || {}, p = t === "config" ? { ...a, ...c } : { ...c, ...a }; try { let l = e(p, t === "config" ? n : i); if (l === void 0) throw new Error; return l } catch (u) { throw new I(u.message || `Not found in config files w/ profile [${o}]: ${ub(e.toString())}`, { logger: r.logger }) } } }); var AAt, p$e, u$e = s(() => { Z(); AAt = e => typeof e == "function", p$e = e => AAt(e) ? async () => await e() : Is(e) }); var ht, m$e = s(() => { Z(); VMe(); c$e(); u$e(); ht = ({ environmentVariableSelector: e, configFileSelector: t, default: r }, o = {}) => { let { signingName: n, logger: i } = o; return jr(sr(qMe(e, { signingName: n, logger: i }), a$e(t, o), p$e(r))) } }); var pp = s(() => { m$e() }); var l$e, d$e, f$e, h$e = s(() => { nn(); l$e = "AWS_ENDPOINT_URL", d$e = "endpoint_url", f$e = e => ({ environmentVariableSelector: t => { let r = e.split(" ").map(i => i.toUpperCase()), o = t[[l$e, ...r].join("_")]; if (o) return o; let n = t[l$e]; if (n) return n }, configFileSelector: (t, r) => { if (r && t.services) { let n = r[["services", t.services].join(on)]; if (n) { let i = e.split(" ").map(c => c.toLowerCase()), a = n[[i.join("_"), d$e].join(on)]; if (a) return a } } let o = t[d$e]; if (o) return o }, default: void 0 }) }); var Eb, p3 = s(() => { pp(); h$e(); Eb = async e => ht(f$e(e ?? ""))() }); var yb, Sb = s(() => { Bg(); yb = e => typeof e == "object" ? "url" in e ? Js(e.url) : e : Js(e) }); var g$e, u3, m3 = s(() => { HMe(); jMe(); p3(); Sb(); g$e = async (e, t, r, o) => { if (!r.isCustomEndpoint) { let a; r.serviceConfiguredEndpoint ? a = await r.serviceConfiguredEndpoint() : a = await Eb(r.serviceId), a && (r.endpoint = () => Promise.resolve(yb(a)), r.isCustomEndpoint = !0) } let n = await u3(e, t, r); if (typeof r.endpointProvider != "function") throw new Error("config.endpointProvider is not set."); return r.endpointProvider(n, o) }, u3 = async (e, t, r) => { let o = {}, n = t?.getEndpointParameterInstructions?.() || {}; for (let [i, a] of Object.entries(n)) switch (a.type) { case "staticContextParams": o[i] = a.value; break; case "contextParams": o[i] = e[a.name]; break; case "clientContextParams": case "builtInParams": o[i] = await GMe(a.name, i, r, a.type !== "builtInParams")(); break; case "operationContextParams": o[i] = a.get(e); break; default: throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(a)) }return Object.keys(n).length === 0 && Object.assign(o, r), String(r.serviceId).toLowerCase() === "s3" && await FMe(o), o } }); var x$e = s(() => { m3(); Sb() }); var E$e, l3 = s(() => { Ie(); gt(); m3(); E$e = ({ config: e, instructions: t }) => (r, o) => async n => { e.isCustomEndpoint && ea(o, "ENDPOINT_OVERRIDE", "N"); let i = await g$e(n.input, { getEndpointParameterInstructions() { return t } }, { ...e }, o); o.endpointV2 = i, o.authSchemes = i.properties?.authSchemes; let a = o.authSchemes?.[0]; if (a) { o.signing_region = a.signingRegion, o.signing_service = a.signingName; let p = je(o)?.selectedHttpAuthScheme?.httpAuthOption; p && (p.signingProperties = Object.assign(p.signingProperties || {}, { signing_region: a.signingRegion, signingRegion: a.signingRegion, signing_service: a.signingName, signingName: a.signingName, signingRegionSet: a.signingRegionSet }, a.properties)) } return r({ ...n }) } }); var y$e = s(() => { }); var S$e = s(() => { }); var _$e, C$e = s(() => { _$e = { name: "serializerMiddleware", step: "serialize", tags: ["SERIALIZER"], override: !0 } }); var R$e = s(() => { y$e(); C$e(); S$e() }); var TAt, T, A$e = s(() => { R$e(); l3(); TAt = { step: "serialize", tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"], name: "endpointV2Middleware", override: !0, relation: "before", toMiddleware: _$e.name }, T = (e, t) => ({ applyToStack: r => { r.addRelativeTo(E$e({ config: e, instructions: t }), TAt) } }) }); var _b, T$e = s(() => { gt(); p3(); Sb(); _b = e => { let t = e.tls ?? !0, { endpoint: r, useDualstackEndpoint: o, useFipsEndpoint: n } = e, i = r != null ? async () => yb(await le(r)()) : void 0, c = Object.assign(e, { endpoint: i, tls: t, isCustomEndpoint: !!r, useDualstackEndpoint: le(o ?? !1), useFipsEndpoint: le(n ?? !1) }), p; return c.serviceConfiguredEndpoint = async () => (e.serviceId && !p && (p = Eb(e.serviceId)), p), c } }); var w$e = s(() => { }); var b$e = s(() => { }); var V = s(() => { x$e(); l3(); A$e(); T$e(); w$e(); b$e() }); var Gi, Ul, Hl, Cb = s(() => { (function (e) { e.STANDARD = "standard", e.ADAPTIVE = "adaptive" })(Gi || (Gi = {})); Ul = 3, Hl = Gi.STANDARD }); var I$e, v$e, P$e, O$e, D$e, k$e = s(() => { I$e = ["BandwidthLimitExceeded", "EC2ThrottledException", "LimitExceededException", "PriorRequestNotComplete", "ProvisionedThroughputExceededException", "RequestLimitExceeded", "RequestThrottled", "RequestThrottledException", "SlowDown", "ThrottledException", "Throttling", "ThrottlingException", "TooManyRequestsException", "TransactionInProgressException"], v$e = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], P$e = [500, 502, 503, 504], O$e = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], D$e = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"] }); var wAt, bAt, IAt, Rb, Ab, N$e, d3 = s(() => { k$e(); wAt = e => e?.$retryable !== void 0, bAt = e => e.$metadata?.clockSkewCorrected, IAt = e => { let t = new Set(["Failed to fetch", "NetworkError when attempting to fetch resource", "The Internet connection appears to be offline", "Load failed", "Network request failed"]); return e && e instanceof TypeError ? t.has(e.message) : !1 }, Rb = e => e.$metadata?.httpStatusCode === 429 || I$e.includes(e.name) || e.$retryable?.throttling == !0, Ab = (e, t = 0) => wAt(e) || bAt(e) || v$e.includes(e.name) || O$e.includes(e?.code || "") || D$e.includes(e?.code || "") || P$e.includes(e.$metadata?.httpStatusCode || 0) || IAt(e) || e.cause !== void 0 && t <= 10 && Ab(e.cause, t + 1), N$e = e => { if (e.$metadata?.httpStatusCode !== void 0) { let t = e.$metadata.httpStatusCode; return 500 <= t && t <= 599 && !Ab(e) } return !1 } }); var Tb, f3 = s(() => { d3(); Tb = class e { static setTimeoutFn = setTimeout; beta; minCapacity; minFillRate; scaleConstant; smooth; currentCapacity = 0; enabled = !1; lastMaxRate = 0; measuredTxRate = 0; requestCount = 0; fillRate; lastThrottleTime; lastTimestamp = 0; lastTxRateBucket; maxCapacity; timeWindow = 0; constructor(t) { this.beta = t?.beta ?? .7, this.minCapacity = t?.minCapacity ?? 1, this.minFillRate = t?.minFillRate ?? .5, this.scaleConstant = t?.scaleConstant ?? .4, this.smooth = t?.smooth ?? .8; let r = this.getCurrentTimeInSeconds(); this.lastThrottleTime = r, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity } getCurrentTimeInSeconds() { return Date.now() / 1e3 } async getSendToken() { return this.acquireTokenBucket(1) } async acquireTokenBucket(t) { if (this.enabled) { if (this.refillTokenBucket(), t > this.currentCapacity) { let r = (t - this.currentCapacity) / this.fillRate * 1e3; await new Promise(o => e.setTimeoutFn(o, r)) } this.currentCapacity = this.currentCapacity - t } } refillTokenBucket() { let t = this.getCurrentTimeInSeconds(); if (!this.lastTimestamp) { this.lastTimestamp = t; return } let r = (t - this.lastTimestamp) * this.fillRate; this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + r), this.lastTimestamp = t } updateClientSendingRate(t) { let r; if (this.updateMeasuredRate(), Rb(t)) { let n = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate; this.lastMaxRate = n, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), r = this.cubicThrottle(n), this.enableTokenBucket() } else this.calculateTimeWindow(), r = this.cubicSuccess(this.getCurrentTimeInSeconds()); let o = Math.min(r, 2 * this.measuredTxRate); this.updateTokenBucketRate(o) } calculateTimeWindow() { this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3)) } cubicThrottle(t) { return this.getPrecise(t * this.beta) } cubicSuccess(t) { return this.getPrecise(this.scaleConstant * Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate) } enableTokenBucket() { this.enabled = !0 } updateTokenBucketRate(t) { this.refillTokenBucket(), this.fillRate = Math.max(t, this.minFillRate), this.maxCapacity = Math.max(t, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity) } updateMeasuredRate() { let t = this.getCurrentTimeInSeconds(), r = Math.floor(t * 2) / 2; if (this.requestCount++, r > this.lastTxRateBucket) { let o = this.requestCount / (r - this.lastTxRateBucket); this.measuredTxRate = this.getPrecise(o * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = r } } getPrecise(t) { return parseFloat(t.toFixed(8)) } } }); var B$e, L$e, M$e = s(() => { B$e = "amz-sdk-invocation-id", L$e = "amz-sdk-request" }); var F$e, U$e = s(() => { F$e = () => { let e = 100; return { computeNextBackoffDelay: o => Math.floor(Math.min(2e4, Math.random() * 2 ** o * e)), setDelayBase: o => { e = o } } } }); var h3, H$e = s(() => { h3 = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({ getRetryCount: () => t, getRetryDelay: () => Math.min(2e4, e), getRetryCost: () => r }) }); var Gl, g3 = s(() => { Cb(); U$e(); H$e(); Gl = class { maxAttempts; mode = Gi.STANDARD; capacity = 500; retryBackoffStrategy = F$e(); maxAttemptsProvider; constructor(t) { this.maxAttempts = t, this.maxAttemptsProvider = typeof t == "function" ? t : async () => t } async acquireInitialRetryToken(t) { return h3({ retryDelay: 100, retryCount: 0 }) } async refreshRetryTokenForRetry(t, r) { let o = await this.getMaxAttempts(); if (this.shouldRetry(t, r, o)) { let n = r.errorType; this.retryBackoffStrategy.setDelayBase(n === "THROTTLING" ? 500 : 100); let i = this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()), a = r.retryAfterHint ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i) : i, c = this.getCapacityCost(n); return this.capacity -= c, h3({ retryDelay: a, retryCount: t.getRetryCount() + 1, retryCost: c }) } throw new Error("No retry token available") } recordSuccess(t) { this.capacity = Math.max(500, this.capacity + (t.getRetryCost() ?? 1)) } getCapacity() { return this.capacity } async getMaxAttempts() { try { return await this.maxAttemptsProvider() } catch { return console.warn(`Max attempts provider could not resolve. Using default of ${Ul}`), Ul } } shouldRetry(t, r, o) { return t.getRetryCount() + 1 < o && this.capacity >= this.getCapacityCost(r.errorType) && this.isRetryableError(r.errorType) } getCapacityCost(t) { return t === "TRANSIENT" ? 10 : 5 } isRetryableError(t) { return t === "THROTTLING" || t === "TRANSIENT" } } }); var wb, G$e = s(() => { Cb(); f3(); g3(); wb = class { maxAttemptsProvider; rateLimiter; standardRetryStrategy; mode = Gi.ADAPTIVE; constructor(t, r) { this.maxAttemptsProvider = t; let { rateLimiter: o } = r ?? {}; this.rateLimiter = o ?? new Tb, this.standardRetryStrategy = new Gl(t) } async acquireInitialRetryToken(t) { return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(t) } async refreshRetryTokenForRetry(t, r) { return this.rateLimiter.updateClientSendingRate(r), this.standardRetryStrategy.refreshRetryTokenForRetry(t, r) } recordSuccess(t) { this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(t) } } }); var j$e = s(() => { }); var q$e = s(() => { }); var Gg = s(() => { G$e(); j$e(); f3(); g3(); Cb(); M$e(); q$e() }); var V$e = s(() => { }); var z$e = s(() => { }); var W$e, K$e = s(() => { W$e = e => e instanceof Error ? e : e instanceof Object ? Object.assign(new Error, e) : typeof e == "string" ? new Error(e) : new Error(`AWS SDK error wrapper for ${e}`) }); var Q$e = s(() => { }); var Y$e = s(() => { }); var X$e, J$e, bb, Ib, OAt, DAt, vb, Z$e = s(() => { gt(); Gg(); X$e = "AWS_MAX_ATTEMPTS", J$e = "max_attempts", bb = { environmentVariableSelector: e => { let t = e[X$e]; if (!t) return; let r = parseInt(t); if (Number.isNaN(r)) throw new Error(`Environment variable ${X$e} mast be a number, got "${t}"`); return r }, configFileSelector: e => { let t = e[J$e]; if (!t) return; let r = parseInt(t); if (Number.isNaN(r)) throw new Error(`Shared config file entry ${J$e} mast be a number, got "${t}"`); return r }, default: Ul }, Ib = e => { let { retryStrategy: t, retryMode: r, maxAttempts: o } = e, n = le(o ?? Ul); return Object.assign(e, { maxAttempts: n, retryStrategy: async () => t || (await le(r)() === Gi.ADAPTIVE ? new wb(n) : new Gl(n)) }) }, OAt = "AWS_RETRY_MODE", DAt = "retry_mode", vb = { environmentVariableSelector: e => e[OAt], configFileSelector: e => e[DAt], default: Hl } }); var eFe = s(() => { }); var up, Qa, jl, tFe, rFe, oFe = s(() => { up = (e, t) => { let r = []; if (e && r.push(e), t) for (let o of t) r.push(o); return r }, Qa = (e, t) => `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`, jl = () => { let e = [], t = [], r = !1, o = new Set, n = m => m.sort((f, h) => tFe[h.step] - tFe[f.step] || rFe[h.priority || "normal"] - rFe[f.priority || "normal"]), i = m => { let f = !1, h = E => { let S = up(E.name, E.aliases); if (S.includes(m)) { f = !0; for (let y of S) o.delete(y); return !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, a = m => { let f = !1, h = E => { if (E.middleware === m) { f = !0; for (let S of up(E.name, E.aliases)) o.delete(S); return !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, c = m => (e.forEach(f => { m.add(f.middleware, { ...f }) }), t.forEach(f => { m.addRelativeTo(f.middleware, { ...f }) }), m.identifyOnResolve?.(l.identifyOnResolve()), m), p = m => { let f = []; return m.before.forEach(h => { h.before.length === 0 && h.after.length === 0 ? f.push(h) : f.push(...p(h)) }), f.push(m), m.after.reverse().forEach(h => { h.before.length === 0 && h.after.length === 0 ? f.push(h) : f.push(...p(h)) }), f }, u = (m = !1) => { let f = [], h = [], E = {}; return e.forEach(y => { let C = { ...y, before: [], after: [] }; for (let b of up(C.name, C.aliases)) E[b] = C; f.push(C) }), t.forEach(y => { let C = { ...y, before: [], after: [] }; for (let b of up(C.name, C.aliases)) E[b] = C; h.push(C) }), h.forEach(y => { if (y.toMiddleware) { let C = E[y.toMiddleware]; if (C === void 0) { if (m) return; throw new Error(`${y.toMiddleware} is not found when adding ${Qa(y.name, y.aliases)} middleware ${y.relation} ${y.toMiddleware}`) } y.relation === "after" && C.after.push(y), y.relation === "before" && C.before.push(y) } }), n(f).map(p).reduce((y, C) => (y.push(...C), y), []) }, l = { add: (m, f = {}) => { let { name: h, override: E, aliases: S } = f, y = { step: "initialize", priority: "normal", middleware: m, ...f }, C = up(h, S); if (C.length > 0) { if (C.some(b => o.has(b))) { if (!E) throw new Error(`Duplicate middleware name '${Qa(h, S)}'`); for (let b of C) { let L = e.findIndex(j => j.name === b || j.aliases?.some(re => re === b)); if (L === -1) continue; let N = e[L]; if (N.step !== y.step || y.priority !== N.priority) throw new Error(`"${Qa(N.name, N.aliases)}" middleware with ${N.priority} priority in ${N.step} step cannot be overridden by "${Qa(h, S)}" middleware with ${y.priority} priority in ${y.step} step.`); e.splice(L, 1) } } for (let b of C) o.add(b) } e.push(y) }, addRelativeTo: (m, f) => { let { name: h, override: E, aliases: S } = f, y = { middleware: m, ...f }, C = up(h, S); if (C.length > 0) { if (C.some(b => o.has(b))) { if (!E) throw new Error(`Duplicate middleware name '${Qa(h, S)}'`); for (let b of C) { let L = t.findIndex(j => j.name === b || j.aliases?.some(re => re === b)); if (L === -1) continue; let N = t[L]; if (N.toMiddleware !== y.toMiddleware || N.relation !== y.relation) throw new Error(`"${Qa(N.name, N.aliases)}" middleware ${N.relation} "${N.toMiddleware}" middleware cannot be overridden by "${Qa(h, S)}" middleware ${y.relation} "${y.toMiddleware}" middleware.`); t.splice(L, 1) } } for (let b of C) o.add(b) } t.push(y) }, clone: () => c(jl()), use: m => { m.applyToStack(l) }, remove: m => typeof m == "string" ? i(m) : a(m), removeByTag: m => { let f = !1, h = E => { let { tags: S, name: y, aliases: C } = E; if (S && S.includes(m)) { let b = up(y, C); for (let L of b) o.delete(L); return f = !0, !1 } return !0 }; return e = e.filter(h), t = t.filter(h), f }, concat: m => { let f = c(jl()); return f.use(m), f.identifyOnResolve(r || f.identifyOnResolve() || (m.identifyOnResolve?.() ?? !1)), f }, applyToStack: c, identify: () => u(!0).map(m => { let f = m.step ?? m.relation + " " + m.toMiddleware; return Qa(m.name, m.aliases) + " - " + f }), identifyOnResolve(m) { return typeof m == "boolean" && (r = m), r }, resolve: (m, f) => { for (let h of u().map(E => E.middleware).reverse()) m = h(m, f); return r && console.log(l.identify()), m } }; return l }, tFe = { initialize: 5, serialize: 4, build: 3, finalizeRequest: 2, deserialize: 1 }, rFe = { high: 3, normal: 2, low: 1 } }); var x3 = s(() => { oFe() }); var ql, nFe = s(() => { x3(); ql = class { config; middlewareStack = jl(); initConfig; handlers; constructor(t) { this.config = t; let { protocol: r, protocolSettings: o } = t; o && typeof r == "function" && (t.protocol = new r(o)) } send(t, r, o) { let n = typeof r != "function" ? r : void 0, i = typeof r == "function" ? r : o, a = n === void 0 && this.config.cacheMiddleware === !0, c; if (a) { this.handlers || (this.handlers = new WeakMap); let p = this.handlers; p.has(t.constructor) ? c = p.get(t.constructor) : (c = t.resolveMiddleware(this.middlewareStack, this.config, n), p.set(t.constructor, c)) } else delete this.handlers, c = t.resolveMiddleware(this.middlewareStack, this.config, n); if (i) c(t).then(p => i(null, p.output), p => i(p)).catch(() => { }); else return c(t).then(p => p.output) } destroy() { this.config?.requestHandler?.destroy?.(), delete this.handlers } } }); var sFe = s(() => { }); function Pb(e, t) { if (t == null) return t; let r = ue.of(e); if (r.getMergedTraits().sensitive) return E3; if (r.isListSchema()) { if (!!r.getValueSchema().getMergedTraits().sensitive) return E3 } else if (r.isMapSchema()) { if (!!r.getKeySchema().getMergedTraits().sensitive || !!r.getValueSchema().getMergedTraits().sensitive) return E3 } else if (r.isStructSchema() && typeof t == "object") { let o = t, n = {}; for (let [i, a] of r.structIterator()) o[i] != null && (n[i] = Pb(a, o[i])); return n } return t } var E3, iFe = s(() => { Oe(); E3 = "***SensitiveInformation***" }); var R, y3, aFe = s(() => { x3(); Dl(); iFe(); R = class { middlewareStack = jl(); schema; static classBuilder() { return new y3 } resolveMiddlewareWithContext(t, r, o, { middlewareFn: n, clientName: i, commandName: a, inputFilterSensitiveLog: c, outputFilterSensitiveLog: p, smithyContext: u, additionalContext: l, CommandCtor: m }) { for (let y of n.bind(this)(m, t, r, o)) this.middlewareStack.use(y); let f = t.concat(this.middlewareStack), { logger: h } = r, E = { logger: h, clientName: i, commandName: a, inputFilterSensitiveLog: c, outputFilterSensitiveLog: p, [kNe]: { commandInstance: this, ...u }, ...l }, { requestHandler: S } = r; return f.resolve(y => S.handle(y.request, o || {}), E) } }, y3 = class { _init = () => { }; _ep = {}; _middlewareFn = () => []; _commandName = ""; _clientName = ""; _additionalContext = {}; _smithyContext = {}; _inputFilterSensitiveLog = void 0; _outputFilterSensitiveLog = void 0; _serializer = null; _deserializer = null; _operationSchema; init(t) { this._init = t } ep(t) { return this._ep = t, this } m(t) { return this._middlewareFn = t, this } s(t, r, o = {}) { return this._smithyContext = { service: t, operation: r, ...o }, this } c(t = {}) { return this._additionalContext = t, this } n(t, r) { return this._clientName = t, this._commandName = r, this } f(t = o => o, r = o => o) { return this._inputFilterSensitiveLog = t, this._outputFilterSensitiveLog = r, this } ser(t) { return this._serializer = t, this } de(t) { return this._deserializer = t, this } sc(t) { return this._operationSchema = t, this._smithyContext.operationSchema = t, this } build() { let t = this, r; return r = class extends R { input; static getEndpointParameterInstructions() { return t._ep } constructor(...[o]) { super(), this.input = o ?? {}, t._init(this), this.schema = t._operationSchema } resolveMiddleware(o, n, i) { let a = t._operationSchema, c = a?.[4] ?? a?.input, p = a?.[5] ?? a?.output; return this.resolveMiddlewareWithContext(o, n, i, { CommandCtor: r, middlewareFn: t._middlewareFn, clientName: t._clientName, commandName: t._commandName, inputFilterSensitiveLog: t._inputFilterSensitiveLog ?? (a ? Pb.bind(null, c) : u => u), outputFilterSensitiveLog: t._outputFilterSensitiveLog ?? (a ? Pb.bind(null, p) : u => u), smithyContext: t._smithyContext, additionalContext: t._additionalContext }) } serialize = t._serializer; deserialize = t._deserializer } } } }); var cFe = s(() => { }); var Ob, pFe = s(() => { Ob = (e, t) => { for (let r of Object.keys(e)) { let o = e[r], n = async function (a, c, p) { let u = new o(a); if (typeof c == "function") this.send(u, c); else if (typeof p == "function") { if (typeof c != "object") throw new Error(`Expected http options but got ${typeof c}`); this.send(u, c || {}, p) } else return this.send(u, c) }, i = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, ""); t.prototype[i] = n } } }); var Vl, uFe = s(() => { Vl = class e extends Error { $fault; $response; $retryable; $metadata; constructor(t) { super(t.message), Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = t.name, this.$fault = t.$fault, this.$metadata = t.$metadata } static isInstance(t) { if (!t) return !1; let r = t; return e.prototype.isPrototypeOf(r) || !!r.$fault && !!r.$metadata && (r.$fault === "client" || r.$fault === "server") } static [Symbol.hasInstance](t) { if (!t) return !1; let r = t; return this === e ? e.isInstance(t) : e.isInstance(t) ? r.name && this.name ? this.prototype.isPrototypeOf(t) || r.name === this.name : this.prototype.isPrototypeOf(t) : !1 } } }); var mFe = s(() => { }); var Db, lFe = s(() => { Db = e => { switch (e) { case "standard": return { retryMode: "standard", connectionTimeout: 3100 }; case "in-region": return { retryMode: "standard", connectionTimeout: 1100 }; case "cross-region": return { retryMode: "standard", connectionTimeout: 3100 }; case "mobile": return { retryMode: "standard", connectionTimeout: 3e4 }; default: return {} } } }); var dFe, kb, fFe = s(() => { dFe = !1, kb = e => { e && !dFe && parseInt(e.substring(1, e.indexOf("."))) < 16 && (dFe = !0) } }); var hFe = s(() => { }); var gFe, xFe, EFe = s(() => { Dl(); gFe = e => { let t = []; for (let r in Ol) { let o = Ol[r]; e[o] !== void 0 && t.push({ algorithmId: () => o, checksumConstructor: () => e[o] }) } return { addChecksumAlgorithm(r) { t.push(r) }, checksumAlgorithms() { return t } } }, xFe = e => { let t = {}; return e.checksumAlgorithms().forEach(r => { t[r.algorithmId()] = r.checksumConstructor() }), t } }); var yFe, SFe, _Fe = s(() => { yFe = e => ({ setRetryStrategy(t) { e.retryStrategy = t }, retryStrategy() { return e.retryStrategy } }), SFe = e => { let t = {}; return t.retryStrategy = e.retryStrategy(), t } }); var Nb, Bb, CFe = s(() => { EFe(); _Fe(); Nb = e => Object.assign(gFe(e), yFe(e)), Bb = e => Object.assign(xFe(e), SFe(e)) }); var RFe = s(() => { CFe() }); var AFe = s(() => { }); var TFe = s(() => { }); var wFe = s(() => { }); var Ya, bFe = s(() => { Ya = class { trace() { } debug() { } info() { } warn() { } error() { } } }); var IFe = s(() => { }); var vFe = s(() => { }); var PFe = s(() => { }); var OFe = s(() => { }); var F = s(() => { nFe(); sFe(); aFe(); cFe(); pFe(); mFe(); lFe(); fFe(); uFe(); hFe(); RFe(); AFe(); TFe(); wFe(); bFe(); IFe(); vFe(); PFe(); OFe(); Pr() }); import { Readable as kAt } from "stream"; var DFe, kFe = s(() => { DFe = e => e?.body instanceof kAt || typeof ReadableStream < "u" && e?.body instanceof ReadableStream }); var NAt, BAt, LAt, MAt, $At, Lb, FAt, NFe = s(() => { Hi(); d3(); F(); Gg(); Wp(); kFe(); K$e(); NAt = e => (t, r) => async o => { let n = await e.retryStrategy(), i = await e.maxAttempts(); if (BAt(n)) { n = n; let a = await n.acquireInitialRetryToken(r.partition_id), c = new Error, p = 0, u = 0, { request: l } = o, m = Gn.isInstance(l); for (m && (l.headers[B$e] = ro()); ;)try { m && (l.headers[L$e] = `attempt=${p + 1}; max=${i}`); let { response: f, output: h } = await t(o); return n.recordSuccess(a), h.$metadata.attempts = p + 1, h.$metadata.totalRetryDelay = u, { response: f, output: h } } catch (f) { let h = LAt(f); if (c = W$e(f), m && DFe(l)) throw (r.logger instanceof Ya ? console : r.logger)?.warn("An error was encountered in a non-retryable streaming request."), c; try { a = await n.refreshRetryTokenForRetry(a, h) } catch { throw c.$metadata || (c.$metadata = {}), c.$metadata.attempts = p + 1, c.$metadata.totalRetryDelay = u, c } p = a.getRetryCount(); let E = a.getRetryDelay(); u += E, await new Promise(S => setTimeout(S, E)) } } else return n = n, n?.mode && (r.userAgent = [...r.userAgent || [], ["cfg/retry-mode", n.mode]]), n.retry(t, o) }, BAt = e => typeof e.acquireInitialRetryToken < "u" && typeof e.refreshRetryTokenForRetry < "u" && typeof e.recordSuccess < "u", LAt = e => { let t = { error: e, errorType: MAt(e) }, r = FAt(e.$response); return r && (t.retryAfterHint = r), t }, MAt = e => Rb(e) ? "THROTTLING" : Ab(e) ? "TRANSIENT" : N$e(e) ? "SERVER_ERROR" : "CLIENT_ERROR", $At = { name: "retryMiddleware", tags: ["RETRY"], step: "finalizeRequest", priority: "high", override: !0 }, Lb = e => ({ applyToStack: t => { t.add(NAt(e), $At) } }), FAt = e => { if (!kl.isInstance(e)) return; let t = Object.keys(e.headers).find(i => i.toLowerCase() === "retry-after"); if (!t) return; let r = e.headers[t], o = Number(r); return Number.isNaN(o) ? new Date(r) : new Date(o * 1e3) } }); var jg = s(() => { Y$e(); Q$e(); Z$e(); V$e(); eFe(); z$e(); NFe() }); var qg, S3 = s(() => { qg = { CrtSignerV4: null } }); var zl, BFe = s(() => { pe(); LE(); S3(); zl = class { sigv4aSigner; sigv4Signer; signerOptions; static sigv4aDependency() { return typeof qg.CrtSignerV4 == "function" ? "crt" : typeof SD.SignatureV4a == "function" ? "js" : "none" } constructor(t) { this.sigv4Signer = new kg(t), this.signerOptions = t } async sign(t, r = {}) { return r.signingRegion === "*" ? this.getSigv4aSigner().sign(t, r) : this.sigv4Signer.sign(t, r) } async signWithCredentials(t, r, o = {}) { if (o.signingRegion === "*") { let n = this.getSigv4aSigner(), i = qg.CrtSignerV4; if (i && n instanceof i) return n.signWithCredentials(t, r, o); throw new Error(`signWithCredentials with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`) } return this.sigv4Signer.signWithCredentials(t, r, o) } async presign(t, r = {}) { if (r.signingRegion === "*") { let o = this.getSigv4aSigner(), n = qg.CrtSignerV4; if (n && o instanceof n) return o.presign(t, r); throw new Error(`presign with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`) } return this.sigv4Signer.presign(t, r) } async presignWithCredentials(t, r, o = {}) { if (o.signingRegion === "*") throw new Error("Method presignWithCredentials is not supported for [signingRegion=*]."); return this.sigv4Signer.presignWithCredentials(t, r, o) } getSigv4aSigner() { if (!this.sigv4aSigner) { let t = qg.CrtSignerV4, r = SD.SignatureV4a; if (this.signerOptions.runtime === "node") { if (!t && !r) throw new Error("Neither CRT nor JS SigV4a implementation is available. Please load either @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt"); if (t && typeof t == "function") this.sigv4aSigner = new t({ ...this.signerOptions, signingAlgorithm: 1 }); else if (r && typeof r == "function") this.sigv4aSigner = new r({ ...this.signerOptions }); else throw new Error("Available SigV4a implementation is not a valid constructor. Please ensure you've properly imported @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a.For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt") } else { if (!r || typeof r != "function") throw new Error("JS SigV4a implementation is not available or not a valid constructor. Please check whether you have installed the @aws-sdk/signature-v4a package explicitly. The CRT implementation is not available for browsers. You must also register the package by calling [require('@aws-sdk/signature-v4a');] or an ESM equivalent such as [import '@aws-sdk/signature-v4a';]. For more information please go to https://github.com/aws/aws-sdk-js-v3#using-javascript-non-crt-implementation-of-sigv4a"); this.sigv4aSigner = new r({ ...this.signerOptions }) } } return this.sigv4aSigner } } }); var _3 = s(() => { BFe(); S3() }); var W3, _, U, A, v, P, de, ke, oe, ne, ji, Jr, wr, br, so, se, K3, an, Er, ce, Gb, rt, or, nr, Lt, LFe, Q3, z, H, jb, qb, ti, MFe, Hb, VUe, zUe, $Fe, V3, mp, Y3, Xg, Yl, WUe, KUe, FFe, QUe, YUe, XUe, Vb, X3, JUe, J3, UFe, HFe, GFe, jFe, ZUe, qFe, VFe, Wl, Kl, Vg, Vn, Gt, Ot, xr, e1e, zFe, Wg, Je, WFe, KFe, Ro, C3, t1e, r1e, sn, Te, o1e, QFe, YFe, XFe, Pe, Ve, $e, Mb, JFe, ZFe, eUe, $b, R3, UAt, Tr, Dr, Qr, Ke, Yr, tUe, Ir, Xr, rUe, oUe, nUe, A3, T3, z3, sUe, w3, iUe, Fb, Ho, n1e, b3, Z3, aUe, cUe, pUe, I3, s1e, i1e, v3, uUe, P3, O3, D3, mUe, lUe, zg, dUe, fUe, hUe, gUe, xUe, k3, EUe, yUe, N3, SUe, _Ue, CUe, B3, RUe, L3, HAt, GAt, M3, Ql, AUe, jAt, $3, qn, F3, Kg, Qg, Yg, TUe, Zs, wUe, bUe, IUe, vUe, ei, PUe, OUe, DUe, kUe, NUe, BUe, qAt, LUe, MUe, VAt, $Ue, Xa, U3, FUe, zAt, UUe, H3, HUe, WAt, G3, GUe, j3, q3, jUe, Ub, qUe, KAt, a1e, c1e = s(() => { W3 = "required", _ = "type", U = "rules", A = "conditions", v = "fn", P = "argv", de = "ref", ke = "assign", oe = "url", ne = "properties", ji = "backend", Jr = "authSchemes", wr = "disableDoubleEncoding", br = "signingName", so = "signingRegion", se = "headers", K3 = "signingRegionSet", an = "isSet", Er = "booleanEquals", ce = "error", Gb = "aws.partition", rt = "stringEquals", or = "getAttr", nr = "name", Lt = "substring", LFe = "bucketSuffix", Q3 = "parseURL", z = "endpoint", H = "tree", jb = "aws.isVirtualHostableS3Bucket", qb = "{url#scheme}://{Bucket}.{url#authority}{url#path}", ti = "not", MFe = "accessPointSuffix", Hb = "{url#scheme}://{url#authority}{url#path}", VUe = "hardwareType", zUe = "regionPrefix", $Fe = "bucketAliasSuffix", V3 = "outpostId", mp = "isValidHostLabel", Y3 = "sigv4a", Xg = "s3-outposts", Yl = "s3", WUe = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", KUe = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", FFe = "https://{Bucket}.s3.{partitionResult#dnsSuffix}", QUe = "aws.parseArn", YUe = "bucketArn", XUe = "arnType", Vb = "", X3 = "s3-object-lambda", JUe = "accesspoint", J3 = "accessPointName", UFe = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}", HFe = "mrapPartition", GFe = "outpostType", jFe = "arnPrefix", ZUe = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", qFe = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", VFe = "https://s3.{partitionResult#dnsSuffix}", Wl = { [W3]: !1, [_]: "string" }, Kl = { [W3]: !0, default: !1, [_]: "boolean" }, Vg = { [W3]: !1, [_]: "boolean" }, Vn = { [v]: Er, [P]: [{ [de]: "Accelerate" }, !0] }, Gt = { [v]: Er, [P]: [{ [de]: "UseFIPS" }, !0] }, Ot = { [v]: Er, [P]: [{ [de]: "UseDualStack" }, !0] }, xr = { [v]: an, [P]: [{ [de]: "Endpoint" }] }, e1e = { [v]: Gb, [P]: [{ [de]: "Region" }], [ke]: "partitionResult" }, zFe = { [v]: rt, [P]: [{ [v]: or, [P]: [{ [de]: "partitionResult" }, nr] }, "aws-cn"] }, Wg = { [v]: an, [P]: [{ [de]: "Bucket" }] }, Je = { [de]: "Bucket" }, WFe = { [A]: [Vn], [ce]: "S3Express does not support S3 Accelerate.", [_]: ce }, KFe = { [A]: [xr, { [v]: Q3, [P]: [{ [de]: "Endpoint" }], [ke]: "url" }], [U]: [{ [A]: [{ [v]: an, [P]: [{ [de]: "DisableS3ExpressSessionAuth" }] }, { [v]: Er, [P]: [{ [de]: "DisableS3ExpressSessionAuth" }, !0] }], [U]: [{ [A]: [{ [v]: Er, [P]: [{ [v]: or, [P]: [{ [de]: "url" }, "isIp"] }, !0] }], [U]: [{ [A]: [{ [v]: "uriEncode", [P]: [Je], [ke]: "uri_encoded_bucket" }], [U]: [{ [z]: { [oe]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [ne]: { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: "s3express", [so]: "{Region}" }] }, [se]: {} }, [_]: z }], [_]: H }], [_]: H }, { [A]: [{ [v]: jb, [P]: [Je, !1] }], [U]: [{ [z]: { [oe]: qb, [ne]: { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: "s3express", [so]: "{Region}" }] }, [se]: {} }, [_]: z }], [_]: H }, { [ce]: "S3Express bucket name is not a valid virtual hostable name.", [_]: ce }], [_]: H }, { [A]: [{ [v]: Er, [P]: [{ [v]: or, [P]: [{ [de]: "url" }, "isIp"] }, !0] }], [U]: [{ [A]: [{ [v]: "uriEncode", [P]: [Je], [ke]: "uri_encoded_bucket" }], [U]: [{ [z]: { [oe]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [ne]: { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4-s3express", [br]: "s3express", [so]: "{Region}" }] }, [se]: {} }, [_]: z }], [_]: H }], [_]: H }, { [A]: [{ [v]: jb, [P]: [Je, !1] }], [U]: [{ [z]: { [oe]: qb, [ne]: { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4-s3express", [br]: "s3express", [so]: "{Region}" }] }, [se]: {} }, [_]: z }], [_]: H }, { [ce]: "S3Express bucket name is not a valid virtual hostable name.", [_]: ce }], [_]: H }, Ro = { [v]: Q3, [P]: [{ [de]: "Endpoint" }], [ke]: "url" }, C3 = { [v]: Er, [P]: [{ [v]: or, [P]: [{ [de]: "url" }, "isIp"] }, !0] }, t1e = { [de]: "url" }, r1e = { [v]: "uriEncode", [P]: [Je], [ke]: "uri_encoded_bucket" }, sn = { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: "s3express", [so]: "{Region}" }] }, Te = {}, o1e = { [v]: jb, [P]: [Je, !1] }, QFe = { [ce]: "S3Express bucket name is not a valid virtual hostable name.", [_]: ce }, YFe = { [v]: an, [P]: [{ [de]: "UseS3ExpressControlEndpoint" }] }, XFe = { [v]: Er, [P]: [{ [de]: "UseS3ExpressControlEndpoint" }, !0] }, Pe = { [v]: ti, [P]: [xr] }, Ve = { [v]: Er, [P]: [{ [de]: "UseDualStack" }, !1] }, $e = { [v]: Er, [P]: [{ [de]: "UseFIPS" }, !1] }, Mb = { [ce]: "Unrecognized S3Express bucket name format.", [_]: ce }, JFe = { [v]: ti, [P]: [Wg] }, ZFe = { [de]: VUe }, eUe = { [A]: [Pe], [ce]: "Expected a endpoint to be specified but no endpoint was found", [_]: ce }, $b = { [Jr]: [{ [wr]: !0, [nr]: Y3, [br]: Xg, [K3]: ["*"] }, { [wr]: !0, [nr]: "sigv4", [br]: Xg, [so]: "{Region}" }] }, R3 = { [v]: Er, [P]: [{ [de]: "ForcePathStyle" }, !1] }, UAt = { [de]: "ForcePathStyle" }, Tr = { [v]: Er, [P]: [{ [de]: "Accelerate" }, !1] }, Dr = { [v]: rt, [P]: [{ [de]: "Region" }, "aws-global"] }, Qr = { [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: Yl, [so]: "us-east-1" }] }, Ke = { [v]: ti, [P]: [Dr] }, Yr = { [v]: Er, [P]: [{ [de]: "UseGlobalEndpoint" }, !0] }, tUe = { [oe]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: { [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: Yl, [so]: "{Region}" }] }, [se]: {} }, Ir = { [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: Yl, [so]: "{Region}" }] }, Xr = { [v]: Er, [P]: [{ [de]: "UseGlobalEndpoint" }, !1] }, rUe = { [oe]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [ne]: Ir, [se]: {} }, oUe = { [oe]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [ne]: Ir, [se]: {} }, nUe = { [oe]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: Ir, [se]: {} }, A3 = { [v]: Er, [P]: [{ [v]: or, [P]: [t1e, "isIp"] }, !1] }, T3 = { [oe]: WUe, [ne]: Ir, [se]: {} }, z3 = { [oe]: qb, [ne]: Ir, [se]: {} }, sUe = { [z]: z3, [_]: z }, w3 = { [oe]: KUe, [ne]: Ir, [se]: {} }, iUe = { [oe]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [ne]: Ir, [se]: {} }, Fb = { [ce]: "Invalid region: region was not a valid DNS name.", [_]: ce }, Ho = { [de]: YUe }, n1e = { [de]: XUe }, b3 = { [v]: or, [P]: [Ho, "service"] }, Z3 = { [de]: J3 }, aUe = { [A]: [Ot], [ce]: "S3 Object Lambda does not support Dual-stack", [_]: ce }, cUe = { [A]: [Vn], [ce]: "S3 Object Lambda does not support S3 Accelerate", [_]: ce }, pUe = { [A]: [{ [v]: an, [P]: [{ [de]: "DisableAccessPoints" }] }, { [v]: Er, [P]: [{ [de]: "DisableAccessPoints" }, !0] }], [ce]: "Access points are not supported for this operation", [_]: ce }, I3 = { [A]: [{ [v]: an, [P]: [{ [de]: "UseArnRegion" }] }, { [v]: Er, [P]: [{ [de]: "UseArnRegion" }, !1] }, { [v]: ti, [P]: [{ [v]: rt, [P]: [{ [v]: or, [P]: [Ho, "region"] }, "{Region}"] }] }], [ce]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [_]: ce }, s1e = { [v]: or, [P]: [{ [de]: "bucketPartition" }, nr] }, i1e = { [v]: or, [P]: [Ho, "accountId"] }, v3 = { [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: X3, [so]: "{bucketArn#region}" }] }, uUe = { [ce]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [_]: ce }, P3 = { [ce]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [_]: ce }, O3 = { [ce]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [_]: ce }, D3 = { [ce]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [_]: ce }, mUe = { [ce]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [_]: ce }, lUe = { [ce]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [_]: ce }, zg = { [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: Yl, [so]: "{bucketArn#region}" }] }, dUe = { [Jr]: [{ [wr]: !0, [nr]: Y3, [br]: Xg, [K3]: ["*"] }, { [wr]: !0, [nr]: "sigv4", [br]: Xg, [so]: "{bucketArn#region}" }] }, fUe = { [v]: QUe, [P]: [Je] }, hUe = { [oe]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: Ir, [se]: {} }, gUe = { [oe]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: Ir, [se]: {} }, xUe = { [oe]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: Ir, [se]: {} }, k3 = { [oe]: ZUe, [ne]: Ir, [se]: {} }, EUe = { [oe]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: Ir, [se]: {} }, yUe = { [de]: "UseObjectLambdaEndpoint" }, N3 = { [Jr]: [{ [wr]: !0, [nr]: "sigv4", [br]: X3, [so]: "{Region}" }] }, SUe = { [oe]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: Ir, [se]: {} }, _Ue = { [oe]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [ne]: Ir, [se]: {} }, CUe = { [oe]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: Ir, [se]: {} }, B3 = { [oe]: Hb, [ne]: Ir, [se]: {} }, RUe = { [oe]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [ne]: Ir, [se]: {} }, L3 = [{ [de]: "Region" }], HAt = [{ [de]: "Endpoint" }], GAt = [Je], M3 = [Vn], Ql = [xr, Ro], AUe = [{ [v]: an, [P]: [{ [de]: "DisableS3ExpressSessionAuth" }] }, { [v]: Er, [P]: [{ [de]: "DisableS3ExpressSessionAuth" }, !0] }], jAt = [r1e], $3 = [o1e], qn = [e1e], F3 = [Gt, Ot], Kg = [Gt, Ve], Qg = [$e, Ot], Yg = [$e, Ve], TUe = [{ [v]: Lt, [P]: [Je, 6, 14, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 14, 16, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], Zs = [{ [A]: [Gt, Ot], [z]: { [oe]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: sn, [se]: {} }, [_]: z }, { [A]: Kg, [z]: { [oe]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [ne]: sn, [se]: {} }, [_]: z }, { [A]: Qg, [z]: { [oe]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: sn, [se]: {} }, [_]: z }, { [A]: Yg, [z]: { [oe]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [ne]: sn, [se]: {} }, [_]: z }], wUe = [{ [v]: Lt, [P]: [Je, 6, 15, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 15, 17, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], bUe = [{ [v]: Lt, [P]: [Je, 6, 19, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 19, 21, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], IUe = [{ [v]: Lt, [P]: [Je, 6, 20, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 20, 22, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], vUe = [{ [v]: Lt, [P]: [Je, 6, 26, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 26, 28, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], ei = [{ [A]: [Gt, Ot], [z]: { [oe]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4-s3express", [br]: "s3express", [so]: "{Region}" }] }, [se]: {} }, [_]: z }, { [A]: Kg, [z]: { [oe]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [ne]: { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4-s3express", [br]: "s3express", [so]: "{Region}" }] }, [se]: {} }, [_]: z }, { [A]: Qg, [z]: { [oe]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4-s3express", [br]: "s3express", [so]: "{Region}" }] }, [se]: {} }, [_]: z }, { [A]: Yg, [z]: { [oe]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [ne]: { [ji]: "S3Express", [Jr]: [{ [wr]: !0, [nr]: "sigv4-s3express", [br]: "s3express", [so]: "{Region}" }] }, [se]: {} }, [_]: z }], PUe = [Je, 0, 7, !0], OUe = [{ [v]: Lt, [P]: [Je, 7, 15, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 15, 17, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], DUe = [{ [v]: Lt, [P]: [Je, 7, 16, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 16, 18, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], kUe = [{ [v]: Lt, [P]: [Je, 7, 20, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 20, 22, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], NUe = [{ [v]: Lt, [P]: [Je, 7, 21, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 21, 23, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], BUe = [{ [v]: Lt, [P]: [Je, 7, 27, !0], [ke]: "s3expressAvailabilityZoneId" }, { [v]: Lt, [P]: [Je, 27, 29, !0], [ke]: "s3expressAvailabilityZoneDelim" }, { [v]: rt, [P]: [{ [de]: "s3expressAvailabilityZoneDelim" }, "--"] }], qAt = [Wg], LUe = [{ [v]: mp, [P]: [{ [de]: V3 }, !1] }], MUe = [{ [v]: rt, [P]: [{ [de]: zUe }, "beta"] }], VAt = ["*"], $Ue = [{ [v]: mp, [P]: [{ [de]: "Region" }, !1] }], Xa = [{ [v]: rt, [P]: [{ [de]: "Region" }, "us-east-1"] }], U3 = [{ [v]: rt, [P]: [n1e, JUe] }], FUe = [{ [v]: or, [P]: [Ho, "resourceId[1]"], [ke]: J3 }, { [v]: ti, [P]: [{ [v]: rt, [P]: [Z3, Vb] }] }], zAt = [Ho, "resourceId[1]"], UUe = [Ot], H3 = [{ [v]: ti, [P]: [{ [v]: rt, [P]: [{ [v]: or, [P]: [Ho, "region"] }, Vb] }] }], HUe = [{ [v]: ti, [P]: [{ [v]: an, [P]: [{ [v]: or, [P]: [Ho, "resourceId[2]"] }] }] }], WAt = [Ho, "resourceId[2]"], G3 = [{ [v]: Gb, [P]: [{ [v]: or, [P]: [Ho, "region"] }], [ke]: "bucketPartition" }], GUe = [{ [v]: rt, [P]: [s1e, { [v]: or, [P]: [{ [de]: "partitionResult" }, nr] }] }], j3 = [{ [v]: mp, [P]: [{ [v]: or, [P]: [Ho, "region"] }, !0] }], q3 = [{ [v]: mp, [P]: [i1e, !1] }], jUe = [{ [v]: mp, [P]: [Z3, !1] }], Ub = [Gt], qUe = [{ [v]: mp, [P]: [{ [de]: "Region" }, !0] }], KAt = { version: "1.0", parameters: { Bucket: Wl, Region: Wl, UseFIPS: Kl, UseDualStack: Kl, Endpoint: Wl, ForcePathStyle: Kl, Accelerate: Kl, UseGlobalEndpoint: Kl, UseObjectLambdaEndpoint: Vg, Key: Wl, Prefix: Wl, CopySource: Wl, DisableAccessPoints: Vg, DisableMultiRegionAccessPoints: Kl, UseArnRegion: Vg, UseS3ExpressControlEndpoint: Vg, DisableS3ExpressSessionAuth: Vg }, [U]: [{ [A]: [{ [v]: an, [P]: L3 }], [U]: [{ [A]: [Vn, Gt], error: "Accelerate cannot be used with FIPS", [_]: ce }, { [A]: [Ot, xr], error: "Cannot set dual-stack in combination with a custom endpoint.", [_]: ce }, { [A]: [xr, Gt], error: "A custom endpoint cannot be combined with FIPS", [_]: ce }, { [A]: [xr, Vn], error: "A custom endpoint cannot be combined with S3 Accelerate", [_]: ce }, { [A]: [Gt, e1e, zFe], error: "Partition does not support FIPS", [_]: ce }, { [A]: [Wg, { [v]: Lt, [P]: [Je, 0, 6, !0], [ke]: LFe }, { [v]: rt, [P]: [{ [de]: LFe }, "--x-s3"] }], [U]: [WFe, KFe, { [A]: [YFe, XFe], [U]: [{ [A]: qn, [U]: [{ [A]: [r1e, Pe], [U]: [{ [A]: F3, endpoint: { [oe]: "https://s3express-control-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: sn, [se]: Te }, [_]: z }, { [A]: Kg, endpoint: { [oe]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: sn, [se]: Te }, [_]: z }, { [A]: Qg, endpoint: { [oe]: "https://s3express-control.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: sn, [se]: Te }, [_]: z }, { [A]: Yg, endpoint: { [oe]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: sn, [se]: Te }, [_]: z }], [_]: H }], [_]: H }], [_]: H }, { [A]: $3, [U]: [{ [A]: qn, [U]: [{ [A]: AUe, [U]: [{ [A]: TUe, [U]: Zs, [_]: H }, { [A]: wUe, [U]: Zs, [_]: H }, { [A]: bUe, [U]: Zs, [_]: H }, { [A]: IUe, [U]: Zs, [_]: H }, { [A]: vUe, [U]: Zs, [_]: H }, Mb], [_]: H }, { [A]: TUe, [U]: ei, [_]: H }, { [A]: wUe, [U]: ei, [_]: H }, { [A]: bUe, [U]: ei, [_]: H }, { [A]: IUe, [U]: ei, [_]: H }, { [A]: vUe, [U]: ei, [_]: H }, Mb], [_]: H }], [_]: H }, QFe], [_]: H }, { [A]: [Wg, { [v]: Lt, [P]: PUe, [ke]: MFe }, { [v]: rt, [P]: [{ [de]: MFe }, "--xa-s3"] }], [U]: [WFe, KFe, { [A]: $3, [U]: [{ [A]: qn, [U]: [{ [A]: AUe, [U]: [{ [A]: OUe, [U]: Zs, [_]: H }, { [A]: DUe, [U]: Zs, [_]: H }, { [A]: kUe, [U]: Zs, [_]: H }, { [A]: NUe, [U]: Zs, [_]: H }, { [A]: BUe, [U]: Zs, [_]: H }, Mb], [_]: H }, { [A]: OUe, [U]: ei, [_]: H }, { [A]: DUe, [U]: ei, [_]: H }, { [A]: kUe, [U]: ei, [_]: H }, { [A]: NUe, [U]: ei, [_]: H }, { [A]: BUe, [U]: ei, [_]: H }, Mb], [_]: H }], [_]: H }, QFe], [_]: H }, { [A]: [JFe, YFe, XFe], [U]: [{ [A]: qn, [U]: [{ [A]: Ql, endpoint: { [oe]: Hb, [ne]: sn, [se]: Te }, [_]: z }, { [A]: F3, endpoint: { [oe]: "https://s3express-control-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: sn, [se]: Te }, [_]: z }, { [A]: Kg, endpoint: { [oe]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}", [ne]: sn, [se]: Te }, [_]: z }, { [A]: Qg, endpoint: { [oe]: "https://s3express-control.dualstack.{Region}.{partitionResult#dnsSuffix}", [ne]: sn, [se]: Te }, [_]: z }, { [A]: Yg, endpoint: { [oe]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}", [ne]: sn, [se]: Te }, [_]: z }], [_]: H }], [_]: H }, { [A]: [Wg, { [v]: Lt, [P]: [Je, 49, 50, !0], [ke]: VUe }, { [v]: Lt, [P]: [Je, 8, 12, !0], [ke]: zUe }, { [v]: Lt, [P]: PUe, [ke]: $Fe }, { [v]: Lt, [P]: [Je, 32, 49, !0], [ke]: V3 }, { [v]: Gb, [P]: L3, [ke]: "regionPartition" }, { [v]: rt, [P]: [{ [de]: $Fe }, "--op-s3"] }], [U]: [{ [A]: LUe, [U]: [{ [A]: $3, [U]: [{ [A]: [{ [v]: rt, [P]: [ZFe, "e"] }], [U]: [{ [A]: MUe, [U]: [eUe, { [A]: Ql, endpoint: { [oe]: "https://{Bucket}.ec2.{url#authority}", [ne]: $b, [se]: Te }, [_]: z }], [_]: H }, { endpoint: { [oe]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [ne]: $b, [se]: Te }, [_]: z }], [_]: H }, { [A]: [{ [v]: rt, [P]: [ZFe, "o"] }], [U]: [{ [A]: MUe, [U]: [eUe, { [A]: Ql, endpoint: { [oe]: "https://{Bucket}.op-{outpostId}.{url#authority}", [ne]: $b, [se]: Te }, [_]: z }], [_]: H }, { endpoint: { [oe]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [ne]: $b, [se]: Te }, [_]: z }], [_]: H }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [_]: ce }], [_]: H }, { error: "Invalid Outposts Bucket alias - it must be a valid bucket name.", [_]: ce }], [_]: H }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [_]: ce }], [_]: H }, { [A]: qAt, [U]: [{ [A]: [xr, { [v]: ti, [P]: [{ [v]: an, [P]: [{ [v]: Q3, [P]: HAt }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [_]: ce }, { [A]: [R3, o1e], [U]: [{ [A]: qn, [U]: [{ [A]: $Ue, [U]: [{ [A]: [Vn, zFe], error: "S3 Accelerate cannot be used in this region", [_]: ce }, { [A]: [Ot, Gt, Tr, Pe, Dr], endpoint: { [oe]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ot, Gt, Tr, Pe, Ke, Yr], [U]: [{ endpoint: tUe, [_]: z }], [_]: H }, { [A]: [Ot, Gt, Tr, Pe, Ke, Xr], endpoint: tUe, [_]: z }, { [A]: [Ve, Gt, Tr, Pe, Dr], endpoint: { [oe]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ve, Gt, Tr, Pe, Ke, Yr], [U]: [{ endpoint: rUe, [_]: z }], [_]: H }, { [A]: [Ve, Gt, Tr, Pe, Ke, Xr], endpoint: rUe, [_]: z }, { [A]: [Ot, $e, Vn, Pe, Dr], endpoint: { [oe]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ot, $e, Vn, Pe, Ke, Yr], [U]: [{ endpoint: oUe, [_]: z }], [_]: H }, { [A]: [Ot, $e, Vn, Pe, Ke, Xr], endpoint: oUe, [_]: z }, { [A]: [Ot, $e, Tr, Pe, Dr], endpoint: { [oe]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ot, $e, Tr, Pe, Ke, Yr], [U]: [{ endpoint: nUe, [_]: z }], [_]: H }, { [A]: [Ot, $e, Tr, Pe, Ke, Xr], endpoint: nUe, [_]: z }, { [A]: [Ve, $e, Tr, xr, Ro, C3, Dr], endpoint: { [oe]: WUe, [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ve, $e, Tr, xr, Ro, A3, Dr], endpoint: { [oe]: qb, [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ve, $e, Tr, xr, Ro, C3, Ke, Yr], [U]: [{ [A]: Xa, endpoint: T3, [_]: z }, { endpoint: T3, [_]: z }], [_]: H }, { [A]: [Ve, $e, Tr, xr, Ro, A3, Ke, Yr], [U]: [{ [A]: Xa, endpoint: z3, [_]: z }, sUe], [_]: H }, { [A]: [Ve, $e, Tr, xr, Ro, C3, Ke, Xr], endpoint: T3, [_]: z }, { [A]: [Ve, $e, Tr, xr, Ro, A3, Ke, Xr], endpoint: z3, [_]: z }, { [A]: [Ve, $e, Vn, Pe, Dr], endpoint: { [oe]: KUe, [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ve, $e, Vn, Pe, Ke, Yr], [U]: [{ [A]: Xa, endpoint: w3, [_]: z }, { endpoint: w3, [_]: z }], [_]: H }, { [A]: [Ve, $e, Vn, Pe, Ke, Xr], endpoint: w3, [_]: z }, { [A]: [Ve, $e, Tr, Pe, Dr], endpoint: { [oe]: FFe, [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ve, $e, Tr, Pe, Ke, Yr], [U]: [{ [A]: Xa, endpoint: { [oe]: FFe, [ne]: Ir, [se]: Te }, [_]: z }, { endpoint: iUe, [_]: z }], [_]: H }, { [A]: [Ve, $e, Tr, Pe, Ke, Xr], endpoint: iUe, [_]: z }], [_]: H }, Fb], [_]: H }], [_]: H }, { [A]: [xr, Ro, { [v]: rt, [P]: [{ [v]: or, [P]: [t1e, "scheme"] }, "http"] }, { [v]: jb, [P]: [Je, !0] }, R3, $e, Ve, Tr], [U]: [{ [A]: qn, [U]: [{ [A]: $Ue, [U]: [sUe], [_]: H }, Fb], [_]: H }], [_]: H }, { [A]: [R3, { [v]: QUe, [P]: GAt, [ke]: YUe }], [U]: [{ [A]: [{ [v]: or, [P]: [Ho, "resourceId[0]"], [ke]: XUe }, { [v]: ti, [P]: [{ [v]: rt, [P]: [n1e, Vb] }] }], [U]: [{ [A]: [{ [v]: rt, [P]: [b3, X3] }], [U]: [{ [A]: U3, [U]: [{ [A]: FUe, [U]: [aUe, cUe, { [A]: H3, [U]: [pUe, { [A]: HUe, [U]: [I3, { [A]: G3, [U]: [{ [A]: qn, [U]: [{ [A]: GUe, [U]: [{ [A]: j3, [U]: [{ [A]: [{ [v]: rt, [P]: [i1e, Vb] }], error: "Invalid ARN: Missing account id", [_]: ce }, { [A]: q3, [U]: [{ [A]: jUe, [U]: [{ [A]: Ql, endpoint: { [oe]: UFe, [ne]: v3, [se]: Te }, [_]: z }, { [A]: Ub, endpoint: { [oe]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ne]: v3, [se]: Te }, [_]: z }, { endpoint: { [oe]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ne]: v3, [se]: Te }, [_]: z }], [_]: H }, uUe], [_]: H }, P3], [_]: H }, O3], [_]: H }, D3], [_]: H }], [_]: H }], [_]: H }, mUe], [_]: H }, { error: "Invalid ARN: bucket ARN is missing a region", [_]: ce }], [_]: H }, lUe], [_]: H }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [_]: ce }], [_]: H }, { [A]: U3, [U]: [{ [A]: FUe, [U]: [{ [A]: H3, [U]: [{ [A]: U3, [U]: [{ [A]: H3, [U]: [pUe, { [A]: HUe, [U]: [I3, { [A]: G3, [U]: [{ [A]: qn, [U]: [{ [A]: [{ [v]: rt, [P]: [s1e, "{partitionResult#name}"] }], [U]: [{ [A]: j3, [U]: [{ [A]: [{ [v]: rt, [P]: [b3, Yl] }], [U]: [{ [A]: q3, [U]: [{ [A]: jUe, [U]: [{ [A]: M3, error: "Access Points do not support S3 Accelerate", [_]: ce }, { [A]: F3, endpoint: { [oe]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ne]: zg, [se]: Te }, [_]: z }, { [A]: Kg, endpoint: { [oe]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ne]: zg, [se]: Te }, [_]: z }, { [A]: Qg, endpoint: { [oe]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ne]: zg, [se]: Te }, [_]: z }, { [A]: [$e, Ve, xr, Ro], endpoint: { [oe]: UFe, [ne]: zg, [se]: Te }, [_]: z }, { [A]: Yg, endpoint: { [oe]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ne]: zg, [se]: Te }, [_]: z }], [_]: H }, uUe], [_]: H }, P3], [_]: H }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [_]: ce }], [_]: H }, O3], [_]: H }, D3], [_]: H }], [_]: H }], [_]: H }, mUe], [_]: H }], [_]: H }], [_]: H }, { [A]: [{ [v]: mp, [P]: [Z3, !0] }], [U]: [{ [A]: UUe, error: "S3 MRAP does not support dual-stack", [_]: ce }, { [A]: Ub, error: "S3 MRAP does not support FIPS", [_]: ce }, { [A]: M3, error: "S3 MRAP does not support S3 Accelerate", [_]: ce }, { [A]: [{ [v]: Er, [P]: [{ [de]: "DisableMultiRegionAccessPoints" }, !0] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [_]: ce }, { [A]: [{ [v]: Gb, [P]: L3, [ke]: HFe }], [U]: [{ [A]: [{ [v]: rt, [P]: [{ [v]: or, [P]: [{ [de]: HFe }, nr] }, { [v]: or, [P]: [Ho, "partition"] }] }], [U]: [{ endpoint: { [oe]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [ne]: { [Jr]: [{ [wr]: !0, name: Y3, [br]: Yl, [K3]: VAt }] }, [se]: Te }, [_]: z }], [_]: H }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [_]: ce }], [_]: H }], [_]: H }, { error: "Invalid Access Point Name", [_]: ce }], [_]: H }, lUe], [_]: H }, { [A]: [{ [v]: rt, [P]: [b3, Xg] }], [U]: [{ [A]: UUe, error: "S3 Outposts does not support Dual-stack", [_]: ce }, { [A]: Ub, error: "S3 Outposts does not support FIPS", [_]: ce }, { [A]: M3, error: "S3 Outposts does not support S3 Accelerate", [_]: ce }, { [A]: [{ [v]: an, [P]: [{ [v]: or, [P]: [Ho, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [_]: ce }, { [A]: [{ [v]: or, [P]: zAt, [ke]: V3 }], [U]: [{ [A]: LUe, [U]: [I3, { [A]: G3, [U]: [{ [A]: qn, [U]: [{ [A]: GUe, [U]: [{ [A]: j3, [U]: [{ [A]: q3, [U]: [{ [A]: [{ [v]: or, [P]: WAt, [ke]: GFe }], [U]: [{ [A]: [{ [v]: or, [P]: [Ho, "resourceId[3]"], [ke]: J3 }], [U]: [{ [A]: [{ [v]: rt, [P]: [{ [de]: GFe }, JUe] }], [U]: [{ [A]: Ql, endpoint: { [oe]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [ne]: dUe, [se]: Te }, [_]: z }, { endpoint: { [oe]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ne]: dUe, [se]: Te }, [_]: z }], [_]: H }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [_]: ce }], [_]: H }, { error: "Invalid ARN: expected an access point name", [_]: ce }], [_]: H }, { error: "Invalid ARN: Expected a 4-component resource", [_]: ce }], [_]: H }, P3], [_]: H }, O3], [_]: H }, D3], [_]: H }], [_]: H }], [_]: H }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [_]: ce }], [_]: H }, { error: "Invalid ARN: The Outpost Id was not set", [_]: ce }], [_]: H }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [_]: ce }], [_]: H }, { error: "Invalid ARN: No ARN type specified", [_]: ce }], [_]: H }, { [A]: [{ [v]: Lt, [P]: [Je, 0, 4, !1], [ke]: jFe }, { [v]: rt, [P]: [{ [de]: jFe }, "arn:"] }, { [v]: ti, [P]: [{ [v]: an, [P]: [fUe] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [_]: ce }, { [A]: [{ [v]: Er, [P]: [UAt, !0] }, fUe], error: "Path-style addressing cannot be used with ARN buckets", [_]: ce }, { [A]: jAt, [U]: [{ [A]: qn, [U]: [{ [A]: [Tr], [U]: [{ [A]: [Ot, Pe, Gt, Dr], endpoint: { [oe]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ot, Pe, Gt, Ke, Yr], [U]: [{ endpoint: hUe, [_]: z }], [_]: H }, { [A]: [Ot, Pe, Gt, Ke, Xr], endpoint: hUe, [_]: z }, { [A]: [Ve, Pe, Gt, Dr], endpoint: { [oe]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ve, Pe, Gt, Ke, Yr], [U]: [{ endpoint: gUe, [_]: z }], [_]: H }, { [A]: [Ve, Pe, Gt, Ke, Xr], endpoint: gUe, [_]: z }, { [A]: [Ot, Pe, $e, Dr], endpoint: { [oe]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ot, Pe, $e, Ke, Yr], [U]: [{ endpoint: xUe, [_]: z }], [_]: H }, { [A]: [Ot, Pe, $e, Ke, Xr], endpoint: xUe, [_]: z }, { [A]: [Ve, xr, Ro, $e, Dr], endpoint: { [oe]: ZUe, [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ve, xr, Ro, $e, Ke, Yr], [U]: [{ [A]: Xa, endpoint: k3, [_]: z }, { endpoint: k3, [_]: z }], [_]: H }, { [A]: [Ve, xr, Ro, $e, Ke, Xr], endpoint: k3, [_]: z }, { [A]: [Ve, Pe, $e, Dr], endpoint: { [oe]: qFe, [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Ve, Pe, $e, Ke, Yr], [U]: [{ [A]: Xa, endpoint: { [oe]: qFe, [ne]: Ir, [se]: Te }, [_]: z }, { endpoint: EUe, [_]: z }], [_]: H }, { [A]: [Ve, Pe, $e, Ke, Xr], endpoint: EUe, [_]: z }], [_]: H }, { error: "Path-style addressing cannot be used with S3 Accelerate", [_]: ce }], [_]: H }], [_]: H }], [_]: H }, { [A]: [{ [v]: an, [P]: [yUe] }, { [v]: Er, [P]: [yUe, !0] }], [U]: [{ [A]: qn, [U]: [{ [A]: qUe, [U]: [aUe, cUe, { [A]: Ql, endpoint: { [oe]: Hb, [ne]: N3, [se]: Te }, [_]: z }, { [A]: Ub, endpoint: { [oe]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [ne]: N3, [se]: Te }, [_]: z }, { endpoint: { [oe]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [ne]: N3, [se]: Te }, [_]: z }], [_]: H }, Fb], [_]: H }], [_]: H }, { [A]: [JFe], [U]: [{ [A]: qn, [U]: [{ [A]: qUe, [U]: [{ [A]: [Gt, Ot, Pe, Dr], endpoint: { [oe]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Gt, Ot, Pe, Ke, Yr], [U]: [{ endpoint: SUe, [_]: z }], [_]: H }, { [A]: [Gt, Ot, Pe, Ke, Xr], endpoint: SUe, [_]: z }, { [A]: [Gt, Ve, Pe, Dr], endpoint: { [oe]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [Gt, Ve, Pe, Ke, Yr], [U]: [{ endpoint: _Ue, [_]: z }], [_]: H }, { [A]: [Gt, Ve, Pe, Ke, Xr], endpoint: _Ue, [_]: z }, { [A]: [$e, Ot, Pe, Dr], endpoint: { [oe]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [$e, Ot, Pe, Ke, Yr], [U]: [{ endpoint: CUe, [_]: z }], [_]: H }, { [A]: [$e, Ot, Pe, Ke, Xr], endpoint: CUe, [_]: z }, { [A]: [$e, Ve, xr, Ro, Dr], endpoint: { [oe]: Hb, [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [$e, Ve, xr, Ro, Ke, Yr], [U]: [{ [A]: Xa, endpoint: B3, [_]: z }, { endpoint: B3, [_]: z }], [_]: H }, { [A]: [$e, Ve, xr, Ro, Ke, Xr], endpoint: B3, [_]: z }, { [A]: [$e, Ve, Pe, Dr], endpoint: { [oe]: VFe, [ne]: Qr, [se]: Te }, [_]: z }, { [A]: [$e, Ve, Pe, Ke, Yr], [U]: [{ [A]: Xa, endpoint: { [oe]: VFe, [ne]: Ir, [se]: Te }, [_]: z }, { endpoint: RUe, [_]: z }], [_]: H }, { [A]: [$e, Ve, Pe, Ke, Xr], endpoint: RUe, [_]: z }], [_]: H }, Fb], [_]: H }], [_]: H }], [_]: H }, { error: "A region must be set when sending requests to S3.", [_]: ce }] }, a1e = KAt }); var QAt, zb, eH = s(() => { Jw(); Ft(); c1e(); QAt = new Rr({ size: 50, params: ["Accelerate", "Bucket", "DisableAccessPoints", "DisableMultiRegionAccessPoints", "DisableS3ExpressSessionAuth", "Endpoint", "ForcePathStyle", "Region", "UseArnRegion", "UseDualStack", "UseFIPS", "UseGlobalEndpoint", "UseObjectLambdaEndpoint", "UseS3ExpressControlEndpoint"] }), zb = (e, t = {}) => QAt.get(e, () => Ur(a1e, { endpointParams: e, logger: t.logger })); Rt.aws = Ng }); function u1e(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "s3", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } function m1e(e) { return { schemeId: "aws.auth#sigv4a", signingProperties: { name: "s3", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } var YAt, XAt, p1e, JAt, ZAt, l1e, d1e, tH = s(() => { Ye(); _3(); V(); gt(); eH(); YAt = e => async (t, r, o) => { if (!o) throw new Error("Could not find `input` for `defaultEndpointRuleSetHttpAuthSchemeParametersProvider`"); let n = await e(t, r, o), i = je(r)?.commandInstance?.constructor?.getEndpointParameterInstructions; if (!i) throw new Error(`getEndpointParameterInstructions() is not defined on '${r.commandName}'`); let a = await u3(o, { getEndpointParameterInstructions: i }, t); return Object.assign(n, a) }, XAt = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }), p1e = YAt(XAt); JAt = (e, t, r) => n => { let a = e(n).properties?.authSchemes; if (!a) return t(n); let c = []; for (let p of a) { let { name: u, properties: l = {}, ...m } = p, f = u.toLowerCase(); u !== f && console.warn(`HttpAuthScheme has been normalized with lowercasing: '${u}' to '${f}'`); let h; if (f === "sigv4a") { h = "aws.auth#sigv4a"; let y = a.find(C => { let b = C.name.toLowerCase(); return b !== "sigv4a" && b.startsWith("sigv4") }); if (zl.sigv4aDependency() === "none" && y) continue } else if (f.startsWith("sigv4")) h = "aws.auth#sigv4"; else throw new Error(`Unknown HttpAuthScheme found in '@smithy.rules#endpointRuleSet': '${f}'`); let E = r[h]; if (!E) throw new Error(`Could not find HttpAuthOption create function for '${h}'`); let S = E(n); S.schemeId = h, S.signingProperties = { ...S.signingProperties || {}, ...m, ...l }, c.push(S) } return c }, ZAt = e => { let t = []; switch (e.operation) { default: t.push(u1e(e)), t.push(m1e(e)) }return t }, l1e = JAt(zb, ZAt, { "aws.auth#sigv4": u1e, "aws.auth#sigv4a": m1e }), d1e = e => { let t = qr(e), r = gQ(t); return Object.assign(r, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var f1e, w, K = s(() => { f1e = e => Object.assign(e, { useFipsEndpoint: e.useFipsEndpoint ?? !1, useDualstackEndpoint: e.useDualstackEndpoint ?? !1, forcePathStyle: e.forcePathStyle ?? !1, useAccelerateEndpoint: e.useAccelerateEndpoint ?? !1, useGlobalEndpoint: e.useGlobalEndpoint ?? !1, disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? !1, defaultSigningName: "s3", clientContextParams: e.clientContextParams ?? {} }), w = { ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" }, UseArnRegion: { type: "clientContextParams", name: "useArnRegion" }, DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" }, Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" }, DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" }, UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" }, UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" } } }); var kr, rH = s(() => { F(); kr = class e extends Vl { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var Wb, Kb, Qb, Yb, Xb, Jb, Zb, e0, t0, r0, o0, n0, s0, i0, oH = s(() => { rH(); Wb = class e extends kr { name = "NoSuchUpload"; $fault = "client"; constructor(t) { super({ name: "NoSuchUpload", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Kb = class e extends kr { name = "ObjectNotInActiveTierError"; $fault = "client"; constructor(t) { super({ name: "ObjectNotInActiveTierError", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Qb = class e extends kr { name = "BucketAlreadyExists"; $fault = "client"; constructor(t) { super({ name: "BucketAlreadyExists", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Yb = class e extends kr { name = "BucketAlreadyOwnedByYou"; $fault = "client"; constructor(t) { super({ name: "BucketAlreadyOwnedByYou", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Xb = class e extends kr { name = "NoSuchBucket"; $fault = "client"; constructor(t) { super({ name: "NoSuchBucket", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, Jb = class e extends kr { name = "InvalidObjectState"; $fault = "client"; StorageClass; AccessTier; constructor(t) { super({ name: "InvalidObjectState", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype), this.StorageClass = t.StorageClass, this.AccessTier = t.AccessTier } }, Zb = class e extends kr { name = "NoSuchKey"; $fault = "client"; constructor(t) { super({ name: "NoSuchKey", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, e0 = class e extends kr { name = "NotFound"; $fault = "client"; constructor(t) { super({ name: "NotFound", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, t0 = class e extends kr { name = "EncryptionTypeMismatch"; $fault = "client"; constructor(t) { super({ name: "EncryptionTypeMismatch", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, r0 = class e extends kr { name = "InvalidRequest"; $fault = "client"; constructor(t) { super({ name: "InvalidRequest", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, o0 = class e extends kr { name = "InvalidWriteOffset"; $fault = "client"; constructor(t) { super({ name: "InvalidWriteOffset", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, n0 = class e extends kr { name = "TooManyParts"; $fault = "client"; constructor(t) { super({ name: "TooManyParts", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, s0 = class e extends kr { name = "IdempotencyParameterMismatch"; $fault = "client"; constructor(t) { super({ name: "IdempotencyParameterMismatch", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, i0 = class e extends kr { name = "ObjectAlreadyInActiveTierError"; $fault = "client"; constructor(t) { super({ name: "ObjectAlreadyInActiveTierError", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } } }); var eTt, tTt, a0, I0, Xl, T1e, lp, w1e, Jg, b1e, rTt, oTt, nTt, sTt, iTt, I1e, h1e, aTt, cTt, pTt, uTt, mTt, lTt, dTt, fTt, v1e, hTt, lH, P1e, c0, gTt, xTt, ETt, O1e, rx, W, dH, yTt, STt, _Tt, D1e, fH, CTt, Ao, RTt, ATt, p0, TTt, wTt, k1e, g1e, x1e, hH, N1e, B1e, ox, gH, L1e, Ze, bTt, ITt, nH, vTt, PTt, OTt, DTt, kTt, NTt, Jl, To, wo, bo, nx, BTt, sx, Zl, LTt, ix, ed, MTt, $Tt, td, ax, cx, px, tr, rr, FTt, UTt, HTt, GTt, jTt, qTt, M1e, VTt, $1e, zTt, WTt, F1e, u0, xH, EH, KTt, QTt, YTt, XTt, U1e, JTt, v0, yH, ZTt, H1e, G1e, Io, vo, j1e, q1e, V1e, z1e, ewt, twt, rwt, owt, W1e, SH, K1e, Q1e, Y1e, nwt, swt, _H, iwt, cn, ux, awt, rd, cwt, Go, X1e, pwt, uwt, J1e, mwt, E1e, od, lwt, dwt, fwt, hwt, gwt, xwt, Ewt, ywt, Swt, _wt, Cwt, Rwt, Awt, Twt, wwt, bwt, Iwt, vwt, Pwt, Owt, Dwt, kwt, Nwt, Bwt, Lwt, Mwt, $wt, Fwt, Uwt, Hwt, Gwt, jwt, qwt, Vwt, zwt, Wwt, dp, Kwt, Z1e, Qwt, e3e, CH, Ywt, Xwt, Jwt, Zwt, ebt, tbt, rbt, obt, nbt, sbt, ibt, abt, cbt, pbt, t3e, ubt, r3e, o3e, sH, mbt, Ja, P0, lbt, n3e, ri, dbt, s3e, X, mx, i3e, fbt, RH, hbt, gbt, xbt, a3e, Ebt, c3e, m0, p3e, AH, ybt, Sbt, Zr, Za, _bt, u3e, TH, Cbt, m3e, l3e, lx, wH, bH, fs, d3e, qi, f3e, Rbt, Abt, h3e, Tbt, wbt, bbt, g3e, Ibt, O0, vbt, Pbt, Obt, Dbt, kbt, Nbt, Bbt, Lbt, Mbt, $bt, Fbt, Ubt, Hbt, Gbt, jbt, qbt, Vbt, zbt, Wbt, Kbt, Qbt, Ybt, Xbt, Jbt, Zbt, e0t, t0t, r0t, o0t, n0t, s0t, i0t, a0t, c0t, p0t, u0t, x3e, m0t, l0t, d0t, f0t, h0t, E3e, g0t, x0t, E0t, y0t, S0t, _0t, C0t, R0t, A0t, T0t, w0t, b0t, I0t, v0t, P0t, O0t, D0t, k0t, N0t, B0t, L0t, M0t, $0t, F0t, U0t, H0t, G0t, nd, y3e, j0t, q0t, V0t, z0t, W0t, K0t, Q0t, Y0t, X0t, J0t, Z0t, eIt, tIt, rIt, oIt, nIt, sIt, iIt, aIt, cIt, pIt, uIt, mIt, lIt, dIt, fIt, hIt, gIt, xIt, sd, id, IH, ad, vH, PH, EIt, yIt, SIt, _It, S3e, CIt, RIt, AIt, TIt, Nr, Zg, _3e, cd, OH, wIt, bIt, IIt, vIt, C3e, pd, PIt, OIt, DIt, DH, R3e, kIt, fp, dx, ud, NIt, BIt, LIt, y1e, S1e, MIt, $It, FIt, kH, UIt, HIt, oi, GIt, ex, A3e, T3e, jIt, l0, qIt, w3e, NH, VIt, BH, zIt, b3e, WIt, KIt, d0, I3e, QIt, Ge, YIt, XIt, JIt, D0, ZIt, evt, tvt, rvt, f0, ovt, nvt, svt, ivt, avt, cvt, pvt, uvt, mvt, lvt, dvt, fvt, hvt, gvt, xvt, Evt, yvt, Svt, v3e, iH, aH, _vt, Cvt, Rvt, LH, Avt, Tvt, wvt, bvt, Ivt, h0, vvt, Pvt, ni, Ovt, Dvt, kvt, Nvt, Bvt, Lvt, MH, Mvt, $vt, Fvt, Uvt, Hvt, Gvt, jvt, qvt, Vvt, zvt, Wvt, Kvt, Qvt, Yvt, Xvt, Jvt, Zvt, ePt, md, tPt, rPt, oPt, cH, P3e, O3e, tx, nPt, sPt, D3e, k3e, iPt, $H, N3e, ld, FH, aPt, k0, pH, B3e, cPt, L3e, pPt, M3e, $3e, F3e, uPt, mPt, U3e, hp, uH, lPt, fx, H3e, dPt, G3e, fPt, j3e, q3e, hPt, gPt, xPt, EPt, V3e, yPt, SPt, _Pt, z3e, gs, CPt, RPt, g0, APt, TPt, wPt, bPt, IPt, W3e, x0, vPt, PPt, OPt, dd, fd, DPt, hd, kPt, NPt, BPt, K3e, UH, LPt, MPt, $Pt, Q3e, Y3e, FPt, HH, UPt, HPt, GPt, X3e, Mt, E0, jPt, qPt, VPt, zPt, WPt, KPt, QPt, YPt, XPt, JPt, ZPt, eOt, tOt, rOt, oOt, nOt, sOt, iOt, aOt, cOt, pOt, uOt, mOt, lOt, dOt, fOt, hOt, gOt, xOt, EOt, yOt, SOt, _Ot, COt, ROt, AOt, TOt, wOt, bOt, N0, IOt, vOt, POt, OOt, gp, B0, DOt, kOt, NOt, BOt, LOt, MOt, $Ot, FOt, UOt, HOt, GOt, jOt, qOt, VOt, zOt, WOt, KOt, QOt, y0, YOt, XOt, J3e, L0, M0, JOt, Z3e, eHe, tHe, rHe, oHe, ZOt, nHe, eDt, tDt, sHe, rDt, oDt, iHe, aHe, nDt, sDt, hx, GH, jt, cHe, pHe, uHe, mHe, lHe, S0, jH, dHe, iDt, $0, aDt, cDt, pDt, uDt, fHe, mDt, lDt, dDt, fDt, hDt, gDt, xDt, Tt, _1e, _0, hHe, qH, EDt, yDt, SDt, _Dt, CDt, mH, gHe, VH, zH, RDt, xHe, ADt, TDt, wDt, C0, WH, bDt, EHe, R0, IDt, gd, xo, yHe, C1e, vDt, PDt, SHe, Eo, _He, ODt, DDt, kDt, NDt, BDt, LDt, MDt, $Dt, FDt, UDt, CHe, RHe, HDt, GDt, jDt, qDt, VDt, zDt, WDt, KDt, AHe, A0, THe, wHe, bHe, jo, QDt, YDt, T0, Br, zn, Lr, IHe, Vi, Po, XDt, JDt, vHe, R1e, PHe, OHe, ZDt, ekt, xd, tkt, DHe, rkt, Ed, KH, okt, nkt, QH, skt, YH, ikt, akt, kHe, ckt, XH, NHe, pkt, ukt, mkt, lkt, BHe, F0, LHe, dkt, fkt, U0, MHe, Wn, hs, $He, hkt, FHe, gkt, UHe, xkt, Ekt, HHe, gx, ykt, Skt, _kt, Ckt, Rkt, ec, GHe, jHe, Akt, Tkt, wkt, bkt, Ikt, vkt, Pkt, Okt, JH, w0, _t, qHe, Dkt, kkt, b0, Nkt, Bkt, Lkt, xx, Mkt, VHe, $kt, qo, xp, H0, Vo, ZH, Fkt, G0, Ukt, Y, wt, pn, d, Hkt, ot, yd, te, zHe, Kn, Gkt, WHe, jkt, qkt, Vkt, e2, zkt, Wkt, Ex, j0, Kkt, KHe, QHe, YHe, XHe, JHe, ZHe, e2e, Qkt, t2e, yx, Ykt, zo, Xkt, r2e, Jkt, we, B, o2e, Sd, n2e, Zkt, s2e, eNt, i2e, t2, tNt, rNt, oNt, a2e, nNt, r2, Ep, yp, Sp, c2e, sNt, _p, Cp, p2e, u2e, m2e, l2e, d2e, iNt, aNt, f2e, h2e, g2e, x2e, _d, cNt, q0, Sx, J, pNt, uNt, mNt, lNt, dNt, fNt, hNt, gNt, xNt, ENt, yNt, SNt, _Nt, CNt, RNt, ANt, TNt, wNt, bNt, INt, vNt, PNt, ONt, DNt, kNt, NNt, BNt, LNt, MNt, $Nt, FNt, UNt, HNt, GNt, jNt, qNt, Cd, Rd, Ad, o2, Td, VNt, zNt, WNt, wd, n2, KNt, E2e, QNt, YNt, y2e, XNt, _x, Cx, Rx, JNt, s2, ZNt, eBt, S2e, Kt, tBt, bt, rBt, _2e, oBt, nBt, sBt, iBt, aBt, cBt, Ax, Dt, pBt, C2e, un, mn, ln, tc, eo, xs, to, i2, R2e, uBt, a2, si, mBt, Tx, lBt, g, A2e, A1e, Es, rc, io, wx, T2e, dBt, fBt, hBt, gBt, w2e, xBt, EBt, c2, yBt, SBt, _Bt, CBt, RBt, ABt, TBt, wBt, bBt, IBt, vBt, PBt, OBt, DBt, kBt, NBt, BBt, LBt, MBt, $Bt, FBt, UBt, HBt, GBt, jBt, qBt, VBt, zBt, WBt, KBt, QBt, YBt, XBt, JBt, ZBt, eLt, tLt, rLt, oLt, nLt, sLt, iLt, aLt, cLt, pLt, uLt, mLt, lLt, dLt, fLt, hLt, gLt, xLt, ELt, yLt, SLt, _Lt, CLt, RLt, ALt, TLt, wLt, bLt, ILt, vLt, PLt, OLt, DLt, p2, b2e, kLt, NLt, BLt, LLt, MLt, $Lt, FLt, ULt, HLt, GLt, jLt, qLt, VLt, zLt, WLt, KLt, QLt, YLt, XLt, JLt, ZLt, eMt, tMt, rMt, oMt, nMt, sMt, iMt, aMt, cMt, pMt, uMt, mMt, lMt, dMt, fMt, hMt, gMt, xMt, EMt, yMt, SMt, _Mt, CMt, RMt, AMt, TMt, wMt, bMt, IMt, vMt, PMt, OMt, DMt, kMt, NMt, BMt, LMt, MMt, $Mt, FMt, UMt, HMt, GMt, jMt, qMt, VMt, zMt, WMt, KMt, QMt, I2e, YMt, XMt, JMt, ZMt, e$t, v2e, P2e, O2e, t$t, u2, r$t, o$t, n$t, s$t, m2, i$t, a$t, c$t, p$t, u$t, m$t, l$t, d$t, f$t, h$t, g$t, x$t, E$t, y$t, S$t, _$t, C$t, R$t, A$t, T$t, w$t, b$t, I$t, v$t, P$t, O$t, D$t, k$t, N$t, B$t, L$t, M$t, $$t, F$t, U$t, H$t, G$t, j$t, q$t, V$t, z$t, D2e, W$t, K$t, Q$t, Y$t, X$t, l2, J$t, Z$t, d2, eFt, tFt, rFt, oFt, nFt, sFt, iFt, k2e, f2, aFt, cFt, pFt, N2e, B2e, L2e, uFt, mFt, lFt, dFt, fFt, M2e, zi, $2e, hFt, gFt, xFt, EFt, yFt, SFt, _Ft, F2e, CFt, RFt, AFt, TFt, wFt, bFt, IFt, vFt, PFt, OFt, DFt, kFt, NFt, BFt, LFt, MFt, $Ft, FFt, UFt, HFt, GFt, jFt, qFt, VFt, zFt, WFt, KFt, QFt, YFt, XFt, JFt, ZFt, eUt, tUt, h2, rUt, oUt, U2e, nUt, sUt, iUt, H2e, aUt, cUt, pUt, uUt, G2e, mUt, lUt, dUt, fUt, hUt, j2e, gUt, xUt, EUt, yUt, SUt, _Ut, CUt, RUt, AUt, TUt, q2e, wUt, bUt, IUt, vUt, PUt, OUt, DUt, kUt, NUt, BUt, LUt, bd, g2, MUt, $Ut, FUt, UUt, HUt, GUt, jUt, qUt, VUt, zUt, WUt, KUt, QUt, YUt, XUt, Fe, JUt, ZUt, V2e, V0, e1t, z2e, t1t, r1t, o1t, n1t, s1t, z0, i1t, a1t, c1t, p1t, W2e, u1t, m1t, l1t, d1t, K2e, f1t, h1t, g1t, x1t, E1t, y1t, Q2e, S1t, Wi, _1t, C1t, R1t, A1t, T1t, w1t, b1t, I1t, Y2e, X2e, J2e, Z2e, eGe, tGe, rGe, oGe, nGe, sGe, iGe, aGe, cGe, pGe, uGe, mGe, lGe, dGe, fGe, hGe, gGe, xGe, EGe, yGe, SGe, _Ge, CGe, RGe, AGe, TGe, wGe, bGe, IGe, vGe, PGe, OGe, DGe, kGe, NGe, BGe, LGe, MGe, $Ge, FGe, UGe, HGe, GGe, jGe, qGe, VGe, zGe, WGe, KGe, QGe, YGe, XGe, JGe, ZGe, eje, tje, rje, oje, nje, sje, ije, aje, cje, pje, uje, mje, lje, dje, fje, hje, gje, xje, Eje, yje, Sje, _je, Cje, Rje, Aje, Tje, wje, bje, Ije, vje, Pje, Oje, Dje, kje, Nje, Bje, Lje, Mje, $je, Fje, Uje, Hje, Gje, jje, qje, Vje, zje, Wje, Q = s(() => { Oe(); oH(); rH(); eTt = "Account", tTt = "AnalyticsAndOperator", a0 = "AccelerateConfiguration", I0 = "AccessControlList", Xl = "ACL", T1e = "AnalyticsConfigurationList", lp = "AccessControlPolicy", w1e = "AccessControlTranslation", Jg = "AnalyticsConfiguration", b1e = "AbortDate", rTt = "AnalyticsExportDestination", oTt = "AnalyticsFilter", nTt = "AllowedHeaders", sTt = "AllowedHeader", iTt = "AccountId", I1e = "AbortIncompleteMultipartUpload", h1e = "AccessKeyId", aTt = "AllowedMethods", cTt = "AbortMultipartUpload", pTt = "AbortMultipartUploadOutput", uTt = "AbortMultipartUploadRequest", mTt = "AllowedMethod", lTt = "AllowedOrigins", dTt = "AllowedOrigin", fTt = "AccessPointAlias", v1e = "AccessPointArn", hTt = "AllowQuotedRecordDelimiter", lH = "AcceptRanges", P1e = "AbortRuleId", c0 = "AbacStatus", gTt = "AnalyticsS3BucketDestination", xTt = "ApplyServerSideEncryptionByDefault", ETt = "ArchiveStatus", O1e = "AccessTier", rx = "And", W = "Bucket", dH = "BucketArn", yTt = "BucketAlreadyExists", STt = "BucketAccountId", _Tt = "BucketAlreadyOwnedByYou", D1e = "BlockedEncryptionTypes", fH = "BypassGovernanceRetention", CTt = "BucketInfo", Ao = "BucketKeyEnabled", RTt = "BucketLifecycleConfiguration", ATt = "BucketLocationName", p0 = "BucketLoggingStatus", TTt = "BucketLocationType", wTt = "BucketName", k1e = "BytesProcessed", g1e = "BlockPublicAcls", x1e = "BlockPublicPolicy", hH = "BucketRegion", N1e = "BytesReturned", B1e = "BytesScanned", ox = "Body", gH = "Buckets", L1e = "Checksum", Ze = "ChecksumAlgorithm", bTt = "CannedACL", ITt = "CreateBucket", nH = "CreateBucketConfiguration", vTt = "CreateBucketMetadataConfiguration", PTt = "CreateBucketMetadataConfigurationRequest", OTt = "CreateBucketMetadataTableConfiguration", DTt = "CreateBucketMetadataTableConfigurationRequest", kTt = "CreateBucketOutput", NTt = "CreateBucketRequest", Jl = "CacheControl", To = "ChecksumCRC32", wo = "ChecksumCRC32C", bo = "ChecksumCRC64NVME", nx = "Cache-Control", BTt = "CreationDate", sx = "Content-Disposition", Zl = "ContentDisposition", LTt = "ContinuationEvent", ix = "Content-Encoding", ed = "ContentEncoding", MTt = "CloudFunction", $Tt = "CloudFunctionConfiguration", td = "ContentLanguage", ax = "Content-Language", cx = "Content-Length", px = "ContentLength", tr = "Content-MD5", rr = "ContentMD5", FTt = "CompletedMultipartUpload", UTt = "CompleteMultipartUploadOutput", HTt = "CreateMultipartUploadOutput", GTt = "CompleteMultipartUploadResult", jTt = "CompleteMultipartUploadRequest", qTt = "CreateMultipartUploadRequest", M1e = "CompleteMultipartUpload", VTt = "CreateMultipartUpload", $1e = "ChecksumMode", zTt = "CopyObject", WTt = "CopyObjectOutput", F1e = "CopyObjectResult", u0 = "CORSConfiguration", xH = "CORSRules", EH = "CORSRule", KTt = "CopyObjectRequest", QTt = "CommonPrefix", YTt = "CommonPrefixList", XTt = "CompletedPartList", U1e = "CopyPartResult", JTt = "CompletedPart", v0 = "CommonPrefixes", yH = "ContentRange", ZTt = "ConfirmRemoveSelfBucketAccess", H1e = "Content-Range", G1e = "CopySource", Io = "ChecksumSHA1", vo = "ChecksumSHA256", j1e = "CopySourceIfMatch", q1e = "CopySourceIfModifiedSince", V1e = "CopySourceIfNoneMatch", z1e = "CopySourceIfUnmodifiedSince", ewt = "CreateSessionOutput", twt = "CreateSessionResult", rwt = "CopySourceRange", owt = "CreateSessionRequest", W1e = "CopySourceSSECustomerAlgorithm", SH = "CopySourceSSECustomerKey", K1e = "CopySourceSSECustomerKeyMD5", Q1e = "CSV", Y1e = "CopySourceVersionId", nwt = "CSVInput", swt = "CSVOutput", _H = "ConfigurationState", iwt = "CreateSession", cn = "ChecksumType", ux = "Content-Type", awt = "ClientToken", rd = "ContentType", cwt = "CompressionType", Go = "ContinuationToken", X1e = "Condition", pwt = "Code", uwt = "Comments", J1e = "Contents", mwt = "Cont", E1e = "Credentials", od = "Days", lwt = "DaysAfterInitiation", dwt = "DeleteBucket", fwt = "DeleteBucketAnalyticsConfiguration", hwt = "DeleteBucketAnalyticsConfigurationRequest", gwt = "DeleteBucketCors", xwt = "DeleteBucketCorsRequest", Ewt = "DeleteBucketEncryption", ywt = "DeleteBucketEncryptionRequest", Swt = "DeleteBucketInventoryConfiguration", _wt = "DeleteBucketInventoryConfigurationRequest", Cwt = "DeleteBucketIntelligentTieringConfiguration", Rwt = "DeleteBucketIntelligentTieringConfigurationRequest", Awt = "DeleteBucketLifecycle", Twt = "DeleteBucketLifecycleRequest", wwt = "DeleteBucketMetadataConfiguration", bwt = "DeleteBucketMetadataConfigurationRequest", Iwt = "DeleteBucketMetricsConfigurationRequest", vwt = "DeleteBucketMetricsConfiguration", Pwt = "DeleteBucketMetadataTableConfiguration", Owt = "DeleteBucketMetadataTableConfigurationRequest", Dwt = "DeleteBucketOwnershipControls", kwt = "DeleteBucketOwnershipControlsRequest", Nwt = "DeleteBucketPolicy", Bwt = "DeleteBucketPolicyRequest", Lwt = "DeleteBucketRequest", Mwt = "DeleteBucketReplicationRequest", $wt = "DeleteBucketReplication", Fwt = "DeleteBucketTagging", Uwt = "DeleteBucketTaggingRequest", Hwt = "DeleteBucketWebsite", Gwt = "DeleteBucketWebsiteRequest", jwt = "DataExport", qwt = "DestinationIfMatch", Vwt = "DestinationIfModifiedSince", zwt = "DestinationIfNoneMatch", Wwt = "DestinationIfUnmodifiedSince", dp = "DeleteMarker", Kwt = "DeleteMarkerEntry", Z1e = "DeleteMarkerReplication", Qwt = "DeleteMarkerVersionId", e3e = "DeleteMarkers", CH = "DisplayName", Ywt = "DeletedObject", Xwt = "DeleteObjectOutput", Jwt = "DeleteObjectsOutput", Zwt = "DeleteObjectRequest", ebt = "DeleteObjectsRequest", tbt = "DeleteObjectTagging", rbt = "DeleteObjectTaggingOutput", obt = "DeleteObjectTaggingRequest", nbt = "DeletedObjects", sbt = "DeleteObject", ibt = "DeleteObjects", abt = "DeletePublicAccessBlock", cbt = "DeletePublicAccessBlockRequest", pbt = "DataRedundancy", t3e = "DefaultRetention", ubt = "DeleteResult", r3e = "DestinationResult", o3e = "Date", sH = "Delete", mbt = "Deleted", Ja = "Delimiter", P0 = "Destination", lbt = "Description", n3e = "Details", ri = "Expiration", dbt = "EmailAddress", s3e = "EventBridgeConfiguration", X = "ExpectedBucketOwner", mx = "EncryptionConfiguration", i3e = "ErrorCode", fbt = "ErrorDetails", RH = "ErrorDocument", hbt = "EndEvent", gbt = "ExposeHeaders", xbt = "ExposeHeader", a3e = "ErrorMessage", Ebt = "ExpiredObjectDeleteMarker", c3e = "ExistingObjectReplication", m0 = "ExpiresString", p3e = "ExpectedSourceBucketOwner", AH = "EncryptionType", ybt = "EncryptionTypeList", Sbt = "EncryptionTypeMismatch", Zr = "ETag", Za = "EncodingType", _bt = "EventThreshold", u3e = "ExpressionType", TH = "Encryption", Cbt = "Enabled", m3e = "End", l3e = "Errors", lx = "Error", wH = "Events", bH = "Event", fs = "Expires", d3e = "Expression", qi = "Filter", f3e = "FieldDelimiter", Rbt = "FileHeaderInfo", Abt = "FetchOwner", h3e = "FilterRule", Tbt = "FilterRuleList", wbt = "FilterRules", bbt = "Field", g3e = "Format", Ibt = "Frequency", O0 = "Grants", vbt = "GetBucketAbac", Pbt = "GetBucketAccelerateConfiguration", Obt = "GetBucketAccelerateConfigurationOutput", Dbt = "GetBucketAnalyticsConfigurationOutput", kbt = "GetBucketAccelerateConfigurationRequest", Nbt = "GetBucketAnalyticsConfigurationRequest", Bbt = "GetBucketAnalyticsConfiguration", Lbt = "GetBucketAbacOutput", Mbt = "GetBucketAclOutput", $bt = "GetBucketAbacRequest", Fbt = "GetBucketAclRequest", Ubt = "GetBucketAcl", Hbt = "GetBucketCors", Gbt = "GetBucketCorsOutput", jbt = "GetBucketCorsRequest", qbt = "GetBucketEncryption", Vbt = "GetBucketEncryptionOutput", zbt = "GetBucketEncryptionRequest", Wbt = "GetBucketInventoryConfiguration", Kbt = "GetBucketInventoryConfigurationOutput", Qbt = "GetBucketInventoryConfigurationRequest", Ybt = "GetBucketIntelligentTieringConfiguration", Xbt = "GetBucketIntelligentTieringConfigurationOutput", Jbt = "GetBucketIntelligentTieringConfigurationRequest", Zbt = "GetBucketLocation", e0t = "GetBucketLifecycleConfiguration", t0t = "GetBucketLifecycleConfigurationOutput", r0t = "GetBucketLifecycleConfigurationRequest", o0t = "GetBucketLocationOutput", n0t = "GetBucketLoggingOutput", s0t = "GetBucketLocationRequest", i0t = "GetBucketLoggingRequest", a0t = "GetBucketLogging", c0t = "GetBucketMetadataConfiguration", p0t = "GetBucketMetadataConfigurationOutput", u0t = "GetBucketMetricsConfigurationOutput", x3e = "GetBucketMetadataConfigurationResult", m0t = "GetBucketMetadataConfigurationRequest", l0t = "GetBucketMetricsConfigurationRequest", d0t = "GetBucketMetricsConfiguration", f0t = "GetBucketMetadataTableConfiguration", h0t = "GetBucketMetadataTableConfigurationOutput", E3e = "GetBucketMetadataTableConfigurationResult", g0t = "GetBucketMetadataTableConfigurationRequest", x0t = "GetBucketNotificationConfiguration", E0t = "GetBucketNotificationConfigurationRequest", y0t = "GetBucketOwnershipControls", S0t = "GetBucketOwnershipControlsOutput", _0t = "GetBucketOwnershipControlsRequest", C0t = "GetBucketPolicy", R0t = "GetBucketPolicyOutput", A0t = "GetBucketPolicyRequest", T0t = "GetBucketPolicyStatus", w0t = "GetBucketPolicyStatusOutput", b0t = "GetBucketPolicyStatusRequest", I0t = "GetBucketReplication", v0t = "GetBucketReplicationOutput", P0t = "GetBucketRequestPayment", O0t = "GetBucketRequestPaymentOutput", D0t = "GetBucketRequestPaymentRequest", k0t = "GetBucketReplicationRequest", N0t = "GetBucketTagging", B0t = "GetBucketTaggingOutput", L0t = "GetBucketTaggingRequest", M0t = "GetBucketVersioning", $0t = "GetBucketVersioningOutput", F0t = "GetBucketVersioningRequest", U0t = "GetBucketWebsite", H0t = "GetBucketWebsiteOutput", G0t = "GetBucketWebsiteRequest", nd = "GrantFullControl", y3e = "GlacierJobParameters", j0t = "GetObject", q0t = "GetObjectAcl", V0t = "GetObjectAclOutput", z0t = "GetObjectAttributesOutput", W0t = "GetObjectAttributesParts", K0t = "GetObjectAclRequest", Q0t = "GetObjectAttributesResponse", Y0t = "GetObjectAttributesRequest", X0t = "GetObjectAttributes", J0t = "GetObjectLockConfiguration", Z0t = "GetObjectLockConfigurationOutput", eIt = "GetObjectLockConfigurationRequest", tIt = "GetObjectLegalHold", rIt = "GetObjectLegalHoldOutput", oIt = "GetObjectLegalHoldRequest", nIt = "GetObjectOutput", sIt = "GetObjectRequest", iIt = "GetObjectRetentionOutput", aIt = "GetObjectRetentionRequest", cIt = "GetObjectRetention", pIt = "GetObjectTagging", uIt = "GetObjectTaggingOutput", mIt = "GetObjectTorrentOutput", lIt = "GetObjectTaggingRequest", dIt = "GetObjectTorrentRequest", fIt = "GetObjectTorrent", hIt = "GetPublicAccessBlock", gIt = "GetPublicAccessBlockOutput", xIt = "GetPublicAccessBlockRequest", sd = "GrantRead", id = "GrantReadACP", IH = "GrantWrite", ad = "GrantWriteACP", vH = "Grant", PH = "Grantee", EIt = "HeadBucket", yIt = "HeadBucketOutput", SIt = "HeadBucketRequest", _It = "HttpErrorCodeReturnedEquals", S3e = "HostName", CIt = "HeadObject", RIt = "HeadObjectOutput", AIt = "HeadObjectRequest", TIt = "HttpRedirectCode", Nr = "Id", Zg = "InventoryConfiguration", _3e = "InventoryConfigurationList", cd = "ID", OH = "IndexDocument", wIt = "InventoryDestination", bIt = "IsEnabled", IIt = "InventoryEncryption", vIt = "InventoryFilter", C3e = "IsLatest", pd = "IfMatch", PIt = "IfMatchInitiatedTime", OIt = "IfMatchLastModifiedTime", DIt = "IfMatchSize", DH = "If-Modified-Since", R3e = "IfModifiedSince", kIt = "InitiateMultipartUploadResult", fp = "If-Match", dx = "IfNoneMatch", ud = "If-None-Match", NIt = "InventoryOptionalFields", BIt = "InvalidObjectState", LIt = "IncludedObjectVersions", y1e = "IsPublic", S1e = "IgnorePublicAcls", MIt = "IdempotencyParameterMismatch", $It = "InvalidRequest", FIt = "IsRestoreInProgress", kH = "InputSerialization", UIt = "InventoryS3BucketDestination", HIt = "InventorySchedule", oi = "IsTruncated", GIt = "IntelligentTieringAndOperator", ex = "IntelligentTieringConfiguration", A3e = "IntelligentTieringConfigurationList", T3e = "InventoryTableConfigurationResult", jIt = "InventoryTableConfigurationUpdates", l0 = "InventoryTableConfiguration", qIt = "IntelligentTieringFilter", w3e = "IfUnmodifiedSince", NH = "If-Unmodified-Since", VIt = "InvalidWriteOffset", BH = "Initiator", zIt = "Initiated", b3e = "JSON", WIt = "JSONInput", KIt = "JSONOutput", d0 = "JournalTableConfiguration", I3e = "JournalTableConfigurationResult", QIt = "JournalTableConfigurationUpdates", Ge = "Key", YIt = "KeyCount", XIt = "KeyId", JIt = "KmsKeyArn", D0 = "KeyMarker", ZIt = "KMSContext", evt = "KMSKeyId", tvt = "KMSMasterKeyID", rvt = "KeyPrefixEquals", f0 = "Location", ovt = "ListAllMyBucketsResult", nvt = "ListAllMyDirectoryBucketsResult", svt = "ListBuckets", ivt = "ListBucketAnalyticsConfigurations", avt = "ListBucketAnalyticsConfigurationsOutput", cvt = "ListBucketAnalyticsConfigurationResult", pvt = "ListBucketAnalyticsConfigurationsRequest", uvt = "ListBucketInventoryConfigurations", mvt = "ListBucketInventoryConfigurationsOutput", lvt = "ListBucketInventoryConfigurationsRequest", dvt = "ListBucketIntelligentTieringConfigurations", fvt = "ListBucketIntelligentTieringConfigurationsOutput", hvt = "ListBucketIntelligentTieringConfigurationsRequest", gvt = "ListBucketMetricsConfigurations", xvt = "ListBucketMetricsConfigurationsOutput", Evt = "ListBucketMetricsConfigurationsRequest", yvt = "ListBucketsOutput", Svt = "ListBucketsRequest", v3e = "ListBucketResult", iH = "LocationConstraint", aH = "LifecycleConfiguration", _vt = "ListDirectoryBuckets", Cvt = "ListDirectoryBucketsOutput", Rvt = "ListDirectoryBucketsRequest", LH = "LoggingEnabled", Avt = "LifecycleExpiration", Tvt = "LambdaFunctionArn", wvt = "LambdaFunctionConfiguration", bvt = "LambdaFunctionConfigurationList", Ivt = "LambdaFunctionConfigurations", h0 = "LegalHold", vvt = "LocationInfo", Pvt = "ListInventoryConfigurationsResult", ni = "LastModified", Ovt = "ListMetricsConfigurationsResult", Dvt = "LastModifiedTime", kvt = "ListMultipartUploads", Nvt = "ListMultipartUploadsOutput", Bvt = "ListMultipartUploadsResult", Lvt = "ListMultipartUploadsRequest", MH = "Last-Modified", Mvt = "ListObjects", $vt = "ListObjectsOutput", Fvt = "ListObjectsRequest", Uvt = "ListObjectsV2", Hvt = "ListObjectsV2Output", Gvt = "ListObjectVersionsOutput", jvt = "ListObjectsV2Request", qvt = "ListObjectVersionsRequest", Vvt = "ListObjectVersions", zvt = "ListParts", Wvt = "ListPartsOutput", Kvt = "ListPartsResult", Qvt = "ListPartsRequest", Yvt = "LifecycleRule", Xvt = "LifecycleRuleAndOperator", Jvt = "LifecycleRuleFilter", Zvt = "LifecycleRules", ePt = "ListVersionsResult", md = "Metadata", tPt = "MetricsAndOperator", rPt = "MaxAgeSeconds", oPt = "MaxBuckets", cH = "MetadataConfiguration", P3e = "MetricsConfigurationList", O3e = "MetadataConfigurationResult", tx = "MetricsConfiguration", nPt = "MetadataDirective", sPt = "MaxDirectoryBuckets", D3e = "MfaDelete", k3e = "MetadataEntry", iPt = "MetricsFilter", $H = "MFA", N3e = "MFADelete", ld = "MaxKeys", FH = "MissingMeta", aPt = "MpuObjectSize", k0 = "MaxParts", pH = "MetadataTableConfiguration", B3e = "MetadataTableConfigurationResult", cPt = "MetadataTableEncryptionConfiguration", L3e = "MultipartUpload", pPt = "MultipartUploadList", M3e = "MaxUploads", $3e = "Marker", F3e = "Metrics", uPt = "Message", mPt = "Minutes", U3e = "Mode", hp = "Name", uH = "NotificationConfiguration", lPt = "NotificationConfigurationFilter", fx = "NextContinuationToken", H3e = "NoncurrentDays", dPt = "NotFound", G3e = "NextKeyMarker", fPt = "NextMarker", j3e = "NewerNoncurrentVersions", q3e = "NextPartNumberMarker", hPt = "NoSuchBucket", gPt = "NoSuchKey", xPt = "NoSuchUpload", EPt = "NextUploadIdMarker", V3e = "NoncurrentVersionExpiration", yPt = "NextVersionIdMarker", SPt = "NoncurrentVersionTransitions", _Pt = "NoncurrentVersionTransitionList", z3e = "NoncurrentVersionTransition", gs = "Owner", CPt = "ObjectAttributes", RPt = "ObjectAlreadyInActiveTierError", g0 = "OwnershipControls", APt = "OwnershipControlsRule", TPt = "OwnershipControlsRules", wPt = "OptionalFields", bPt = "ObjectIdentifier", IPt = "ObjectIdentifierList", W3e = "OutputLocation", x0 = "ObjectLockConfiguration", vPt = "ObjectLockEnabled", PPt = "ObjectLockEnabledForBucket", OPt = "ObjectLockLegalHold", dd = "ObjectLockLegalHoldStatus", fd = "ObjectLockMode", DPt = "ObjectLockRetention", hd = "ObjectLockRetainUntilDate", kPt = "ObjectLockRule", NPt = "ObjectList", BPt = "ObjectNotInActiveTierError", K3e = "ObjectOwnership", UH = "OptionalObjectAttributes", LPt = "ObjectParts", MPt = "ObjectPart", $Pt = "ObjectSize", Q3e = "ObjectSizeGreaterThan", Y3e = "ObjectSizeLessThan", FPt = "OutputSchemaVersion", HH = "OutputSerialization", UPt = "ObjectVersion", HPt = "ObjectVersionList", GPt = "Objects", X3e = "Object", Mt = "Prefix", E0 = "PublicAccessBlockConfiguration", jPt = "PutBucketAbac", qPt = "PutBucketAccelerateConfiguration", VPt = "PutBucketAccelerateConfigurationRequest", zPt = "PutBucketAnalyticsConfigurationRequest", WPt = "PutBucketAnalyticsConfiguration", KPt = "PutBucketAbacRequest", QPt = "PutBucketAclRequest", YPt = "PutBucketAcl", XPt = "PutBucketCors", JPt = "PutBucketCorsRequest", ZPt = "PutBucketEncryption", eOt = "PutBucketEncryptionRequest", tOt = "PutBucketInventoryConfiguration", rOt = "PutBucketInventoryConfigurationRequest", oOt = "PutBucketIntelligentTieringConfiguration", nOt = "PutBucketIntelligentTieringConfigurationRequest", sOt = "PutBucketLogging", iOt = "PutBucketLifecycleConfiguration", aOt = "PutBucketLifecycleConfigurationOutput", cOt = "PutBucketLifecycleConfigurationRequest", pOt = "PutBucketLoggingRequest", uOt = "PutBucketMetricsConfiguration", mOt = "PutBucketMetricsConfigurationRequest", lOt = "PutBucketNotificationConfiguration", dOt = "PutBucketNotificationConfigurationRequest", fOt = "PutBucketOwnershipControls", hOt = "PutBucketOwnershipControlsRequest", gOt = "PutBucketPolicy", xOt = "PutBucketPolicyRequest", EOt = "PutBucketReplication", yOt = "PutBucketRequestPayment", SOt = "PutBucketRequestPaymentRequest", _Ot = "PutBucketReplicationRequest", COt = "PutBucketTagging", ROt = "PutBucketTaggingRequest", AOt = "PutBucketVersioning", TOt = "PutBucketVersioningRequest", wOt = "PutBucketWebsite", bOt = "PutBucketWebsiteRequest", N0 = "PartsCount", IOt = "PartitionDateSource", vOt = "ProgressEvent", POt = "ParquetInput", OOt = "PartsList", gp = "PartNumber", B0 = "PartNumberMarker", DOt = "PutObject", kOt = "PutObjectAcl", NOt = "PutObjectAclOutput", BOt = "PutObjectAclRequest", LOt = "PutObjectLockConfiguration", MOt = "PutObjectLockConfigurationOutput", $Ot = "PutObjectLockConfigurationRequest", FOt = "PutObjectLegalHold", UOt = "PutObjectLegalHoldOutput", HOt = "PutObjectLegalHoldRequest", GOt = "PutObjectOutput", jOt = "PutObjectRequest", qOt = "PutObjectRetentionOutput", VOt = "PutObjectRetentionRequest", zOt = "PutObjectRetention", WOt = "PutObjectTagging", KOt = "PutObjectTaggingOutput", QOt = "PutObjectTaggingRequest", y0 = "PartitionedPrefix", YOt = "PutPublicAccessBlock", XOt = "PutPublicAccessBlockRequest", J3e = "PolicyStatus", L0 = "Parts", M0 = "Part", JOt = "Parquet", Z3e = "Payer", eHe = "Payload", tHe = "Permission", rHe = "Policy", oHe = "Progress", ZOt = "Priority", nHe = "Protocol", eDt = "Quiet", tDt = "QueueArn", sHe = "QuoteCharacter", rDt = "QueueConfigurationList", oDt = "QueueConfigurations", iHe = "QueueConfiguration", aHe = "QuoteEscapeCharacter", nDt = "QuoteFields", sDt = "Queue", hx = "Rules", GH = "RedirectAllRequestsTo", jt = "RequestCharged", cHe = "ResponseCacheControl", pHe = "ResponseContentDisposition", uHe = "ResponseContentEncoding", mHe = "ResponseContentLanguage", lHe = "ResponseContentType", S0 = "ReplicationConfiguration", jH = "RecordDelimiter", dHe = "ResponseExpires", iDt = "RestoreExpiryDate", $0 = "RecordExpiration", aDt = "RecordsEvent", cDt = "ReplicaKmsKeyID", pDt = "ReplaceKeyPrefixWith", uDt = "ReplaceKeyWith", fHe = "ReplicaModifications", mDt = "RenameObject", lDt = "RenameObjectOutput", dDt = "RestoreObjectOutput", fDt = "RestoreOutputPath", hDt = "RenameObjectRequest", gDt = "RestoreObjectRequest", xDt = "RestoreObject", Tt = "RequestPayer", _1e = "RestrictPublicBuckets", _0 = "RequestPaymentConfiguration", hHe = "RequestProgress", qH = "RoutingRules", EDt = "ReplicationRuleAndOperator", yDt = "ReplicationRuleFilter", SDt = "ReplicationRule", _Dt = "ReplicationRules", CDt = "RequestRoute", mH = "RestoreRequest", gHe = "RoutingRule", VH = "ReplicationStatus", zH = "RestoreStatus", RDt = "RenameSource", xHe = "ReplicationTime", ADt = "ReplicationTimeValue", TDt = "RequestToken", wDt = "RetainUntilDate", C0 = "Range", WH = "Restore", bDt = "Records", EHe = "Redirect", R0 = "Retention", IDt = "Role", gd = "Rule", xo = "Status", yHe = "StartAfter", C1e = "SecretAccessKey", vDt = "SseAlgorithm", PDt = "StreamingBlob", SHe = "S3BucketDestination", Eo = "StorageClass", _He = "StorageClassAnalysis", ODt = "StorageClassAnalysisDataExport", DDt = "SessionCredentialValue", kDt = "SessionCredentials", NDt = "StatusCode", BDt = "SkipDestinationValidation", LDt = "StatsEvent", MDt = "SourceIfMatch", $Dt = "SourceIfModifiedSince", FDt = "SourceIfNoneMatch", UDt = "SourceIfUnmodifiedSince", CHe = "SSE-KMS", RHe = "SseKmsEncryptedObjects", HDt = "S3KeyFilter", GDt = "S3Key", jDt = "S3Location", qDt = "SessionMode", VDt = "SelectObjectContent", zDt = "SelectObjectContentEventStream", WDt = "SelectObjectContentOutput", KDt = "SelectObjectContentRequest", AHe = "SelectParameters", A0 = "SimplePrefix", THe = "ScanRange", wHe = "SSE-S3", bHe = "SourceSelectionCriteria", jo = "ServerSideEncryption", QDt = "SSEAlgorithm", YDt = "ServerSideEncryptionByDefault", T0 = "ServerSideEncryptionConfiguration", Br = "SSECustomerAlgorithm", zn = "SSECustomerKey", Lr = "SSECustomerKeyMD5", IHe = "SSEKMS", Vi = "SSEKMSEncryptionContext", Po = "SSEKMSKeyId", XDt = "ServerSideEncryptionRule", JDt = "ServerSideEncryptionRules", vHe = "SSES3", R1e = "SessionToken", PHe = "S3TablesDestination", OHe = "S3TablesDestinationResult", ZDt = "S3", ekt = "Schedule", xd = "Size", tkt = "Start", DHe = "Stats", rkt = "Suffix", Ed = "Tags", KH = "TableArn", okt = "TopicArn", nkt = "TargetBucket", QH = "TableBucketArn", skt = "TableBucketType", YH = "TagCount", ikt = "TopicConfigurationList", akt = "TopicConfigurations", kHe = "TopicConfiguration", ckt = "TaggingDirective", XH = "TransitionDefaultMinimumObjectSize", NHe = "TargetGrants", pkt = "TargetGrant", ukt = "TieringList", mkt = "TransitionList", lkt = "TooManyParts", BHe = "TableNamespace", F0 = "TableName", LHe = "TargetObjectKeyFormat", dkt = "TargetPrefix", fkt = "TotalPartsCount", U0 = "TagSet", MHe = "TableStatus", Wn = "Tag", hs = "Tagging", $He = "Tier", hkt = "Tierings", FHe = "Tiering", gkt = "Time", UHe = "Token", xkt = "Topic", Ekt = "Transitions", HHe = "Transition", gx = "Type", ykt = "Uploads", Skt = "UpdateBucketMetadataInventoryTableConfiguration", _kt = "UpdateBucketMetadataInventoryTableConfigurationRequest", Ckt = "UpdateBucketMetadataJournalTableConfiguration", Rkt = "UpdateBucketMetadataJournalTableConfigurationRequest", ec = "UploadId", GHe = "UploadIdMarker", jHe = "UserMetadata", Akt = "UploadPart", Tkt = "UploadPartCopy", wkt = "UploadPartCopyOutput", bkt = "UploadPartCopyRequest", Ikt = "UploadPartOutput", vkt = "UploadPartRequest", Pkt = "URI", Okt = "Upload", JH = "Value", w0 = "VersioningConfiguration", _t = "VersionId", qHe = "VersionIdMarker", Dkt = "Versions", kkt = "Version", b0 = "WebsiteConfiguration", Nkt = "WriteGetObjectResponse", Bkt = "WriteGetObjectResponseRequest", Lkt = "WriteOffsetBytes", xx = "WebsiteRedirectLocation", Mkt = "Years", VHe = "accept-ranges", $kt = "bucket-region", qo = "client", xp = "continuation-token", H0 = "delimiter", Vo = "error", ZH = "eventPayload", Fkt = "endpoint", G0 = "encoding-type", Ukt = "fetch-owner", Y = "http", wt = "httpChecksum", pn = "httpError", d = "httpHeader", Hkt = "hostLabel", ot = "httpPayload", yd = "httpPrefixHeaders", te = "httpQuery", zHe = "http://www.w3.org/2001/XMLSchema-instance", Kn = "id", Gkt = "idempotencyToken", WHe = "key-marker", jkt = "marker", qkt = "max-buckets", Vkt = "max-directory-buckets", e2 = "max-keys", zkt = "max-parts", Wkt = "max-uploads", Ex = "prefix", j0 = "partNumber", Kkt = "part-number-marker", KHe = "response-cache-control", QHe = "response-content-disposition", YHe = "response-content-encoding", XHe = "response-content-language", JHe = "response-content-type", ZHe = "response-expires", e2e = "streaming", Qkt = "start-after", t2e = "smithy.ts.sdk.synthetic.com.amazonaws.s3", yx = "uploadId", Ykt = "upload-id-marker", zo = "versionId", Xkt = "version-id-marker", r2e = "xsi", Jkt = "xmlAttribute", we = "xmlFlattened", B = "xmlName", o2e = "xmlNamespace", Sd = "x-amz-acl", n2e = "x-amz-abort-date", Zkt = "x-amz-access-point-alias", s2e = "x-amz-abort-rule-id", eNt = "x-amz-archive-status", i2e = "x-amz-bucket-arn", t2 = "x-amz-bypass-governance-retention", tNt = "x-amz-bucket-location-name", rNt = "x-amz-bucket-location-type", oNt = "x-amz-bucket-object-lock-enabled", a2e = "x-amz-bucket-object-lock-token", nNt = "x-amz-bucket-region", r2 = "x-amz-checksum-algorithm", Ep = "x-amz-checksum-crc32", yp = "x-amz-checksum-crc32c", Sp = "x-amz-checksum-crc64nvme", c2e = "x-amz-checksum-mode", sNt = "x-amz-confirm-remove-self-bucket-access", _p = "x-amz-checksum-sha1", Cp = "x-amz-checksum-sha256", p2e = "x-amz-copy-source", u2e = "x-amz-copy-source-if-match", m2e = "x-amz-copy-source-if-modified-since", l2e = "x-amz-copy-source-if-none-match", d2e = "x-amz-copy-source-if-unmodified-since", iNt = "x-amz-create-session-mode", aNt = "x-amz-copy-source-range", f2e = "x-amz-copy-source-server-side-encryption-customer-algorithm", h2e = "x-amz-copy-source-server-side-encryption-customer-key", g2e = "x-amz-copy-source-server-side-encryption-customer-key-MD5", x2e = "x-amz-copy-source-version-id", _d = "x-amz-checksum-type", cNt = "x-amz-client-token", q0 = "x-amz-delete-marker", Sx = "x-amz-expiration", J = "x-amz-expected-bucket-owner", pNt = "x-amz-fwd-error-code", uNt = "x-amz-fwd-error-message", mNt = "x-amz-fwd-header-Cache-Control", lNt = "x-amz-fwd-header-Content-Disposition", dNt = "x-amz-fwd-header-Content-Encoding", fNt = "x-amz-fwd-header-Content-Language", hNt = "x-amz-fwd-header-Content-Range", gNt = "x-amz-fwd-header-Content-Type", xNt = "x-amz-fwd-header-ETag", ENt = "x-amz-fwd-header-Expires", yNt = "x-amz-fwd-header-Last-Modified", SNt = "x-amz-fwd-header-accept-ranges", _Nt = "x-amz-fwd-header-x-amz-checksum-crc32", CNt = "x-amz-fwd-header-x-amz-checksum-crc32c", RNt = "x-amz-fwd-header-x-amz-checksum-crc64nvme", ANt = "x-amz-fwd-header-x-amz-checksum-sha1", TNt = "x-amz-fwd-header-x-amz-checksum-sha256", wNt = "x-amz-fwd-header-x-amz-delete-marker", bNt = "x-amz-fwd-header-x-amz-expiration", INt = "x-amz-fwd-header-x-amz-missing-meta", vNt = "x-amz-fwd-header-x-amz-mp-parts-count", PNt = "x-amz-fwd-header-x-amz-object-lock-legal-hold", ONt = "x-amz-fwd-header-x-amz-object-lock-mode", DNt = "x-amz-fwd-header-x-amz-object-lock-retain-until-date", kNt = "x-amz-fwd-header-x-amz-restore", NNt = "x-amz-fwd-header-x-amz-request-charged", BNt = "x-amz-fwd-header-x-amz-replication-status", LNt = "x-amz-fwd-header-x-amz-storage-class", MNt = "x-amz-fwd-header-x-amz-server-side-encryption", $Nt = "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id", FNt = "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled", UNt = "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm", HNt = "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5", GNt = "x-amz-fwd-header-x-amz-tagging-count", jNt = "x-amz-fwd-header-x-amz-version-id", qNt = "x-amz-fwd-status", Cd = "x-amz-grant-full-control", Rd = "x-amz-grant-read", Ad = "x-amz-grant-read-acp", o2 = "x-amz-grant-write", Td = "x-amz-grant-write-acp", VNt = "x-amz-if-match-initiated-time", zNt = "x-amz-if-match-last-modified-time", WNt = "x-amz-if-match-size", wd = "x-amz-meta-", n2 = "x-amz-mfa", KNt = "x-amz-metadata-directive", E2e = "x-amz-missing-meta", QNt = "x-amz-mp-object-size", YNt = "x-amz-max-parts", y2e = "x-amz-mp-parts-count", XNt = "x-amz-object-attributes", _x = "x-amz-object-lock-legal-hold", Cx = "x-amz-object-lock-mode", Rx = "x-amz-object-lock-retain-until-date", JNt = "x-amz-object-ownership", s2 = "x-amz-optional-object-attributes", ZNt = "x-amz-object-size", eBt = "x-amz-part-number-marker", S2e = "x-amz-restore", Kt = "x-amz-request-charged", tBt = "x-amz-restore-output-path", bt = "x-amz-request-payer", rBt = "x-amz-request-route", _2e = "x-amz-replication-status", oBt = "x-amz-rename-source", nBt = "x-amz-rename-source-if-match", sBt = "x-amz-rename-source-if-modified-since", iBt = "x-amz-rename-source-if-none-match", aBt = "x-amz-rename-source-if-unmodified-since", cBt = "x-amz-request-token", Ax = "x-amz-storage-class", Dt = "x-amz-sdk-checksum-algorithm", pBt = "x-amz-skip-destination-validation", C2e = "x-amz-source-expected-bucket-owner", un = "x-amz-server-side-encryption", mn = "x-amz-server-side-encryption-aws-kms-key-id", ln = "x-amz-server-side-encryption-bucket-key-enabled", tc = "x-amz-server-side-encryption-context", eo = "x-amz-server-side-encryption-customer-algorithm", xs = "x-amz-server-side-encryption-customer-key", to = "x-amz-server-side-encryption-customer-key-MD5", i2 = "x-amz-tagging", R2e = "x-amz-tagging-count", uBt = "x-amz-tagging-directive", a2 = "x-amz-transition-default-minimum-object-size", si = "x-amz-version-id", mBt = "x-amz-write-offset-bytes", Tx = "x-amz-website-redirect-location", lBt = "xsi:type", g = "com.amazonaws.s3", A2e = [0, g, SH, 8, 0], A1e = [0, g, DDt, 8, 0], Es = [0, g, zn, 8, 0], rc = [0, g, Vi, 8, 0], io = [0, g, Po, 8, 0], wx = [0, g, PDt, { [e2e]: 1 }, 42], T2e = [3, g, c0, 0, [xo], [0]], dBt = [3, g, I1e, 0, [lwt], [1]], fBt = [3, g, pTt, 0, [jt], [[0, { [d]: Kt }]]], hBt = [3, g, uTt, 0, [W, Ge, ec, Tt, X, PIt], [[0, 1], [0, 1], [0, { [te]: yx }], [0, { [d]: bt }], [0, { [d]: J }], [6, { [d]: VNt }]]], gBt = [3, g, a0, 0, [xo], [0]], w2e = [3, g, lp, 0, [O0, gs], [[() => z0, { [B]: I0 }], () => zi]], xBt = [3, g, w1e, 0, [gs], [0]], EBt = [3, g, tTt, 0, [Mt, Ed], [0, [() => Wi, { [we]: 1, [B]: Wn }]]], c2 = [3, g, Jg, 0, [Nr, qi, _He], [0, [() => w1t, 0], () => BUt]], yBt = [3, g, rTt, 0, [SHe], [() => SBt]], SBt = [3, g, gTt, 0, [g3e, STt, W, Mt], [0, 0, 0, 0]], _Bt = [3, g, D1e, 0, [AH], [[() => o1t, { [we]: 1 }]]], CBt = [3, g, W, 0, [hp, BTt, hH, dH], [0, 4, 0, 0]], RBt = [-3, g, yTt, { [Vo]: qo, [pn]: 409 }, [], []]; k.for(g).registerError(RBt, Qb); ABt = [-3, g, _Tt, { [Vo]: qo, [pn]: 409 }, [], []]; k.for(g).registerError(ABt, Yb); TBt = [3, g, CTt, 0, [pbt, gx], [0, 0]], wBt = [3, g, RTt, 0, [hx], [[() => W2e, { [we]: 1, [B]: gd }]]], bBt = [3, g, p0, 0, [LH], [[() => D2e, 0]]], IBt = [3, g, L1e, 0, [To, wo, bo, Io, vo, cn], [0, 0, 0, 0, 0, 0]], vBt = [3, g, QTt, 0, [Mt], [0]], PBt = [3, g, FTt, 0, [L0], [[() => e1t, { [we]: 1, [B]: M0 }]]], OBt = [3, g, JTt, 0, [Zr, To, wo, bo, Io, vo, gp], [0, 0, 0, 0, 0, 0, 1]], DBt = [3, g, UTt, { [B]: GTt }, [f0, W, Ge, ri, Zr, To, wo, bo, Io, vo, cn, jo, _t, Po, Ao, jt], [0, 0, 0, [0, { [d]: Sx }], 0, 0, 0, 0, 0, 0, 0, [0, { [d]: un }], [0, { [d]: si }], [() => io, { [d]: mn }], [2, { [d]: ln }], [0, { [d]: Kt }]]], kBt = [3, g, jTt, 0, [W, Ge, L3e, ec, To, wo, bo, Io, vo, cn, aPt, Tt, X, pd, dx, Br, zn, Lr], [[0, 1], [0, 1], [() => PBt, { [ot]: 1, [B]: M1e }], [0, { [te]: yx }], [0, { [d]: Ep }], [0, { [d]: yp }], [0, { [d]: Sp }], [0, { [d]: _p }], [0, { [d]: Cp }], [0, { [d]: _d }], [1, { [d]: QNt }], [0, { [d]: bt }], [0, { [d]: J }], [0, { [d]: fp }], [0, { [d]: ud }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }]]], NBt = [3, g, X1e, 0, [_It, rvt], [0, 0]], BBt = [3, g, LTt, 0, [], []], LBt = [3, g, WTt, 0, [F1e, ri, Y1e, _t, jo, Br, Lr, Po, Vi, Ao, jt], [[() => $Bt, 16], [0, { [d]: Sx }], [0, { [d]: x2e }], [0, { [d]: si }], [0, { [d]: un }], [0, { [d]: eo }], [0, { [d]: to }], [() => io, { [d]: mn }], [() => rc, { [d]: tc }], [2, { [d]: ln }], [0, { [d]: Kt }]]], MBt = [3, g, KTt, 0, [Xl, W, Jl, Ze, Zl, ed, td, rd, G1e, j1e, q1e, V1e, z1e, fs, nd, sd, id, ad, pd, dx, Ge, md, nPt, ckt, jo, Eo, xx, Br, zn, Lr, Po, Vi, Ao, W1e, SH, K1e, Tt, hs, fd, hd, dd, X, p3e], [[0, { [d]: Sd }], [0, 1], [0, { [d]: nx }], [0, { [d]: r2 }], [0, { [d]: sx }], [0, { [d]: ix }], [0, { [d]: ax }], [0, { [d]: ux }], [0, { [d]: p2e }], [0, { [d]: u2e }], [4, { [d]: m2e }], [0, { [d]: l2e }], [4, { [d]: d2e }], [4, { [d]: fs }], [0, { [d]: Cd }], [0, { [d]: Rd }], [0, { [d]: Ad }], [0, { [d]: Td }], [0, { [d]: fp }], [0, { [d]: ud }], [0, 1], [128, { [yd]: wd }], [0, { [d]: KNt }], [0, { [d]: uBt }], [0, { [d]: un }], [0, { [d]: Ax }], [0, { [d]: Tx }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], [() => io, { [d]: mn }], [() => rc, { [d]: tc }], [2, { [d]: ln }], [0, { [d]: f2e }], [() => A2e, { [d]: h2e }], [0, { [d]: g2e }], [0, { [d]: bt }], [0, { [d]: i2 }], [0, { [d]: Cx }], [5, { [d]: Rx }], [0, { [d]: _x }], [0, { [d]: J }], [0, { [d]: C2e }]]], $Bt = [3, g, F1e, 0, [Zr, ni, cn, To, wo, bo, Io, vo], [0, 4, 0, 0, 0, 0, 0, 0]], FBt = [3, g, U1e, 0, [Zr, ni, To, wo, bo, Io, vo], [0, 4, 0, 0, 0, 0, 0]], UBt = [3, g, u0, 0, [xH], [[() => z2e, { [we]: 1, [B]: EH }]]], HBt = [3, g, EH, 0, [cd, nTt, aTt, lTt, gbt, rPt], [0, [64, { [we]: 1, [B]: sTt }], [64, { [we]: 1, [B]: mTt }], [64, { [we]: 1, [B]: dTt }], [64, { [we]: 1, [B]: xbt }], 1]], GBt = [3, g, nH, 0, [iH, f0, W, Ed], [0, () => z$t, () => TBt, [() => Wi, 0]]], jBt = [3, g, PTt, 0, [W, rr, Ze, cH, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => W$t, { [ot]: 1, [B]: cH }], [0, { [d]: J }]]], qBt = [3, g, DTt, 0, [W, rr, Ze, pH, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => Y$t, { [ot]: 1, [B]: pH }], [0, { [d]: J }]]], VBt = [3, g, kTt, 0, [f0, dH], [[0, { [d]: f0 }], [0, { [d]: i2e }]]], zBt = [3, g, NTt, 0, [Xl, W, nH, nd, sd, id, IH, ad, PPt, K3e], [[0, { [d]: Sd }], [0, 1], [() => GBt, { [ot]: 1, [B]: nH }], [0, { [d]: Cd }], [0, { [d]: Rd }], [0, { [d]: Ad }], [0, { [d]: o2 }], [0, { [d]: Td }], [2, { [d]: oNt }], [0, { [d]: JNt }]]], WBt = [3, g, HTt, { [B]: kIt }, [b1e, P1e, W, Ge, ec, jo, Br, Lr, Po, Vi, Ao, jt, Ze, cn], [[4, { [d]: n2e }], [0, { [d]: s2e }], [0, { [B]: W }], 0, 0, [0, { [d]: un }], [0, { [d]: eo }], [0, { [d]: to }], [() => io, { [d]: mn }], [() => rc, { [d]: tc }], [2, { [d]: ln }], [0, { [d]: Kt }], [0, { [d]: r2 }], [0, { [d]: _d }]]], KBt = [3, g, qTt, 0, [Xl, W, Jl, Zl, ed, td, rd, fs, nd, sd, id, ad, Ge, md, jo, Eo, xx, Br, zn, Lr, Po, Vi, Ao, Tt, hs, fd, hd, dd, X, Ze, cn], [[0, { [d]: Sd }], [0, 1], [0, { [d]: nx }], [0, { [d]: sx }], [0, { [d]: ix }], [0, { [d]: ax }], [0, { [d]: ux }], [4, { [d]: fs }], [0, { [d]: Cd }], [0, { [d]: Rd }], [0, { [d]: Ad }], [0, { [d]: Td }], [0, 1], [128, { [yd]: wd }], [0, { [d]: un }], [0, { [d]: Ax }], [0, { [d]: Tx }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], [() => io, { [d]: mn }], [() => rc, { [d]: tc }], [2, { [d]: ln }], [0, { [d]: bt }], [0, { [d]: i2 }], [0, { [d]: Cx }], [5, { [d]: Rx }], [0, { [d]: _x }], [0, { [d]: J }], [0, { [d]: r2 }], [0, { [d]: _d }]]], QBt = [3, g, ewt, { [B]: twt }, [jo, Po, Vi, Ao, E1e], [[0, { [d]: un }], [() => io, { [d]: mn }], [() => rc, { [d]: tc }], [2, { [d]: ln }], [() => bUt, { [B]: E1e }]]], YBt = [3, g, owt, 0, [qDt, W, jo, Po, Vi, Ao], [[0, { [d]: iNt }], [0, 1], [0, { [d]: un }], [() => io, { [d]: mn }], [() => rc, { [d]: tc }], [2, { [d]: ln }]]], XBt = [3, g, nwt, 0, [Rbt, uwt, aHe, jH, f3e, sHe, hTt], [0, 0, 0, 0, 0, 0, 2]], JBt = [3, g, swt, 0, [nDt, aHe, jH, f3e, sHe], [0, 0, 0, 0, 0]], ZBt = [3, g, t3e, 0, [U3e, od, Mkt], [0, 1, 1]], eLt = [3, g, sH, 0, [GPt, eDt], [[() => d1t, { [we]: 1, [B]: X3e }], 2]], tLt = [3, g, hwt, 0, [W, Nr, X], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }]]], rLt = [3, g, xwt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], oLt = [3, g, ywt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], nLt = [3, g, Rwt, 0, [W, Nr, X], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }]]], sLt = [3, g, _wt, 0, [W, Nr, X], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }]]], iLt = [3, g, Twt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], aLt = [3, g, bwt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], cLt = [3, g, Owt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], pLt = [3, g, Iwt, 0, [W, Nr, X], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }]]], uLt = [3, g, kwt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], mLt = [3, g, Bwt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], lLt = [3, g, Mwt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], dLt = [3, g, Lwt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], fLt = [3, g, Uwt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], hLt = [3, g, Gwt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], gLt = [3, g, Ywt, 0, [Ge, _t, dp, Qwt], [0, 0, 2, 0]], xLt = [3, g, Kwt, 0, [gs, Ge, _t, C3e, ni], [() => zi, 0, 0, 2, 4]], ELt = [3, g, Z1e, 0, [xo], [0]], yLt = [3, g, Xwt, 0, [dp, _t, jt], [[2, { [d]: q0 }], [0, { [d]: si }], [0, { [d]: Kt }]]], SLt = [3, g, Zwt, 0, [W, Ge, $H, _t, Tt, fH, X, pd, OIt, DIt], [[0, 1], [0, 1], [0, { [d]: n2 }], [0, { [te]: zo }], [0, { [d]: bt }], [2, { [d]: t2 }], [0, { [d]: J }], [0, { [d]: fp }], [6, { [d]: zNt }], [1, { [d]: WNt }]]], _Lt = [3, g, Jwt, { [B]: ubt }, [mbt, jt, l3e], [[() => t1t, { [we]: 1 }], [0, { [d]: Kt }], [() => n1t, { [we]: 1, [B]: lx }]]], CLt = [3, g, ebt, 0, [W, sH, $H, Tt, fH, X, Ze], [[0, 1], [() => eLt, { [ot]: 1, [B]: sH }], [0, { [d]: n2 }], [0, { [d]: bt }], [2, { [d]: t2 }], [0, { [d]: J }], [0, { [d]: Dt }]]], RLt = [3, g, rbt, 0, [_t], [[0, { [d]: si }]]], ALt = [3, g, obt, 0, [W, Ge, _t, X], [[0, 1], [0, 1], [0, { [te]: zo }], [0, { [d]: J }]]], TLt = [3, g, cbt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], wLt = [3, g, P0, 0, [W, eTt, Eo, w1e, mx, xHe, F3e], [0, 0, 0, () => xBt, () => vLt, () => uUt, () => J$t]], bLt = [3, g, r3e, 0, [skt, QH, BHe], [0, 0, 0]], ILt = [3, g, TH, 0, [AH, evt, ZIt], [0, [() => io, 0], 0]], vLt = [3, g, mx, 0, [cDt], [0]], PLt = [-3, g, Sbt, { [Vo]: qo, [pn]: 400 }, [], []]; k.for(g).registerError(PLt, t0); OLt = [3, g, hbt, 0, [], []], DLt = [3, g, lx, 0, [Ge, _t, pwt, uPt], [0, 0, 0, 0]], p2 = [3, g, fbt, 0, [i3e, a3e], [0, 0]], b2e = [3, g, RH, 0, [Ge], [0]], kLt = [3, g, s3e, 0, [], []], NLt = [3, g, c3e, 0, [xo], [0]], BLt = [3, g, h3e, 0, [hp, JH], [0, 0]], LLt = [3, g, Lbt, 0, [c0], [[() => T2e, 16]]], MLt = [3, g, $bt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], $Lt = [3, g, Obt, { [B]: a0 }, [xo, jt], [0, [0, { [d]: Kt }]]], FLt = [3, g, kbt, 0, [W, X, Tt], [[0, 1], [0, { [d]: J }], [0, { [d]: bt }]]], ULt = [3, g, Mbt, { [B]: lp }, [gs, O0], [() => zi, [() => z0, { [B]: I0 }]]], HLt = [3, g, Fbt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], GLt = [3, g, Dbt, 0, [Jg], [[() => c2, 16]]], jLt = [3, g, Nbt, 0, [W, Nr, X], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }]]], qLt = [3, g, Gbt, { [B]: u0 }, [xH], [[() => z2e, { [we]: 1, [B]: EH }]]], VLt = [3, g, jbt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], zLt = [3, g, Vbt, 0, [T0], [[() => q2e, 16]]], WLt = [3, g, zbt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], KLt = [3, g, Xbt, 0, [ex], [[() => u2, 16]]], QLt = [3, g, Jbt, 0, [W, Nr, X], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }]]], YLt = [3, g, Kbt, 0, [Zg], [[() => m2, 16]]], XLt = [3, g, Qbt, 0, [W, Nr, X], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }]]], JLt = [3, g, t0t, { [B]: aH }, [hx, XH], [[() => W2e, { [we]: 1, [B]: gd }], [0, { [d]: a2 }]]], ZLt = [3, g, r0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], eMt = [3, g, o0t, { [B]: iH }, [iH], [0]], tMt = [3, g, s0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], rMt = [3, g, n0t, { [B]: p0 }, [LH], [[() => D2e, 0]]], oMt = [3, g, i0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], nMt = [3, g, p0t, 0, [x3e], [[() => iMt, 16]]], sMt = [3, g, m0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], iMt = [3, g, x3e, 0, [O3e], [() => K$t]], aMt = [3, g, h0t, 0, [E3e], [[() => pMt, 16]]], cMt = [3, g, g0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], pMt = [3, g, E3e, 0, [B3e, xo, lx], [() => X$t, 0, () => p2]], uMt = [3, g, u0t, 0, [tx], [[() => d2, 16]]], mMt = [3, g, l0t, 0, [W, Nr, X], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }]]], lMt = [3, g, E0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], dMt = [3, g, S0t, 0, [g0], [[() => $2e, 16]]], fMt = [3, g, _0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], hMt = [3, g, R0t, 0, [rHe], [[0, 16]]], gMt = [3, g, A0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], xMt = [3, g, w0t, 0, [J3e], [[() => yFt, 16]]], EMt = [3, g, b0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], yMt = [3, g, v0t, 0, [S0], [[() => H2e, 16]]], SMt = [3, g, k0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], _Mt = [3, g, O0t, { [B]: _0 }, [Z3e], [0]], CMt = [3, g, D0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], RMt = [3, g, B0t, { [B]: hs }, [U0], [[() => Wi, 0]]], AMt = [3, g, L0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], TMt = [3, g, $0t, { [B]: w0 }, [xo, N3e], [0, [0, { [B]: D3e }]]], wMt = [3, g, F0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], bMt = [3, g, H0t, { [B]: b0 }, [GH, OH, RH, qH], [() => U2e, () => v2e, () => b2e, [() => Q2e, 0]]], IMt = [3, g, G0t, 0, [W, X], [[0, 1], [0, { [d]: J }]]], vMt = [3, g, V0t, { [B]: lp }, [gs, O0, jt], [() => zi, [() => z0, { [B]: I0 }], [0, { [d]: Kt }]]], PMt = [3, g, K0t, 0, [W, Ge, _t, Tt, X], [[0, 1], [0, 1], [0, { [te]: zo }], [0, { [d]: bt }], [0, { [d]: J }]]], OMt = [3, g, z0t, { [B]: Q0t }, [dp, ni, _t, jt, Zr, L1e, LPt, Eo, $Pt], [[2, { [d]: q0 }], [4, { [d]: MH }], [0, { [d]: si }], [0, { [d]: Kt }], 0, () => IBt, [() => DMt, 0], 0, 1]], DMt = [3, g, W0t, 0, [fkt, B0, q3e, k0, oi, L0], [[1, { [B]: N0 }], 0, 0, 1, 2, [() => x1t, { [we]: 1, [B]: M0 }]]], kMt = [3, g, Y0t, 0, [W, Ge, _t, k0, B0, Br, zn, Lr, Tt, X, CPt], [[0, 1], [0, 1], [0, { [te]: zo }], [1, { [d]: YNt }], [0, { [d]: eBt }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], [0, { [d]: bt }], [0, { [d]: J }], [64, { [d]: XNt }]]], NMt = [3, g, rIt, 0, [h0], [[() => B2e, { [ot]: 1, [B]: h0 }]]], BMt = [3, g, oIt, 0, [W, Ge, _t, Tt, X], [[0, 1], [0, 1], [0, { [te]: zo }], [0, { [d]: bt }], [0, { [d]: J }]]], LMt = [3, g, Z0t, 0, [x0], [[() => N2e, 16]]], MMt = [3, g, eIt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], $Mt = [3, g, nIt, 0, [ox, dp, lH, ri, WH, ni, px, Zr, To, wo, bo, Io, vo, cn, FH, _t, Jl, Zl, ed, td, yH, rd, fs, m0, xx, jo, md, Br, Lr, Po, Ao, Eo, jt, VH, N0, YH, fd, hd, dd], [[() => wx, 16], [2, { [d]: q0 }], [0, { [d]: VHe }], [0, { [d]: Sx }], [0, { [d]: S2e }], [4, { [d]: MH }], [1, { [d]: cx }], [0, { [d]: Zr }], [0, { [d]: Ep }], [0, { [d]: yp }], [0, { [d]: Sp }], [0, { [d]: _p }], [0, { [d]: Cp }], [0, { [d]: _d }], [1, { [d]: E2e }], [0, { [d]: si }], [0, { [d]: nx }], [0, { [d]: sx }], [0, { [d]: ix }], [0, { [d]: ax }], [0, { [d]: H1e }], [0, { [d]: ux }], [4, { [d]: fs }], [0, { [d]: m0 }], [0, { [d]: Tx }], [0, { [d]: un }], [128, { [yd]: wd }], [0, { [d]: eo }], [0, { [d]: to }], [() => io, { [d]: mn }], [2, { [d]: ln }], [0, { [d]: Ax }], [0, { [d]: Kt }], [0, { [d]: _2e }], [1, { [d]: y2e }], [1, { [d]: R2e }], [0, { [d]: Cx }], [5, { [d]: Rx }], [0, { [d]: _x }]]], FMt = [3, g, sIt, 0, [W, pd, R3e, dx, w3e, Ge, C0, cHe, pHe, uHe, mHe, lHe, dHe, _t, Br, zn, Lr, Tt, gp, X, $1e], [[0, 1], [0, { [d]: fp }], [4, { [d]: DH }], [0, { [d]: ud }], [4, { [d]: NH }], [0, 1], [0, { [d]: C0 }], [0, { [te]: KHe }], [0, { [te]: QHe }], [0, { [te]: YHe }], [0, { [te]: XHe }], [0, { [te]: JHe }], [6, { [te]: ZHe }], [0, { [te]: zo }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], [0, { [d]: bt }], [1, { [te]: j0 }], [0, { [d]: J }], [0, { [d]: c2e }]]], UMt = [3, g, iIt, 0, [R0], [[() => L2e, { [ot]: 1, [B]: R0 }]]], HMt = [3, g, aIt, 0, [W, Ge, _t, Tt, X], [[0, 1], [0, 1], [0, { [te]: zo }], [0, { [d]: bt }], [0, { [d]: J }]]], GMt = [3, g, uIt, { [B]: hs }, [_t, U0], [[0, { [d]: si }], [() => Wi, 0]]], jMt = [3, g, lIt, 0, [W, Ge, _t, X, Tt], [[0, 1], [0, 1], [0, { [te]: zo }], [0, { [d]: J }], [0, { [d]: bt }]]], qMt = [3, g, mIt, 0, [ox, jt], [[() => wx, 16], [0, { [d]: Kt }]]], VMt = [3, g, dIt, 0, [W, Ge, Tt, X], [[0, 1], [0, 1], [0, { [d]: bt }], [0, { [d]: J }]]], zMt = [3, g, gIt, 0, [E0], [[() => F2e, 16]]], WMt = [3, g, xIt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], KMt = [3, g, y3e, 0, [$He], [0]], QMt = [3, g, vH, 0, [PH, tHe], [[() => I2e, { [o2e]: [r2e, zHe] }], 0]], I2e = [3, g, PH, 0, [CH, dbt, cd, Pkt, gx], [0, 0, 0, 0, [0, { [Jkt]: 1, [B]: lBt }]]], YMt = [3, g, yIt, 0, [dH, TTt, ATt, hH, fTt], [[0, { [d]: i2e }], [0, { [d]: rNt }], [0, { [d]: tNt }], [0, { [d]: nNt }], [2, { [d]: Zkt }]]], XMt = [3, g, SIt, 0, [W, X], [[0, 1], [0, { [d]: J }]]], JMt = [3, g, RIt, 0, [dp, lH, ri, WH, ETt, ni, px, To, wo, bo, Io, vo, cn, Zr, FH, _t, Jl, Zl, ed, td, rd, yH, fs, m0, xx, jo, md, Br, Lr, Po, Ao, Eo, jt, VH, N0, YH, fd, hd, dd], [[2, { [d]: q0 }], [0, { [d]: VHe }], [0, { [d]: Sx }], [0, { [d]: S2e }], [0, { [d]: eNt }], [4, { [d]: MH }], [1, { [d]: cx }], [0, { [d]: Ep }], [0, { [d]: yp }], [0, { [d]: Sp }], [0, { [d]: _p }], [0, { [d]: Cp }], [0, { [d]: _d }], [0, { [d]: Zr }], [1, { [d]: E2e }], [0, { [d]: si }], [0, { [d]: nx }], [0, { [d]: sx }], [0, { [d]: ix }], [0, { [d]: ax }], [0, { [d]: ux }], [0, { [d]: H1e }], [4, { [d]: fs }], [0, { [d]: m0 }], [0, { [d]: Tx }], [0, { [d]: un }], [128, { [yd]: wd }], [0, { [d]: eo }], [0, { [d]: to }], [() => io, { [d]: mn }], [2, { [d]: ln }], [0, { [d]: Ax }], [0, { [d]: Kt }], [0, { [d]: _2e }], [1, { [d]: y2e }], [1, { [d]: R2e }], [0, { [d]: Cx }], [5, { [d]: Rx }], [0, { [d]: _x }]]], ZMt = [3, g, AIt, 0, [W, pd, R3e, dx, w3e, Ge, C0, cHe, pHe, uHe, mHe, lHe, dHe, _t, Br, zn, Lr, Tt, gp, X, $1e], [[0, 1], [0, { [d]: fp }], [4, { [d]: DH }], [0, { [d]: ud }], [4, { [d]: NH }], [0, 1], [0, { [d]: C0 }], [0, { [te]: KHe }], [0, { [te]: QHe }], [0, { [te]: YHe }], [0, { [te]: XHe }], [0, { [te]: JHe }], [6, { [te]: ZHe }], [0, { [te]: zo }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], [0, { [d]: bt }], [1, { [te]: j0 }], [0, { [d]: J }], [0, { [d]: c2e }]]], e$t = [-3, g, MIt, { [Vo]: qo, [pn]: 400 }, [], []]; k.for(g).registerError(e$t, s0); v2e = [3, g, OH, 0, [rkt], [0]], P2e = [3, g, BH, 0, [cd, CH], [0, 0]], O2e = [3, g, kH, 0, [Q1e, cwt, b3e, JOt], [() => XBt, 0, () => x$t, () => gFt]], t$t = [3, g, GIt, 0, [Mt, Ed], [0, [() => Wi, { [we]: 1, [B]: Wn }]]], u2 = [3, g, ex, 0, [Nr, qi, xo, hkt], [0, [() => r$t, 0], 0, [() => C1t, { [we]: 1, [B]: FHe }]]], r$t = [3, g, qIt, 0, [Mt, Wn, rx], [0, () => bd, [() => t$t, 0]]], o$t = [-3, g, BIt, { [Vo]: qo, [pn]: 403 }, [Eo, O1e], [0, 0]]; k.for(g).registerError(o$t, Jb); n$t = [-3, g, $It, { [Vo]: qo, [pn]: 400 }, [], []]; k.for(g).registerError(n$t, r0); s$t = [-3, g, VIt, { [Vo]: qo, [pn]: 400 }, [], []]; k.for(g).registerError(s$t, o0); m2 = [3, g, Zg, 0, [P0, bIt, qi, Nr, LIt, wPt, ekt], [[() => i$t, 0], 2, () => c$t, 0, 0, [() => c1t, 0], () => u$t]], i$t = [3, g, wIt, 0, [SHe], [[() => p$t, 0]]], a$t = [3, g, IIt, 0, [vHe, IHe], [[() => DUt, { [B]: wHe }], [() => PUt, { [B]: CHe }]]], c$t = [3, g, vIt, 0, [Mt], [0]], p$t = [3, g, UIt, 0, [iTt, W, g3e, Mt, TH], [0, 0, 0, 0, [() => a$t, 0]]], u$t = [3, g, HIt, 0, [Ibt], [0]], m$t = [3, g, l0, 0, [_H, mx], [0, () => l2]], l$t = [3, g, T3e, 0, [_H, MHe, lx, F0, KH], [0, 0, () => p2, 0, 0]], d$t = [3, g, jIt, 0, [_H, mx], [0, () => l2]], f$t = [3, g, d0, 0, [$0, mx], [() => h2, () => l2]], h$t = [3, g, I3e, 0, [MHe, lx, F0, KH, $0], [0, () => p2, 0, 0, () => h2]], g$t = [3, g, QIt, 0, [$0], [() => h2]], x$t = [3, g, WIt, 0, [gx], [0]], E$t = [3, g, KIt, 0, [jH], [0]], y$t = [3, g, wvt, 0, [Nr, Tvt, wH, qi], [0, [0, { [B]: MTt }], [64, { [we]: 1, [B]: bH }], [() => f2, 0]]], S$t = [3, g, Avt, 0, [o3e, od, Ebt], [5, 1, 2]], _$t = [3, g, Yvt, 0, [ri, cd, Mt, qi, xo, Ekt, SPt, V3e, I1e], [() => S$t, 0, 0, [() => R$t, 0], 0, [() => A1t, { [we]: 1, [B]: HHe }], [() => l1t, { [we]: 1, [B]: z3e }], () => tFt, () => dBt]], C$t = [3, g, Xvt, 0, [Mt, Ed, Q3e, Y3e], [0, [() => Wi, { [we]: 1, [B]: Wn }], 1, 1]], R$t = [3, g, Jvt, 0, [Mt, Wn, Q3e, Y3e, rx], [0, () => bd, 1, 1, [() => C$t, 0]]], A$t = [3, g, avt, { [B]: cvt }, [oi, Go, fx, T1e], [2, 0, 0, [() => ZUt, { [we]: 1, [B]: Jg }]]], T$t = [3, g, pvt, 0, [W, Go, X], [[0, 1], [0, { [te]: xp }], [0, { [d]: J }]]], w$t = [3, g, fvt, 0, [oi, Go, fx, A3e], [2, 0, 0, [() => i1t, { [we]: 1, [B]: ex }]]], b$t = [3, g, hvt, 0, [W, Go, X], [[0, 1], [0, { [te]: xp }], [0, { [d]: J }]]], I$t = [3, g, mvt, { [B]: Pvt }, [Go, _3e, oi, fx], [0, [() => a1t, { [we]: 1, [B]: Zg }], 2, 0]], v$t = [3, g, lvt, 0, [W, Go, X], [[0, 1], [0, { [te]: xp }], [0, { [d]: J }]]], P$t = [3, g, xvt, { [B]: Ovt }, [oi, Go, fx, P3e], [2, 0, 0, [() => u1t, { [we]: 1, [B]: tx }]]], O$t = [3, g, Evt, 0, [W, Go, X], [[0, 1], [0, { [te]: xp }], [0, { [d]: J }]]], D$t = [3, g, yvt, { [B]: ovt }, [gH, gs, Go, Mt], [[() => V2e, 0], () => zi, 0, 0]], k$t = [3, g, Svt, 0, [oPt, Go, Mt, hH], [[1, { [te]: qkt }], [0, { [te]: xp }], [0, { [te]: Ex }], [0, { [te]: $kt }]]], N$t = [3, g, Cvt, { [B]: nvt }, [gH, Go], [[() => V2e, 0], 0]], B$t = [3, g, Rvt, 0, [Go, sPt], [[0, { [te]: xp }], [1, { [te]: Vkt }]]], L$t = [3, g, Nvt, { [B]: Bvt }, [W, D0, GHe, G3e, Mt, Ja, EPt, M3e, oi, ykt, v0, Za, jt], [0, 0, 0, 0, 0, 0, 0, 1, 2, [() => m1t, { [we]: 1, [B]: Okt }], [() => V0, { [we]: 1 }], 0, [0, { [d]: Kt }]]], M$t = [3, g, Lvt, 0, [W, Ja, Za, D0, M3e, Mt, GHe, X, Tt], [[0, 1], [0, { [te]: H0 }], [0, { [te]: G0 }], [0, { [te]: WHe }], [1, { [te]: Wkt }], [0, { [te]: Ex }], [0, { [te]: Ykt }], [0, { [d]: J }], [0, { [d]: bt }]]], $$t = [3, g, $vt, { [B]: v3e }, [oi, $3e, fPt, J1e, hp, Mt, Ja, ld, v0, Za, jt], [2, 0, 0, [() => K2e, { [we]: 1 }], 0, 0, 0, 1, [() => V0, { [we]: 1 }], 0, [0, { [d]: Kt }]]], F$t = [3, g, Fvt, 0, [W, Ja, Za, $3e, ld, Mt, Tt, X, UH], [[0, 1], [0, { [te]: H0 }], [0, { [te]: G0 }], [0, { [te]: jkt }], [1, { [te]: e2 }], [0, { [te]: Ex }], [0, { [d]: bt }], [0, { [d]: J }], [64, { [d]: s2 }]]], U$t = [3, g, Hvt, { [B]: v3e }, [oi, J1e, hp, Mt, Ja, ld, v0, Za, YIt, Go, fx, yHe, jt], [2, [() => K2e, { [we]: 1 }], 0, 0, 0, 1, [() => V0, { [we]: 1 }], 0, 1, 0, 0, 0, [0, { [d]: Kt }]]], H$t = [3, g, jvt, 0, [W, Ja, Za, ld, Mt, Go, Abt, yHe, Tt, X, UH], [[0, 1], [0, { [te]: H0 }], [0, { [te]: G0 }], [1, { [te]: e2 }], [0, { [te]: Ex }], [0, { [te]: xp }], [2, { [te]: Ukt }], [0, { [te]: Qkt }], [0, { [d]: bt }], [0, { [d]: J }], [64, { [d]: s2 }]]], G$t = [3, g, Gvt, { [B]: ePt }, [oi, D0, qHe, G3e, yPt, Dkt, e3e, hp, Mt, Ja, ld, v0, Za, jt], [2, 0, 0, 0, 0, [() => f1t, { [we]: 1, [B]: kkt }], [() => r1t, { [we]: 1, [B]: dp }], 0, 0, 0, 1, [() => V0, { [we]: 1 }], 0, [0, { [d]: Kt }]]], j$t = [3, g, qvt, 0, [W, Ja, Za, D0, ld, Mt, qHe, X, Tt, UH], [[0, 1], [0, { [te]: H0 }], [0, { [te]: G0 }], [0, { [te]: WHe }], [1, { [te]: e2 }], [0, { [te]: Ex }], [0, { [te]: Xkt }], [0, { [d]: J }], [0, { [d]: bt }], [64, { [d]: s2 }]]], q$t = [3, g, Wvt, { [B]: Kvt }, [b1e, P1e, W, Ge, ec, B0, q3e, k0, oi, L0, BH, gs, Eo, jt, Ze, cn], [[4, { [d]: n2e }], [0, { [d]: s2e }], 0, 0, 0, 0, 0, 1, 2, [() => g1t, { [we]: 1, [B]: M0 }], () => P2e, () => zi, 0, [0, { [d]: Kt }], 0, 0]], V$t = [3, g, Qvt, 0, [W, Ge, k0, B0, ec, Tt, X, Br, zn, Lr], [[0, 1], [0, 1], [1, { [te]: zkt }], [0, { [te]: Kkt }], [0, { [te]: yx }], [0, { [d]: bt }], [0, { [d]: J }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }]]], z$t = [3, g, vvt, 0, [gx, hp], [0, 0]], D2e = [3, g, LH, 0, [nkt, NHe, dkt, LHe], [0, [() => _1t, 0], 0, [() => $Ut, 0]]], W$t = [3, g, cH, 0, [d0, l0], [() => f$t, () => m$t]], K$t = [3, g, O3e, 0, [r3e, I3e, T3e], [() => bLt, () => h$t, () => l$t]], Q$t = [3, g, k3e, 0, [hp, JH], [0, 0]], Y$t = [3, g, pH, 0, [PHe], [() => yUt]], X$t = [3, g, B3e, 0, [OHe], [() => SUt]], l2 = [3, g, cPt, 0, [vDt, JIt], [0, 0]], J$t = [3, g, F3e, 0, [xo, _bt], [0, () => G2e]], Z$t = [3, g, tPt, 0, [Mt, Ed, v1e], [0, [() => Wi, { [we]: 1, [B]: Wn }], 0]], d2 = [3, g, tx, 0, [Nr, qi], [0, [() => b1t, 0]]], eFt = [3, g, L3e, 0, [ec, Ge, zIt, Eo, gs, BH, Ze, cn], [0, 0, 4, 0, () => zi, () => P2e, 0, 0]], tFt = [3, g, V3e, 0, [H3e, j3e], [1, 1]], rFt = [3, g, z3e, 0, [H3e, Eo, j3e], [1, 0, 1]], oFt = [-3, g, hPt, { [Vo]: qo, [pn]: 404 }, [], []]; k.for(g).registerError(oFt, Xb); nFt = [-3, g, gPt, { [Vo]: qo, [pn]: 404 }, [], []]; k.for(g).registerError(nFt, Zb); sFt = [-3, g, xPt, { [Vo]: qo, [pn]: 404 }, [], []]; k.for(g).registerError(sFt, Wb); iFt = [-3, g, dPt, { [Vo]: qo }, [], []]; k.for(g).registerError(iFt, e0); k2e = [3, g, uH, 0, [akt, oDt, Ivt, s3e], [[() => R1t, { [we]: 1, [B]: kHe }], [() => E1t, { [we]: 1, [B]: iHe }], [() => p1t, { [we]: 1, [B]: $Tt }], () => kLt]], f2 = [3, g, lPt, 0, [Ge], [[() => xUt, { [B]: GDt }]]], aFt = [3, g, X3e, 0, [Ge, ni, Zr, Ze, cn, xd, Eo, gs, zH], [0, 4, 0, [64, { [we]: 1 }], 0, 1, 0, () => zi, () => j2e]], cFt = [-3, g, RPt, { [Vo]: qo, [pn]: 403 }, [], []]; k.for(g).registerError(cFt, i0); pFt = [3, g, bPt, 0, [Ge, _t, Zr, Dvt, xd], [0, 0, 0, 6, 1]], N2e = [3, g, x0, 0, [vPt, gd], [0, () => uFt]], B2e = [3, g, OPt, 0, [xo], [0]], L2e = [3, g, DPt, 0, [U3e, wDt], [0, 5]], uFt = [3, g, kPt, 0, [t3e], [() => ZBt]], mFt = [-3, g, BPt, { [Vo]: qo, [pn]: 403 }, [], []]; k.for(g).registerError(mFt, Kb); lFt = [3, g, MPt, 0, [gp, xd, To, wo, bo, Io, vo], [1, 1, 0, 0, 0, 0, 0]], dFt = [3, g, UPt, 0, [Zr, Ze, cn, xd, Eo, Ge, _t, C3e, ni, gs, zH], [0, [64, { [we]: 1 }], 0, 1, 0, 0, 0, 2, 4, () => zi, () => j2e]], fFt = [3, g, W3e, 0, [ZDt], [[() => EUt, 0]]], M2e = [3, g, HH, 0, [Q1e, b3e], [() => JBt, () => E$t]], zi = [3, g, gs, 0, [CH, cd], [0, 0]], $2e = [3, g, g0, 0, [hx], [[() => h1t, { [we]: 1, [B]: gd }]]], hFt = [3, g, APt, 0, [K3e], [0]], gFt = [3, g, POt, 0, [], []], xFt = [3, g, M0, 0, [gp, ni, Zr, xd, To, wo, bo, Io, vo], [1, 4, 0, 1, 0, 0, 0, 0, 0]], EFt = [3, g, y0, { [B]: y0 }, [IOt], [0]], yFt = [3, g, J3e, 0, [y1e], [[2, { [B]: y1e }]]], SFt = [3, g, oHe, 0, [B1e, k1e, N1e], [1, 1, 1]], _Ft = [3, g, vOt, 0, [n3e], [[() => SFt, { [ZH]: 1 }]]], F2e = [3, g, E0, 0, [g1e, S1e, x1e, _1e], [[2, { [B]: g1e }], [2, { [B]: S1e }], [2, { [B]: x1e }], [2, { [B]: _1e }]]], CFt = [3, g, KPt, 0, [W, rr, Ze, X, c0], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: J }], [() => T2e, { [ot]: 1, [B]: c0 }]]], RFt = [3, g, VPt, 0, [W, a0, X, Ze], [[0, 1], [() => gBt, { [ot]: 1, [B]: a0 }], [0, { [d]: J }], [0, { [d]: Dt }]]], AFt = [3, g, QPt, 0, [Xl, lp, W, rr, Ze, nd, sd, id, IH, ad, X], [[0, { [d]: Sd }], [() => w2e, { [ot]: 1, [B]: lp }], [0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: Cd }], [0, { [d]: Rd }], [0, { [d]: Ad }], [0, { [d]: o2 }], [0, { [d]: Td }], [0, { [d]: J }]]], TFt = [3, g, zPt, 0, [W, Nr, Jg, X], [[0, 1], [0, { [te]: Kn }], [() => c2, { [ot]: 1, [B]: Jg }], [0, { [d]: J }]]], wFt = [3, g, JPt, 0, [W, u0, rr, Ze, X], [[0, 1], [() => UBt, { [ot]: 1, [B]: u0 }], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: J }]]], bFt = [3, g, eOt, 0, [W, rr, Ze, T0, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => q2e, { [ot]: 1, [B]: T0 }], [0, { [d]: J }]]], IFt = [3, g, nOt, 0, [W, Nr, X, ex], [[0, 1], [0, { [te]: Kn }], [0, { [d]: J }], [() => u2, { [ot]: 1, [B]: ex }]]], vFt = [3, g, rOt, 0, [W, Nr, Zg, X], [[0, 1], [0, { [te]: Kn }], [() => m2, { [ot]: 1, [B]: Zg }], [0, { [d]: J }]]], PFt = [3, g, aOt, 0, [XH], [[0, { [d]: a2 }]]], OFt = [3, g, cOt, 0, [W, Ze, aH, X, XH], [[0, 1], [0, { [d]: Dt }], [() => wBt, { [ot]: 1, [B]: aH }], [0, { [d]: J }], [0, { [d]: a2 }]]], DFt = [3, g, pOt, 0, [W, p0, rr, Ze, X], [[0, 1], [() => bBt, { [ot]: 1, [B]: p0 }], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: J }]]], kFt = [3, g, mOt, 0, [W, Nr, tx, X], [[0, 1], [0, { [te]: Kn }], [() => d2, { [ot]: 1, [B]: tx }], [0, { [d]: J }]]], NFt = [3, g, dOt, 0, [W, uH, X, BDt], [[0, 1], [() => k2e, { [ot]: 1, [B]: uH }], [0, { [d]: J }], [2, { [d]: pBt }]]], BFt = [3, g, hOt, 0, [W, rr, X, g0, Ze], [[0, 1], [0, { [d]: tr }], [0, { [d]: J }], [() => $2e, { [ot]: 1, [B]: g0 }], [0, { [d]: Dt }]]], LFt = [3, g, xOt, 0, [W, rr, Ze, ZTt, rHe, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [2, { [d]: sNt }], [0, 16], [0, { [d]: J }]]], MFt = [3, g, _Ot, 0, [W, rr, Ze, S0, UHe, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => H2e, { [ot]: 1, [B]: S0 }], [0, { [d]: a2e }], [0, { [d]: J }]]], $Ft = [3, g, SOt, 0, [W, rr, Ze, _0, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => mUt, { [ot]: 1, [B]: _0 }], [0, { [d]: J }]]], FFt = [3, g, ROt, 0, [W, rr, Ze, hs, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => g2, { [ot]: 1, [B]: hs }], [0, { [d]: J }]]], UFt = [3, g, TOt, 0, [W, rr, Ze, $H, w0, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: n2 }], [() => QUt, { [ot]: 1, [B]: w0 }], [0, { [d]: J }]]], HFt = [3, g, bOt, 0, [W, rr, Ze, b0, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => YUt, { [ot]: 1, [B]: b0 }], [0, { [d]: J }]]], GFt = [3, g, NOt, 0, [jt], [[0, { [d]: Kt }]]], jFt = [3, g, BOt, 0, [Xl, lp, W, rr, Ze, nd, sd, id, IH, ad, Ge, Tt, _t, X], [[0, { [d]: Sd }], [() => w2e, { [ot]: 1, [B]: lp }], [0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: Cd }], [0, { [d]: Rd }], [0, { [d]: Ad }], [0, { [d]: o2 }], [0, { [d]: Td }], [0, 1], [0, { [d]: bt }], [0, { [te]: zo }], [0, { [d]: J }]]], qFt = [3, g, UOt, 0, [jt], [[0, { [d]: Kt }]]], VFt = [3, g, HOt, 0, [W, Ge, h0, Tt, _t, rr, Ze, X], [[0, 1], [0, 1], [() => B2e, { [ot]: 1, [B]: h0 }], [0, { [d]: bt }], [0, { [te]: zo }], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: J }]]], zFt = [3, g, MOt, 0, [jt], [[0, { [d]: Kt }]]], WFt = [3, g, $Ot, 0, [W, x0, Tt, UHe, rr, Ze, X], [[0, 1], [() => N2e, { [ot]: 1, [B]: x0 }], [0, { [d]: bt }], [0, { [d]: a2e }], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: J }]]], KFt = [3, g, GOt, 0, [ri, Zr, To, wo, bo, Io, vo, cn, jo, _t, Br, Lr, Po, Vi, Ao, xd, jt], [[0, { [d]: Sx }], [0, { [d]: Zr }], [0, { [d]: Ep }], [0, { [d]: yp }], [0, { [d]: Sp }], [0, { [d]: _p }], [0, { [d]: Cp }], [0, { [d]: _d }], [0, { [d]: un }], [0, { [d]: si }], [0, { [d]: eo }], [0, { [d]: to }], [() => io, { [d]: mn }], [() => rc, { [d]: tc }], [2, { [d]: ln }], [1, { [d]: ZNt }], [0, { [d]: Kt }]]], QFt = [3, g, jOt, 0, [Xl, ox, W, Jl, Zl, ed, td, px, rr, rd, Ze, To, wo, bo, Io, vo, fs, pd, dx, nd, sd, id, ad, Ge, Lkt, md, jo, Eo, xx, Br, zn, Lr, Po, Vi, Ao, Tt, hs, fd, hd, dd, X], [[0, { [d]: Sd }], [() => wx, 16], [0, 1], [0, { [d]: nx }], [0, { [d]: sx }], [0, { [d]: ix }], [0, { [d]: ax }], [1, { [d]: cx }], [0, { [d]: tr }], [0, { [d]: ux }], [0, { [d]: Dt }], [0, { [d]: Ep }], [0, { [d]: yp }], [0, { [d]: Sp }], [0, { [d]: _p }], [0, { [d]: Cp }], [4, { [d]: fs }], [0, { [d]: fp }], [0, { [d]: ud }], [0, { [d]: Cd }], [0, { [d]: Rd }], [0, { [d]: Ad }], [0, { [d]: Td }], [0, 1], [1, { [d]: mBt }], [128, { [yd]: wd }], [0, { [d]: un }], [0, { [d]: Ax }], [0, { [d]: Tx }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], [() => io, { [d]: mn }], [() => rc, { [d]: tc }], [2, { [d]: ln }], [0, { [d]: bt }], [0, { [d]: i2 }], [0, { [d]: Cx }], [5, { [d]: Rx }], [0, { [d]: _x }], [0, { [d]: J }]]], YFt = [3, g, qOt, 0, [jt], [[0, { [d]: Kt }]]], XFt = [3, g, VOt, 0, [W, Ge, R0, Tt, _t, fH, rr, Ze, X], [[0, 1], [0, 1], [() => L2e, { [ot]: 1, [B]: R0 }], [0, { [d]: bt }], [0, { [te]: zo }], [2, { [d]: t2 }], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: J }]]], JFt = [3, g, KOt, 0, [_t], [[0, { [d]: si }]]], ZFt = [3, g, QOt, 0, [W, Ge, _t, rr, Ze, hs, X, Tt], [[0, 1], [0, 1], [0, { [te]: zo }], [0, { [d]: tr }], [0, { [d]: Dt }], [() => g2, { [ot]: 1, [B]: hs }], [0, { [d]: J }], [0, { [d]: bt }]]], eUt = [3, g, XOt, 0, [W, rr, Ze, E0, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => F2e, { [ot]: 1, [B]: E0 }], [0, { [d]: J }]]], tUt = [3, g, iHe, 0, [Nr, tDt, wH, qi], [0, [0, { [B]: sDt }], [64, { [we]: 1, [B]: bH }], [() => f2, 0]]], h2 = [3, g, $0, 0, [ri, od], [0, 1]], rUt = [3, g, aDt, 0, [eHe], [[21, { [ZH]: 1 }]]], oUt = [3, g, EHe, 0, [S3e, TIt, nHe, pDt, uDt], [0, 0, 0, 0, 0]], U2e = [3, g, GH, 0, [S3e, nHe], [0, 0]], nUt = [3, g, lDt, 0, [], []], sUt = [3, g, hDt, 0, [W, Ge, RDt, qwt, zwt, Vwt, Wwt, MDt, FDt, $Dt, UDt, awt], [[0, 1], [0, 1], [0, { [d]: oBt }], [0, { [d]: fp }], [0, { [d]: ud }], [4, { [d]: DH }], [4, { [d]: NH }], [0, { [d]: nBt }], [0, { [d]: iBt }], [6, { [d]: sBt }], [6, { [d]: aBt }], [0, { [d]: cNt, [Gkt]: 1 }]]], iUt = [3, g, fHe, 0, [xo], [0]], H2e = [3, g, S0, 0, [IDt, hx], [0, [() => y1t, { [we]: 1, [B]: gd }]]], aUt = [3, g, SDt, 0, [cd, ZOt, Mt, qi, xo, bHe, c3e, P0, Z1e], [0, 1, 0, [() => pUt, 0], 0, () => vUt, () => NLt, () => wLt, () => ELt]], cUt = [3, g, EDt, 0, [Mt, Ed], [0, [() => Wi, { [we]: 1, [B]: Wn }]]], pUt = [3, g, yDt, 0, [Mt, Wn, rx], [0, () => bd, [() => cUt, 0]]], uUt = [3, g, xHe, 0, [xo, gkt], [0, () => G2e]], G2e = [3, g, ADt, 0, [mPt], [1]], mUt = [3, g, _0, 0, [Z3e], [0]], lUt = [3, g, hHe, 0, [Cbt], [2]], dUt = [3, g, dDt, 0, [jt, fDt], [[0, { [d]: Kt }], [0, { [d]: tBt }]]], fUt = [3, g, gDt, 0, [W, Ge, _t, mH, Tt, Ze, X], [[0, 1], [0, 1], [0, { [te]: zo }], [() => hUt, { [ot]: 1, [B]: mH }], [0, { [d]: bt }], [0, { [d]: Dt }], [0, { [d]: J }]]], hUt = [3, g, mH, 0, [od, y3e, gx, $He, lbt, AHe, W3e], [1, () => KMt, 0, 0, 0, () => AUt, [() => fFt, 0]]], j2e = [3, g, zH, 0, [FIt, iDt], [2, 4]], gUt = [3, g, gHe, 0, [X1e, EHe], [() => NBt, () => oUt]], xUt = [3, g, HDt, 0, [wbt], [[() => s1t, { [we]: 1, [B]: h3e }]]], EUt = [3, g, jDt, 0, [wTt, Mt, TH, bTt, I0, hs, jHe, Eo], [0, 0, [() => ILt, 0], 0, [() => z0, 0], [() => g2, 0], [() => T1t, 0], 0]], yUt = [3, g, PHe, 0, [QH, F0], [0, 0]], SUt = [3, g, OHe, 0, [QH, F0, KH, BHe], [0, 0, 0, 0]], _Ut = [3, g, THe, 0, [tkt, m3e], [1, 1]], CUt = [3, g, WDt, 0, [eHe], [[() => I1t, 16]]], RUt = [3, g, KDt, 0, [W, Ge, Br, zn, Lr, d3e, u3e, hHe, kH, HH, THe, X], [[0, 1], [0, 1], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], 0, 0, () => lUt, () => O2e, () => M2e, () => _Ut, [0, { [d]: J }]]], AUt = [3, g, AHe, 0, [kH, u3e, d3e, HH], [() => O2e, 0, 0, () => M2e]], TUt = [3, g, YDt, 0, [QDt, tvt], [0, [() => io, 0]]], q2e = [3, g, T0, 0, [hx], [[() => S1t, { [we]: 1, [B]: gd }]]], wUt = [3, g, XDt, 0, [xTt, Ao, D1e], [[() => TUt, 0], 2, [() => _Bt, 0]]], bUt = [3, g, kDt, 0, [h1e, C1e, R1e, ri], [[0, { [B]: h1e }], [() => A1e, { [B]: C1e }], [() => A1e, { [B]: R1e }], [4, { [B]: ri }]]], IUt = [3, g, A0, { [B]: A0 }, [], []], vUt = [3, g, bHe, 0, [RHe, fHe], [() => OUt, () => iUt]], PUt = [3, g, IHe, { [B]: CHe }, [XIt], [[() => io, 0]]], OUt = [3, g, RHe, 0, [xo], [0]], DUt = [3, g, vHe, { [B]: wHe }, [], []], kUt = [3, g, DHe, 0, [B1e, k1e, N1e], [1, 1, 1]], NUt = [3, g, LDt, 0, [n3e], [[() => kUt, { [ZH]: 1 }]]], BUt = [3, g, _He, 0, [jwt], [() => LUt]], LUt = [3, g, ODt, 0, [FPt, P0], [0, () => yBt]], bd = [3, g, Wn, 0, [Ge, JH], [0, 0]], g2 = [3, g, hs, 0, [U0], [[() => Wi, 0]]], MUt = [3, g, pkt, 0, [PH, tHe], [[() => I2e, { [o2e]: [r2e, zHe] }], 0]], $Ut = [3, g, LHe, 0, [A0, y0], [[() => IUt, { [B]: A0 }], [() => EFt, { [B]: y0 }]]], FUt = [3, g, FHe, 0, [od, O1e], [1, 0]], UUt = [-3, g, lkt, { [Vo]: qo, [pn]: 400 }, [], []]; k.for(g).registerError(UUt, n0); HUt = [3, g, kHe, 0, [Nr, okt, wH, qi], [0, [0, { [B]: xkt }], [64, { [we]: 1, [B]: bH }], [() => f2, 0]]], GUt = [3, g, HHe, 0, [o3e, od, Eo], [5, 1, 0]], jUt = [3, g, _kt, 0, [W, rr, Ze, l0, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => d$t, { [ot]: 1, [B]: l0 }], [0, { [d]: J }]]], qUt = [3, g, Rkt, 0, [W, rr, Ze, d0, X], [[0, 1], [0, { [d]: tr }], [0, { [d]: Dt }], [() => g$t, { [ot]: 1, [B]: d0 }], [0, { [d]: J }]]], VUt = [3, g, wkt, 0, [Y1e, U1e, jo, Br, Lr, Po, Ao, jt], [[0, { [d]: x2e }], [() => FBt, 16], [0, { [d]: un }], [0, { [d]: eo }], [0, { [d]: to }], [() => io, { [d]: mn }], [2, { [d]: ln }], [0, { [d]: Kt }]]], zUt = [3, g, bkt, 0, [W, G1e, j1e, q1e, V1e, z1e, rwt, Ge, gp, ec, Br, zn, Lr, W1e, SH, K1e, Tt, X, p3e], [[0, 1], [0, { [d]: p2e }], [0, { [d]: u2e }], [4, { [d]: m2e }], [0, { [d]: l2e }], [4, { [d]: d2e }], [0, { [d]: aNt }], [0, 1], [1, { [te]: j0 }], [0, { [te]: yx }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], [0, { [d]: f2e }], [() => A2e, { [d]: h2e }], [0, { [d]: g2e }], [0, { [d]: bt }], [0, { [d]: J }], [0, { [d]: C2e }]]], WUt = [3, g, Ikt, 0, [jo, Zr, To, wo, bo, Io, vo, Br, Lr, Po, Ao, jt], [[0, { [d]: un }], [0, { [d]: Zr }], [0, { [d]: Ep }], [0, { [d]: yp }], [0, { [d]: Sp }], [0, { [d]: _p }], [0, { [d]: Cp }], [0, { [d]: eo }], [0, { [d]: to }], [() => io, { [d]: mn }], [2, { [d]: ln }], [0, { [d]: Kt }]]], KUt = [3, g, vkt, 0, [ox, W, px, rr, Ze, To, wo, bo, Io, vo, Ge, gp, ec, Br, zn, Lr, Tt, X], [[() => wx, 16], [0, 1], [1, { [d]: cx }], [0, { [d]: tr }], [0, { [d]: Dt }], [0, { [d]: Ep }], [0, { [d]: yp }], [0, { [d]: Sp }], [0, { [d]: _p }], [0, { [d]: Cp }], [0, 1], [1, { [te]: j0 }], [0, { [te]: yx }], [0, { [d]: eo }], [() => Es, { [d]: xs }], [0, { [d]: to }], [0, { [d]: bt }], [0, { [d]: J }]]], QUt = [3, g, w0, 0, [N3e, xo], [[0, { [B]: D3e }], 0]], YUt = [3, g, b0, 0, [RH, OH, GH, qH], [() => b2e, () => v2e, () => U2e, [() => Q2e, 0]]], XUt = [3, g, Bkt, 0, [CDt, TDt, ox, NDt, i3e, a3e, lH, Jl, Zl, ed, td, px, yH, rd, To, wo, bo, Io, vo, dp, Zr, fs, ri, ni, FH, md, fd, dd, hd, N0, VH, jt, WH, jo, Br, Po, Lr, Eo, YH, _t, Ao], [[0, { [Hkt]: 1, [d]: rBt }], [0, { [d]: cBt }], [() => wx, 16], [1, { [d]: qNt }], [0, { [d]: pNt }], [0, { [d]: uNt }], [0, { [d]: SNt }], [0, { [d]: mNt }], [0, { [d]: lNt }], [0, { [d]: dNt }], [0, { [d]: fNt }], [1, { [d]: cx }], [0, { [d]: hNt }], [0, { [d]: gNt }], [0, { [d]: _Nt }], [0, { [d]: CNt }], [0, { [d]: RNt }], [0, { [d]: ANt }], [0, { [d]: TNt }], [2, { [d]: wNt }], [0, { [d]: xNt }], [4, { [d]: ENt }], [0, { [d]: bNt }], [4, { [d]: yNt }], [1, { [d]: INt }], [128, { [yd]: wd }], [0, { [d]: ONt }], [0, { [d]: PNt }], [5, { [d]: DNt }], [1, { [d]: vNt }], [0, { [d]: BNt }], [0, { [d]: NNt }], [0, { [d]: kNt }], [0, { [d]: MNt }], [0, { [d]: UNt }], [() => io, { [d]: $Nt }], [0, { [d]: HNt }], [0, { [d]: LNt }], [1, { [d]: GNt }], [0, { [d]: jNt }], [2, { [d]: FNt }]]], Fe = "unit", JUt = [-3, t2e, "S3ServiceException", 0, [], []]; k.for(t2e).registerError(JUt, kr); ZUt = [1, g, T1e, 0, [() => c2, 0]], V2e = [1, g, gH, 0, [() => CBt, { [B]: W }]], V0 = [1, g, YTt, 0, () => vBt], e1t = [1, g, XTt, 0, () => OBt], z2e = [1, g, xH, 0, [() => HBt, 0]], t1t = [1, g, nbt, 0, () => gLt], r1t = [1, g, e3e, 0, () => xLt], o1t = [1, g, ybt, 0, [0, { [B]: AH }]], n1t = [1, g, l3e, 0, () => DLt], s1t = [1, g, Tbt, 0, () => BLt], z0 = [1, g, O0, 0, [() => QMt, { [B]: vH }]], i1t = [1, g, A3e, 0, [() => u2, 0]], a1t = [1, g, _3e, 0, [() => m2, 0]], c1t = [1, g, NIt, 0, [0, { [B]: bbt }]], p1t = [1, g, bvt, 0, [() => y$t, 0]], W2e = [1, g, Zvt, 0, [() => _$t, 0]], u1t = [1, g, P3e, 0, [() => d2, 0]], m1t = [1, g, pPt, 0, () => eFt], l1t = [1, g, _Pt, 0, () => rFt], d1t = [1, g, IPt, 0, () => pFt], K2e = [1, g, NPt, 0, [() => aFt, 0]], f1t = [1, g, HPt, 0, [() => dFt, 0]], h1t = [1, g, TPt, 0, () => hFt], g1t = [1, g, L0, 0, () => xFt], x1t = [1, g, OOt, 0, () => lFt], E1t = [1, g, rDt, 0, [() => tUt, 0]], y1t = [1, g, _Dt, 0, [() => aUt, 0]], Q2e = [1, g, qH, 0, [() => gUt, { [B]: gHe }]], S1t = [1, g, JDt, 0, [() => wUt, 0]], Wi = [1, g, U0, 0, [() => bd, { [B]: Wn }]], _1t = [1, g, NHe, 0, [() => MUt, { [B]: vH }]], C1t = [1, g, ukt, 0, () => FUt], R1t = [1, g, ikt, 0, [() => HUt, 0]], A1t = [1, g, mkt, 0, () => GUt], T1t = [1, g, jHe, 0, [() => Q$t, { [B]: k3e }]], w1t = [4, g, oTt, 0, [Mt, Wn, rx], [0, () => bd, [() => EBt, 0]]], b1t = [4, g, iPt, 0, [Mt, Wn, v1e, rx], [0, () => bd, 0, [() => Z$t, 0]]], I1t = [4, g, zDt, { [e2e]: 1 }, [bDt, DHe, oHe, mwt, m3e], [[() => rUt, 0], [() => NUt, 0], [() => _Ft, 0], () => BBt, () => OLt]], Y2e = [9, g, cTt, { [Y]: ["DELETE", "/{Key+}?x-id=AbortMultipartUpload", 204] }, () => hBt, () => fBt], X2e = [9, g, M1e, { [Y]: ["POST", "/{Key+}", 200] }, () => kBt, () => DBt], J2e = [9, g, zTt, { [Y]: ["PUT", "/{Key+}?x-id=CopyObject", 200] }, () => MBt, () => LBt], Z2e = [9, g, ITt, { [Y]: ["PUT", "/", 200] }, () => zBt, () => VBt], eGe = [9, g, vTt, { [wt]: "-", [Y]: ["POST", "/?metadataConfiguration", 200] }, () => jBt, () => Fe], tGe = [9, g, OTt, { [wt]: "-", [Y]: ["POST", "/?metadataTable", 200] }, () => qBt, () => Fe], rGe = [9, g, VTt, { [Y]: ["POST", "/{Key+}?uploads", 200] }, () => KBt, () => WBt], oGe = [9, g, iwt, { [Y]: ["GET", "/?session", 200] }, () => YBt, () => QBt], nGe = [9, g, dwt, { [Y]: ["DELETE", "/", 204] }, () => dLt, () => Fe], sGe = [9, g, fwt, { [Y]: ["DELETE", "/?analytics", 204] }, () => tLt, () => Fe], iGe = [9, g, gwt, { [Y]: ["DELETE", "/?cors", 204] }, () => rLt, () => Fe], aGe = [9, g, Ewt, { [Y]: ["DELETE", "/?encryption", 204] }, () => oLt, () => Fe], cGe = [9, g, Cwt, { [Y]: ["DELETE", "/?intelligent-tiering", 204] }, () => nLt, () => Fe], pGe = [9, g, Swt, { [Y]: ["DELETE", "/?inventory", 204] }, () => sLt, () => Fe], uGe = [9, g, Awt, { [Y]: ["DELETE", "/?lifecycle", 204] }, () => iLt, () => Fe], mGe = [9, g, wwt, { [Y]: ["DELETE", "/?metadataConfiguration", 204] }, () => aLt, () => Fe], lGe = [9, g, Pwt, { [Y]: ["DELETE", "/?metadataTable", 204] }, () => cLt, () => Fe], dGe = [9, g, vwt, { [Y]: ["DELETE", "/?metrics", 204] }, () => pLt, () => Fe], fGe = [9, g, Dwt, { [Y]: ["DELETE", "/?ownershipControls", 204] }, () => uLt, () => Fe], hGe = [9, g, Nwt, { [Y]: ["DELETE", "/?policy", 204] }, () => mLt, () => Fe], gGe = [9, g, $wt, { [Y]: ["DELETE", "/?replication", 204] }, () => lLt, () => Fe], xGe = [9, g, Fwt, { [Y]: ["DELETE", "/?tagging", 204] }, () => fLt, () => Fe], EGe = [9, g, Hwt, { [Y]: ["DELETE", "/?website", 204] }, () => hLt, () => Fe], yGe = [9, g, sbt, { [Y]: ["DELETE", "/{Key+}?x-id=DeleteObject", 204] }, () => SLt, () => yLt], SGe = [9, g, ibt, { [wt]: "-", [Y]: ["POST", "/?delete", 200] }, () => CLt, () => _Lt], _Ge = [9, g, tbt, { [Y]: ["DELETE", "/{Key+}?tagging", 204] }, () => ALt, () => RLt], CGe = [9, g, abt, { [Y]: ["DELETE", "/?publicAccessBlock", 204] }, () => TLt, () => Fe], RGe = [9, g, vbt, { [Y]: ["GET", "/?abac", 200] }, () => MLt, () => LLt], AGe = [9, g, Pbt, { [Y]: ["GET", "/?accelerate", 200] }, () => FLt, () => $Lt], TGe = [9, g, Ubt, { [Y]: ["GET", "/?acl", 200] }, () => HLt, () => ULt], wGe = [9, g, Bbt, { [Y]: ["GET", "/?analytics&x-id=GetBucketAnalyticsConfiguration", 200] }, () => jLt, () => GLt], bGe = [9, g, Hbt, { [Y]: ["GET", "/?cors", 200] }, () => VLt, () => qLt], IGe = [9, g, qbt, { [Y]: ["GET", "/?encryption", 200] }, () => WLt, () => zLt], vGe = [9, g, Ybt, { [Y]: ["GET", "/?intelligent-tiering&x-id=GetBucketIntelligentTieringConfiguration", 200] }, () => QLt, () => KLt], PGe = [9, g, Wbt, { [Y]: ["GET", "/?inventory&x-id=GetBucketInventoryConfiguration", 200] }, () => XLt, () => YLt], OGe = [9, g, e0t, { [Y]: ["GET", "/?lifecycle", 200] }, () => ZLt, () => JLt], DGe = [9, g, Zbt, { [Y]: ["GET", "/?location", 200] }, () => tMt, () => eMt], kGe = [9, g, a0t, { [Y]: ["GET", "/?logging", 200] }, () => oMt, () => rMt], NGe = [9, g, c0t, { [Y]: ["GET", "/?metadataConfiguration", 200] }, () => sMt, () => nMt], BGe = [9, g, f0t, { [Y]: ["GET", "/?metadataTable", 200] }, () => cMt, () => aMt], LGe = [9, g, d0t, { [Y]: ["GET", "/?metrics&x-id=GetBucketMetricsConfiguration", 200] }, () => mMt, () => uMt], MGe = [9, g, x0t, { [Y]: ["GET", "/?notification", 200] }, () => lMt, () => k2e], $Ge = [9, g, y0t, { [Y]: ["GET", "/?ownershipControls", 200] }, () => fMt, () => dMt], FGe = [9, g, C0t, { [Y]: ["GET", "/?policy", 200] }, () => gMt, () => hMt], UGe = [9, g, T0t, { [Y]: ["GET", "/?policyStatus", 200] }, () => EMt, () => xMt], HGe = [9, g, I0t, { [Y]: ["GET", "/?replication", 200] }, () => SMt, () => yMt], GGe = [9, g, P0t, { [Y]: ["GET", "/?requestPayment", 200] }, () => CMt, () => _Mt], jGe = [9, g, N0t, { [Y]: ["GET", "/?tagging", 200] }, () => AMt, () => RMt], qGe = [9, g, M0t, { [Y]: ["GET", "/?versioning", 200] }, () => wMt, () => TMt], VGe = [9, g, U0t, { [Y]: ["GET", "/?website", 200] }, () => IMt, () => bMt], zGe = [9, g, j0t, { [wt]: "-", [Y]: ["GET", "/{Key+}?x-id=GetObject", 200] }, () => FMt, () => $Mt], WGe = [9, g, q0t, { [Y]: ["GET", "/{Key+}?acl", 200] }, () => PMt, () => vMt], KGe = [9, g, X0t, { [Y]: ["GET", "/{Key+}?attributes", 200] }, () => kMt, () => OMt], QGe = [9, g, tIt, { [Y]: ["GET", "/{Key+}?legal-hold", 200] }, () => BMt, () => NMt], YGe = [9, g, J0t, { [Y]: ["GET", "/?object-lock", 200] }, () => MMt, () => LMt], XGe = [9, g, cIt, { [Y]: ["GET", "/{Key+}?retention", 200] }, () => HMt, () => UMt], JGe = [9, g, pIt, { [Y]: ["GET", "/{Key+}?tagging", 200] }, () => jMt, () => GMt], ZGe = [9, g, fIt, { [Y]: ["GET", "/{Key+}?torrent", 200] }, () => VMt, () => qMt], eje = [9, g, hIt, { [Y]: ["GET", "/?publicAccessBlock", 200] }, () => WMt, () => zMt], tje = [9, g, EIt, { [Y]: ["HEAD", "/", 200] }, () => XMt, () => YMt], rje = [9, g, CIt, { [Y]: ["HEAD", "/{Key+}", 200] }, () => ZMt, () => JMt], oje = [9, g, ivt, { [Y]: ["GET", "/?analytics&x-id=ListBucketAnalyticsConfigurations", 200] }, () => T$t, () => A$t], nje = [9, g, dvt, { [Y]: ["GET", "/?intelligent-tiering&x-id=ListBucketIntelligentTieringConfigurations", 200] }, () => b$t, () => w$t], sje = [9, g, uvt, { [Y]: ["GET", "/?inventory&x-id=ListBucketInventoryConfigurations", 200] }, () => v$t, () => I$t], ije = [9, g, gvt, { [Y]: ["GET", "/?metrics&x-id=ListBucketMetricsConfigurations", 200] }, () => O$t, () => P$t], aje = [9, g, svt, { [Y]: ["GET", "/?x-id=ListBuckets", 200] }, () => k$t, () => D$t], cje = [9, g, _vt, { [Y]: ["GET", "/?x-id=ListDirectoryBuckets", 200] }, () => B$t, () => N$t], pje = [9, g, kvt, { [Y]: ["GET", "/?uploads", 200] }, () => M$t, () => L$t], uje = [9, g, Mvt, { [Y]: ["GET", "/", 200] }, () => F$t, () => $$t], mje = [9, g, Uvt, { [Y]: ["GET", "/?list-type=2", 200] }, () => H$t, () => U$t], lje = [9, g, Vvt, { [Y]: ["GET", "/?versions", 200] }, () => j$t, () => G$t], dje = [9, g, zvt, { [Y]: ["GET", "/{Key+}?x-id=ListParts", 200] }, () => V$t, () => q$t], fje = [9, g, jPt, { [wt]: "-", [Y]: ["PUT", "/?abac", 200] }, () => CFt, () => Fe], hje = [9, g, qPt, { [wt]: "-", [Y]: ["PUT", "/?accelerate", 200] }, () => RFt, () => Fe], gje = [9, g, YPt, { [wt]: "-", [Y]: ["PUT", "/?acl", 200] }, () => AFt, () => Fe], xje = [9, g, WPt, { [Y]: ["PUT", "/?analytics", 200] }, () => TFt, () => Fe], Eje = [9, g, XPt, { [wt]: "-", [Y]: ["PUT", "/?cors", 200] }, () => wFt, () => Fe], yje = [9, g, ZPt, { [wt]: "-", [Y]: ["PUT", "/?encryption", 200] }, () => bFt, () => Fe], Sje = [9, g, oOt, { [Y]: ["PUT", "/?intelligent-tiering", 200] }, () => IFt, () => Fe], _je = [9, g, tOt, { [Y]: ["PUT", "/?inventory", 200] }, () => vFt, () => Fe], Cje = [9, g, iOt, { [wt]: "-", [Y]: ["PUT", "/?lifecycle", 200] }, () => OFt, () => PFt], Rje = [9, g, sOt, { [wt]: "-", [Y]: ["PUT", "/?logging", 200] }, () => DFt, () => Fe], Aje = [9, g, uOt, { [Y]: ["PUT", "/?metrics", 200] }, () => kFt, () => Fe], Tje = [9, g, lOt, { [Y]: ["PUT", "/?notification", 200] }, () => NFt, () => Fe], wje = [9, g, fOt, { [wt]: "-", [Y]: ["PUT", "/?ownershipControls", 200] }, () => BFt, () => Fe], bje = [9, g, gOt, { [wt]: "-", [Y]: ["PUT", "/?policy", 200] }, () => LFt, () => Fe], Ije = [9, g, EOt, { [wt]: "-", [Y]: ["PUT", "/?replication", 200] }, () => MFt, () => Fe], vje = [9, g, yOt, { [wt]: "-", [Y]: ["PUT", "/?requestPayment", 200] }, () => $Ft, () => Fe], Pje = [9, g, COt, { [wt]: "-", [Y]: ["PUT", "/?tagging", 200] }, () => FFt, () => Fe], Oje = [9, g, AOt, { [wt]: "-", [Y]: ["PUT", "/?versioning", 200] }, () => UFt, () => Fe], Dje = [9, g, wOt, { [wt]: "-", [Y]: ["PUT", "/?website", 200] }, () => HFt, () => Fe], kje = [9, g, DOt, { [wt]: "-", [Y]: ["PUT", "/{Key+}?x-id=PutObject", 200] }, () => QFt, () => KFt], Nje = [9, g, kOt, { [wt]: "-", [Y]: ["PUT", "/{Key+}?acl", 200] }, () => jFt, () => GFt], Bje = [9, g, FOt, { [wt]: "-", [Y]: ["PUT", "/{Key+}?legal-hold", 200] }, () => VFt, () => qFt], Lje = [9, g, LOt, { [wt]: "-", [Y]: ["PUT", "/?object-lock", 200] }, () => WFt, () => zFt], Mje = [9, g, zOt, { [wt]: "-", [Y]: ["PUT", "/{Key+}?retention", 200] }, () => XFt, () => YFt], $je = [9, g, WOt, { [wt]: "-", [Y]: ["PUT", "/{Key+}?tagging", 200] }, () => ZFt, () => JFt], Fje = [9, g, YOt, { [wt]: "-", [Y]: ["PUT", "/?publicAccessBlock", 200] }, () => eUt, () => Fe], Uje = [9, g, mDt, { [Y]: ["PUT", "/{Key+}?renameObject", 200] }, () => sUt, () => nUt], Hje = [9, g, xDt, { [wt]: "-", [Y]: ["POST", "/{Key+}?restore", 200] }, () => fUt, () => dUt], Gje = [9, g, VDt, { [Y]: ["POST", "/{Key+}?select&select-type=2", 200] }, () => RUt, () => CUt], jje = [9, g, Skt, { [wt]: "-", [Y]: ["PUT", "/?metadataInventoryTable", 200] }, () => jUt, () => Fe], qje = [9, g, Ckt, { [wt]: "-", [Y]: ["PUT", "/?metadataJournalTable", 200] }, () => qUt, () => Fe], Vje = [9, g, Akt, { [wt]: "-", [Y]: ["PUT", "/{Key+}?x-id=UploadPart", 200] }, () => KUt, () => WUt], zje = [9, g, Tkt, { [Y]: ["PUT", "/{Key+}?x-id=UploadPartCopy", 200] }, () => zUt, () => VUt], Wje = [9, g, Nkt, { [Fkt]: ["{RequestRoute}."], [Y]: ["POST", "/WriteGetObjectResponse", 200] }, () => XUt, () => Fe] }); var Id, W0 = s(() => { pe(); V(); F(); K(); Q(); Id = class extends R.classBuilder().ep({ ...w, DisableS3ExpressSessionAuth: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").sc(oGe).build() { } }); var Qje, Kje = s(() => { Qje = { name: "@aws-sdk/client-s3", description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native", version: "3.962.0", scripts: { build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs", "build:cjs": "node ../../scripts/compilation/inline client-s3", "build:es": "tsc -p tsconfig.es.json", "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"', "build:types": "tsc -p tsconfig.types.json", "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4", clean: "rimraf ./dist-* && rimraf *.tsbuildinfo", "extract:docs": "api-extractor run --local", "generate:client": "node ../../scripts/generate-clients/single-service --solo s3", test: "yarn g:vitest run", "test:browser": "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.mts", "test:browser:watch": "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.mts", "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts && yarn test:browser", "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts", "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs", "test:integration": "yarn g:vitest run -c vitest.config.integ.mts", "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts", "test:watch": "yarn g:vitest watch" }, main: "./dist-cjs/index.js", types: "./dist-types/index.d.ts", module: "./dist-es/index.js", sideEffects: !1, dependencies: { "@aws-crypto/sha1-browser": "5.2.0", "@aws-crypto/sha256-browser": "5.2.0", "@aws-crypto/sha256-js": "5.2.0", "@aws-sdk/core": "3.957.0", "@aws-sdk/credential-provider-node": "3.962.0", "@aws-sdk/middleware-bucket-endpoint": "3.957.0", "@aws-sdk/middleware-expect-continue": "3.957.0", "@aws-sdk/middleware-flexible-checksums": "3.957.0", "@aws-sdk/middleware-host-header": "3.957.0", "@aws-sdk/middleware-location-constraint": "3.957.0", "@aws-sdk/middleware-logger": "3.957.0", "@aws-sdk/middleware-recursion-detection": "3.957.0", "@aws-sdk/middleware-sdk-s3": "3.957.0", "@aws-sdk/middleware-ssec": "3.957.0", "@aws-sdk/middleware-user-agent": "3.957.0", "@aws-sdk/region-config-resolver": "3.957.0", "@aws-sdk/signature-v4-multi-region": "3.957.0", "@aws-sdk/types": "3.957.0", "@aws-sdk/util-endpoints": "3.957.0", "@aws-sdk/util-user-agent-browser": "3.957.0", "@aws-sdk/util-user-agent-node": "3.957.0", "@smithy/config-resolver": "^4.4.5", "@smithy/core": "^3.20.0", "@smithy/eventstream-serde-browser": "^4.2.7", "@smithy/eventstream-serde-config-resolver": "^4.3.7", "@smithy/eventstream-serde-node": "^4.2.7", "@smithy/fetch-http-handler": "^5.3.8", "@smithy/hash-blob-browser": "^4.2.8", "@smithy/hash-node": "^4.2.7", "@smithy/hash-stream-node": "^4.2.7", "@smithy/invalid-dependency": "^4.2.7", "@smithy/md5-js": "^4.2.7", "@smithy/middleware-content-length": "^4.2.7", "@smithy/middleware-endpoint": "^4.4.1", "@smithy/middleware-retry": "^4.4.17", "@smithy/middleware-serde": "^4.2.8", "@smithy/middleware-stack": "^4.2.7", "@smithy/node-config-provider": "^4.3.7", "@smithy/node-http-handler": "^4.4.7", "@smithy/protocol-http": "^5.3.7", "@smithy/smithy-client": "^4.10.2", "@smithy/types": "^4.11.0", "@smithy/url-parser": "^4.2.7", "@smithy/util-base64": "^4.3.0", "@smithy/util-body-length-browser": "^4.2.0", "@smithy/util-body-length-node": "^4.2.1", "@smithy/util-defaults-mode-browser": "^4.3.16", "@smithy/util-defaults-mode-node": "^4.2.19", "@smithy/util-endpoints": "^3.2.7", "@smithy/util-middleware": "^4.2.7", "@smithy/util-retry": "^4.2.7", "@smithy/util-stream": "^4.5.8", "@smithy/util-utf8": "^4.2.0", "@smithy/util-waiter": "^4.2.7", tslib: "^2.6.2" }, devDependencies: { "@aws-sdk/signature-v4-crt": "3.957.0", "@tsconfig/node18": "18.2.4", "@types/node": "^18.19.69", concurrently: "7.0.0", "downlevel-dts": "0.10.1", rimraf: "3.0.2", typescript: "~5.8.3" }, engines: { node: ">=18.0.0" }, typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } }, files: ["dist-*/**"], author: { name: "AWS SDK for JavaScript Team", url: "https://aws.amazon.com/javascript/" }, license: "Apache-2.0", browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" }, "react-native": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native" }, homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3", repository: { type: "git", url: "https://github.com/aws/aws-sdk-js-v3.git", directory: "clients/client-s3" } } }); var K0, Q0, Yje, Xje, Jje, Zje, x2, e4e = s(() => { He(); Z(); K0 = "AWS_ACCESS_KEY_ID", Q0 = "AWS_SECRET_ACCESS_KEY", Yje = "AWS_SESSION_TOKEN", Xje = "AWS_CREDENTIAL_EXPIRATION", Jje = "AWS_CREDENTIAL_SCOPE", Zje = "AWS_ACCOUNT_ID", x2 = e => async () => { e?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv"); let t = process.env[K0], r = process.env[Q0], o = process.env[Yje], n = process.env[Xje], i = process.env[Jje], a = process.env[Zje]; if (t && r) { let c = { accessKeyId: t, secretAccessKey: r, ...o && { sessionToken: o }, ...n && { expiration: new Date(n) }, ...i && { credentialScope: i }, ...a && { accountId: a } }; return ee(c, "CREDENTIALS_ENV_VARS", "g"), c } throw new I("Unable to find environment variable credentials.", { logger: e?.logger }) } }); var t4e = {}; Qe(t4e, { ENV_ACCOUNT_ID: () => Zje, ENV_CREDENTIAL_SCOPE: () => Jje, ENV_EXPIRATION: () => Xje, ENV_KEY: () => K0, ENV_SECRET: () => Q0, ENV_SESSION: () => Yje, fromEnv: () => x2 }); var E2 = s(() => { e4e() }); import { Buffer as P1t } from "buffer"; import { request as O1t } from "http"; function oc(e) { return new Promise((t, r) => { let o = O1t({ method: "GET", ...e, hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1") }); o.on("error", n => { r(Object.assign(new kt("Unable to connect to instance metadata service"), n)), o.destroy() }), o.on("timeout", () => { r(new kt("TimeoutError from instance metadata service")), o.destroy() }), o.on("response", n => { let { statusCode: i = 400 } = n; (i < 200 || 300 <= i) && (r(Object.assign(new kt("Error response received from instance metadata service"), { statusCode: i })), o.destroy()); let a = []; n.on("data", c => { a.push(c) }), n.on("end", () => { t(P1t.concat(a)), o.destroy() }) }), o.end() }) } var Y0 = s(() => { Z() }); var X0, J0, y2 = s(() => { X0 = e => !!e && typeof e == "object" && typeof e.AccessKeyId == "string" && typeof e.SecretAccessKey == "string" && typeof e.Token == "string" && typeof e.Expiration == "string", J0 = e => ({ accessKeyId: e.AccessKeyId, secretAccessKey: e.SecretAccessKey, sessionToken: e.Token, expiration: new Date(e.Expiration), ...e.AccountId && { accountId: e.AccountId } }) }); var dTo, fTo, bx, Z0 = s(() => { dTo = 1e3, fTo = 0, bx = ({ maxRetries: e = 0, timeout: t = 1e3 }) => ({ maxRetries: e, timeout: t }) }); var Ix, S2 = s(() => { Ix = (e, t) => { let r = e(); for (let o = 0; o < t; o++)r = r.catch(e); return r } }); import { parse as D1t } from "url"; var eI, tI, _2, k1t, N1t, B1t, L1t, M1t, $1t, r4e = s(() => { Z(); Y0(); y2(); Z0(); S2(); eI = "AWS_CONTAINER_CREDENTIALS_FULL_URI", tI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", _2 = "AWS_CONTAINER_AUTHORIZATION_TOKEN", k1t = (e = {}) => { let { timeout: t, maxRetries: r } = bx(e); return () => Ix(async () => { let o = await $1t({ logger: e.logger }), n = JSON.parse(await N1t(t, o)); if (!X0(n)) throw new I("Invalid response received from instance metadata service.", { logger: e.logger }); return J0(n) }, r) }, N1t = async (e, t) => (process.env[_2] && (t.headers = { ...t.headers, Authorization: process.env[_2] }), (await oc({ ...t, timeout: e })).toString()), B1t = "169.254.170.2", L1t = { localhost: !0, "127.0.0.1": !0 }, M1t = { "http:": !0, "https:": !0 }, $1t = async ({ logger: e }) => { if (process.env[tI]) return { hostname: B1t, path: process.env[tI] }; if (process.env[eI]) { let t = D1t(process.env[eI]); if (!t.hostname || !(t.hostname in L1t)) throw new I(`${t.hostname} is not a valid container metadata service hostname`, { tryNextLink: !1, logger: e }); if (!t.protocol || !(t.protocol in M1t)) throw new I(`${t.protocol} is not a valid container metadata service protocol`, { tryNextLink: !1, logger: e }); return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 } } throw new I(`The container metadata credential provider cannot be used unless the ${tI} or ${eI} environment variable is set`, { tryNextLink: !1, logger: e }) } }); var rI, o4e = s(() => { Z(); rI = class e extends I { tryNextLink; name = "InstanceMetadataV1FallbackError"; constructor(t, r = !0) { super(t, r), this.tryNextLink = r, Object.setPrototypeOf(this, e.prototype) } } }); var Rp, C2 = s(() => { (function (e) { e.IPv4 = "http://169.254.169.254", e.IPv6 = "http://[fd00:ec2::254]" })(Rp || (Rp = {})) }); var F1t, U1t, n4e, s4e = s(() => { F1t = "AWS_EC2_METADATA_SERVICE_ENDPOINT", U1t = "ec2_metadata_service_endpoint", n4e = { environmentVariableSelector: e => e[F1t], configFileSelector: e => e[U1t], default: void 0 } }); var nc, R2 = s(() => { (function (e) { e.IPv4 = "IPv4", e.IPv6 = "IPv6" })(nc || (nc = {})) }); var H1t, G1t, i4e, a4e = s(() => { R2(); H1t = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE", G1t = "ec2_metadata_service_endpoint_mode", i4e = { environmentVariableSelector: e => e[H1t], configFileSelector: e => e[G1t], default: nc.IPv4 } }); var oI, j1t, q1t, A2 = s(() => { pp(); Bg(); C2(); s4e(); R2(); a4e(); oI = async () => Js(await j1t() || await q1t()), j1t = async () => ht(n4e)(), q1t = async () => { let e = await ht(i4e)(); switch (e) { case nc.IPv4: return Rp.IPv4; case nc.IPv6: return Rp.IPv6; default: throw new Error(`Unsupported endpoint mode: ${e}. Select from ${Object.values(nc)}`) } } }); var V1t, T2, c4e = s(() => {
  V1t = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html", T2 = (e, t) => {
    let r = 300 + Math.floor(Math.random() * 300), o = new Date(Date.now() + r * 1e3); t.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: `+ V1t); let n = e.originalExpiration ?? e.expiration; return { ...e, ...n ? { originalExpiration: n } : {}, expiration: o }
  }
}); var p4e, u4e = s(() => { c4e(); p4e = (e, t = {}) => { let r = t?.logger || console, o; return async () => { let n; try { n = await e(), n.expiration && n.expiration.getTime() < Date.now() && (n = T2(n, r)) } catch (i) { if (o) r.warn("Credential renew failed: ", i), n = T2(o, r); else throw i } return o = n, n } } }); var d4e, z1t, w2, m4e, l4e, W1t, K1t, Q1t, Y1t, X1t, f4e = s(() => { pp(); Z(); o4e(); Y0(); y2(); Z0(); S2(); A2(); u4e(); d4e = "/latest/meta-data/iam/security-credentials/", z1t = "/latest/api/token", w2 = "AWS_EC2_METADATA_V1_DISABLED", m4e = "ec2_metadata_v1_disabled", l4e = "x-aws-ec2-metadata-token", W1t = (e = {}) => p4e(K1t(e), { logger: e.logger }), K1t = (e = {}) => { let t = !1, { logger: r, profile: o } = e, { timeout: n, maxRetries: i } = bx(e), a = async (c, p) => { if (t || p.headers?.[l4e] == null) { let m = !1, f = !1, h = await ht({ environmentVariableSelector: E => { let S = E[w2]; if (f = !!S && S !== "false", S === void 0) throw new I(`${w2} not set in env, checking config file next.`, { logger: e.logger }); return f }, configFileSelector: E => { let S = E[m4e]; return m = !!S && S !== "false", m }, default: !1 }, { profile: o })(); if (e.ec2MetadataV1Disabled || h) { let E = []; throw e.ec2MetadataV1Disabled && E.push("credential provider initialization (runtime option ec2MetadataV1Disabled)"), m && E.push(`config file profile (${m4e})`), f && E.push(`process environment variable (${w2})`), new rI(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${E.join(", ")}].`) } } let l = (await Ix(async () => { let m; try { m = await Y1t(p) } catch (f) { throw f.statusCode === 401 && (t = !1), f } return m }, c)).trim(); return Ix(async () => { let m; try { m = await X1t(l, p, e) } catch (f) { throw f.statusCode === 401 && (t = !1), f } return m }, c) }; return async () => { let c = await oI(); if (t) return r?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)"), a(i, { ...c, timeout: n }); { let p; try { p = (await Q1t({ ...c, timeout: n })).toString() } catch (u) { if (u?.statusCode === 400) throw Object.assign(u, { message: "EC2 Metadata token request returned error" }); return (u.message === "TimeoutError" || [403, 404, 405].includes(u.statusCode)) && (t = !0), r?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)"), a(i, { ...c, timeout: n }) } return a(i, { ...c, headers: { [l4e]: p }, timeout: n }) } } }, Q1t = async e => oc({ ...e, path: z1t, method: "PUT", headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" } }), Y1t = async e => (await oc({ ...e, path: d4e })).toString(), X1t = async (e, t, r) => { let o = JSON.parse((await oc({ ...t, path: d4e + e })).toString()); if (!X0(o)) throw new I("Invalid response received from instance metadata service.", { logger: r.logger }); return J0(o) } }); var h4e = s(() => { }); var vx = {}; Qe(vx, { DEFAULT_MAX_RETRIES: () => fTo, DEFAULT_TIMEOUT: () => dTo, ENV_CMDS_AUTH_TOKEN: () => _2, ENV_CMDS_FULL_URI: () => eI, ENV_CMDS_RELATIVE_URI: () => tI, Endpoint: () => Rp, fromContainerMetadata: () => k1t, fromInstanceMetadata: () => W1t, getInstanceMetadataEndpoint: () => oI, httpRequest: () => oc, providerConfigFromInit: () => bx }); var Px = s(() => { r4e(); f4e(); Z0(); h4e(); Y0(); A2(); C2() }); var g4e, x4e, E4e = s(() => { Z(); g4e = "AWS_EC2_METADATA_DISABLED", x4e = async e => { let { ENV_CMDS_FULL_URI: t, ENV_CMDS_RELATIVE_URI: r, fromContainerMetadata: o, fromInstanceMetadata: n } = await Promise.resolve().then(() => (Px(), vx)); if (process.env[r] || process.env[t]) { e.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata"); let { fromHttp: i } = await Promise.resolve().then(() => (vc(), Ic)); return sr(i(e), o(e)) } return process.env[g4e] && process.env[g4e] !== "false" ? async () => { throw new I("EC2 Instance Metadata Service access disabled", { logger: e.logger }) } : (e.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"), n(e)) } }); function y4e(e, t) { let r = J1t(e), o, n, i, a = async c => { if (c?.forceRefresh) return await r(c); if (i?.expiration && i?.expiration?.getTime() < Date.now() && (i = void 0), o) await o; else if (!i || t?.(i)) if (i) n || (n = r(c).then(p => { i = p, n = void 0 })); else return o = r(c).then(p => { i = p, o = void 0 }), a(c); return i }; return a } var J1t, S4e = s(() => { J1t = e => async t => { let r; for (let o of e) try { return await o(t) } catch (n) { if (r = n, n?.tryNextLink) continue; throw n } throw r } }); var b2, I2 = s(() => { b2 = e => e && (typeof e.sso_start_url == "string" || typeof e.sso_account_id == "string" || typeof e.sso_session == "string" || typeof e.sso_region == "string" || typeof e.sso_role_name == "string") }); var _4e = s(() => { }); var vd, nI = s(() => { vd = "To refresh this SSO session run 'aws sso login' with the corresponding profile." }); var C4e, R4e = s(() => { C4e = async (e, t = {}, r) => { let { SSOOIDCClient: o } = await Promise.resolve().then(() => ($c(), Mc)), n = a => t.clientConfig?.[a] ?? t.parentClientConfig?.[a] ?? r?.[a]; return new o(Object.assign({}, t.clientConfig ?? {}, { region: e ?? t.clientConfig?.region, logger: n("logger"), userAgentAppId: n("userAgentAppId") })) } }); var A4e, T4e = s(() => { R4e(); A4e = async (e, t, r = {}, o) => { let { CreateTokenCommand: n } = await Promise.resolve().then(() => ($c(), Mc)); return (await C4e(t, r, o)).send(new n({ clientId: e.clientId, clientSecret: e.clientSecret, refreshToken: e.refreshToken, grantType: "refresh_token" })) } }); var v2, w4e = s(() => { Z(); nI(); v2 = e => { if (e.expiration && e.expiration.getTime() < Date.now()) throw new at(`Token is expired. ${vd}`, !1) } }); var sc, b4e = s(() => { Z(); nI(); sc = (e, t, r = !1) => { if (typeof t > "u") throw new at(`Value not present for '${e}' in SSO Token${r ? ". Cannot refresh" : ""}. ${vd}`, !1) } }); import { promises as Z1t } from "fs"; var e3t, I4e, v4e = s(() => { nn(); ({ writeFile: e3t } = Z1t), I4e = (e, t) => { let r = mb(e), o = JSON.stringify(t, null, 2); return e3t(r, o) } }); var P4e, O4e, D4e = s(() => { Z(); nn(); nI(); T4e(); w4e(); b4e(); v4e(); P4e = new Date(0), O4e = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/token-providers - fromSso"); let r = await Ka(e), o = jn({ profile: e.profile ?? t?.profile }), n = r[o]; if (n) { if (!n.sso_session) throw new at(`Profile '${o}' is missing required property 'sso_session'.`) } else throw new at(`Profile '${o}' could not be found in shared credentials file.`, !1); let i = n.sso_session, c = (await xb(e))[i]; if (!c) throw new at(`Sso session '${i}' could not be found in shared credentials file.`, !1); for (let E of ["sso_start_url", "sso_region"]) if (!c[E]) throw new at(`Sso session '${i}' is missing required property '${E}'.`, !1); let p = c.sso_start_url, u = c.sso_region, l; try { l = await Mg(i) } catch { throw new at(`The SSO session token associated with profile=${o} was not found or is invalid. ${vd}`, !1) } sc("accessToken", l.accessToken), sc("expiresAt", l.expiresAt); let { accessToken: m, expiresAt: f } = l, h = { token: m, expiration: new Date(f) }; if (h.expiration.getTime() - Date.now() > 3e5) return h; if (Date.now() - P4e.getTime() < 30 * 1e3) return v2(h), h; sc("clientId", l.clientId, !0), sc("clientSecret", l.clientSecret, !0), sc("refreshToken", l.refreshToken, !0); try { P4e.setTime(Date.now()); let E = await A4e(l, u, e, t); sc("accessToken", E.accessToken), sc("expiresIn", E.expiresIn); let S = new Date(Date.now() + E.expiresIn * 1e3); try { await I4e(i, { ...l, accessToken: E.accessToken, expiresAt: S.toISOString(), refreshToken: E.refreshToken }) } catch { } return { token: E.accessToken, expiration: S } } catch { return v2(h), h } } }); var k4e = s(() => { }); var N4e = s(() => { }); var B4e = s(() => { _4e(); D4e(); k4e(); N4e() }); function r3t(e) { return { schemeId: "aws.auth#sigv4", signingProperties: { name: "awsssoportal", region: e.region }, propertiesExtractor: (t, r) => ({ signingProperties: { config: t, context: r } }) } } function sI(e) { return { schemeId: "smithy.api#noAuth" } } var L4e, M4e, $4e, P2 = s(() => { Ye(); gt(); L4e = async (e, t, r) => ({ operation: je(t).operation, region: await le(e.region)() || (() => { throw new Error("expected `region` to be configured for `aws.auth#sigv4`") })() }); M4e = e => { let t = []; switch (e.operation) { case "GetRoleCredentials": { t.push(sI(e)); break } case "ListAccountRoles": { t.push(sI(e)); break } case "ListAccounts": { t.push(sI(e)); break } case "Logout": { t.push(sI(e)); break } default: t.push(r3t(e)) }return t }, $4e = e => { let t = qr(e); return Object.assign(t, { authSchemePreference: le(e.authSchemePreference ?? []) }) } }); var F4e, ic, Pd = s(() => { F4e = e => Object.assign(e, { useDualstackEndpoint: e.useDualstackEndpoint ?? !1, useFipsEndpoint: e.useFipsEndpoint ?? !1, defaultSigningName: "awsssoportal" }), ic = { UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" }, Endpoint: { type: "builtInParams", name: "endpoint" }, Region: { type: "builtInParams", name: "region" }, UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" } } }); var H4e, U4e = s(() => { H4e = { name: "@aws-sdk/client-sso", description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native", version: "3.958.0", scripts: { build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs", "build:cjs": "node ../../scripts/compilation/inline client-sso", "build:es": "tsc -p tsconfig.es.json", "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"', "build:types": "tsc -p tsconfig.types.json", "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4", clean: "rimraf ./dist-* && rimraf *.tsbuildinfo", "extract:docs": "api-extractor run --local", "generate:client": "node ../../scripts/generate-clients/single-service --solo sso", "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs" }, main: "./dist-cjs/index.js", types: "./dist-types/index.d.ts", module: "./dist-es/index.js", sideEffects: !1, dependencies: { "@aws-crypto/sha256-browser": "5.2.0", "@aws-crypto/sha256-js": "5.2.0", "@aws-sdk/core": "3.957.0", "@aws-sdk/middleware-host-header": "3.957.0", "@aws-sdk/middleware-logger": "3.957.0", "@aws-sdk/middleware-recursion-detection": "3.957.0", "@aws-sdk/middleware-user-agent": "3.957.0", "@aws-sdk/region-config-resolver": "3.957.0", "@aws-sdk/types": "3.957.0", "@aws-sdk/util-endpoints": "3.957.0", "@aws-sdk/util-user-agent-browser": "3.957.0", "@aws-sdk/util-user-agent-node": "3.957.0", "@smithy/config-resolver": "^4.4.5", "@smithy/core": "^3.20.0", "@smithy/fetch-http-handler": "^5.3.8", "@smithy/hash-node": "^4.2.7", "@smithy/invalid-dependency": "^4.2.7", "@smithy/middleware-content-length": "^4.2.7", "@smithy/middleware-endpoint": "^4.4.1", "@smithy/middleware-retry": "^4.4.17", "@smithy/middleware-serde": "^4.2.8", "@smithy/middleware-stack": "^4.2.7", "@smithy/node-config-provider": "^4.3.7", "@smithy/node-http-handler": "^4.4.7", "@smithy/protocol-http": "^5.3.7", "@smithy/smithy-client": "^4.10.2", "@smithy/types": "^4.11.0", "@smithy/url-parser": "^4.2.7", "@smithy/util-base64": "^4.3.0", "@smithy/util-body-length-browser": "^4.2.0", "@smithy/util-body-length-node": "^4.2.1", "@smithy/util-defaults-mode-browser": "^4.3.16", "@smithy/util-defaults-mode-node": "^4.2.19", "@smithy/util-endpoints": "^3.2.7", "@smithy/util-middleware": "^4.2.7", "@smithy/util-retry": "^4.2.7", "@smithy/util-utf8": "^4.2.0", tslib: "^2.6.2" }, devDependencies: { "@tsconfig/node18": "18.2.4", "@types/node": "^18.19.69", concurrently: "7.0.0", "downlevel-dts": "0.10.1", rimraf: "3.0.2", typescript: "~5.8.3" }, engines: { node: ">=18.0.0" }, typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } }, files: ["dist-*/**"], author: { name: "AWS SDK for JavaScript Team", url: "https://aws.amazon.com/javascript/" }, license: "Apache-2.0", browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" }, "react-native": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native" }, homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso", repository: { type: "git", url: "https://github.com/aws/aws-sdk-js-v3.git", directory: "clients/client-sso" } } }); var G4e, j4e = s(() => { G4e = { isCrtAvailable: !1 } }); var q4e, V4e = s(() => { j4e(); q4e = () => G4e.isCrtAvailable ? ["md/crt-avail"] : null }); import { platform as n3t, release as s3t } from "os"; import { env as z4e, versions as i3t } from "process"; var iI, W4e = s(() => { V4e(); iI = ({ serviceId: e, clientVersion: t }) => async r => { let o = [["aws-sdk-js", t], ["ua", "2.1"], [`os/${n3t()}`, s3t()], ["lang/js"], ["md/nodejs", `${i3t.node}`]], n = q4e(); n && o.push(n), e && o.push([`api/${e}`, t]), z4e.AWS_EXECUTION_ENV && o.push([`exec-env/${z4e.AWS_EXECUTION_ENV}`]); let i = await r?.userAgentAppId?.(); return i ? [...o, [`app/${i}`]] : [...o] } }); var a3t, c3t, p3t, aI, K4e = s(() => { ob(); a3t = "AWS_SDK_UA_APP_ID", c3t = "sdk_ua_app_id", p3t = "sdk-ua-app-id", aI = { environmentVariableSelector: e => e[a3t], configFileSelector: e => e[c3t] ?? e[p3t], default: z1 } }); var O2 = s(() => { W4e(); K4e() }); import { Buffer as D2 } from "buffer"; var k2, Q4e, Y4e = s(() => { cr(); k2 = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return D2.from(e, t, r) }, Q4e = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? D2.from(e, t) : D2.from(e) } }); import { Buffer as N2 } from "buffer"; var X4e, J4e, B2 = s(() => { cr(); X4e = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return N2.from(e, t, r) }, J4e = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? N2.from(e, t) : N2.from(e) } }); var ac, L2 = s(() => { B2(); ac = e => { let t = J4e(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var Z4e, eqe = s(() => { L2(); Z4e = e => typeof e == "string" ? ac(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) }); var Od, tqe = s(() => { B2(); Od = e => { if (typeof e == "string") return e; if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number") throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."); return X4e(e.buffer, e.byteOffset, e.byteLength).toString("utf8") } }); var Dd = s(() => { L2(); eqe(); tqe() }); import { Buffer as u3t } from "buffer"; import { createHash as m3t, createHmac as l3t } from "crypto"; function rqe(e, t) { return u3t.isBuffer(e) ? e : typeof e == "string" ? Q4e(e, t) : ArrayBuffer.isView(e) ? k2(e.buffer, e.byteOffset, e.byteLength) : k2(e) } var cc, M2 = s(() => { Y4e(); Dd(); cc = class { algorithmIdentifier; secret; hash; constructor(t, r) { this.algorithmIdentifier = t, this.secret = r, this.reset() } update(t, r) { this.hash.update(Z4e(rqe(t, r))) } digest() { return Promise.resolve(this.hash.digest()) } reset() { this.hash = this.secret ? l3t(this.algorithmIdentifier, rqe(this.secret)) : m3t(this.algorithmIdentifier) } } }); var cI, d3t, oqe = s(() => { cI = e => encodeURIComponent(e).replace(/[!'()*]/g, d3t), d3t = e => `%${e.charCodeAt(0).toString(16).toUpperCase()}` }); var nqe = s(() => { }); var sqe = s(() => { oqe(); nqe() }); function iqe(e) { let t = []; for (let r of Object.keys(e).sort()) { let o = e[r]; if (r = cI(r), Array.isArray(o)) for (let n = 0, i = o.length; n < i; n++)t.push(`${r}=${cI(o[n])}`); else { let n = r; (o || typeof o == "string") && (n += `=${cI(o)}`), t.push(n) } } return t.join("&") } var aqe = s(() => { sqe() }); var cqe, pqe = s(() => { cqe = ["ECONNRESET", "EPIPE", "ETIMEDOUT"] }); var uqe, mqe = s(() => { uqe = e => { let t = {}; for (let r of Object.keys(e)) { let o = e[r]; t[r] = Array.isArray(o) ? o.join(",") : o } return t } }); var yr, Ap = s(() => { yr = { setTimeout: (e, t) => setTimeout(e, t), clearTimeout: e => clearTimeout(e) } }); var lqe, dqe, fqe = s(() => { Ap(); lqe = 1e3, dqe = (e, t, r = 0) => { if (!r) return -1; let o = n => { let i = yr.setTimeout(() => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${r} ms.`), { name: "TimeoutError" })) }, r - n), a = c => { c?.connecting ? c.on("connect", () => { yr.clearTimeout(i) }) : yr.clearTimeout(i) }; e.socket ? a(e.socket) : e.on("socket", a) }; return r < 2e3 ? (o(0), 0) : yr.setTimeout(o.bind(null, lqe), lqe) } }); var hqe, gqe = s(() => { Ap(); hqe = (e, t, r = 0, o, n) => r ? yr.setTimeout(() => { let i = `@smithy/node-http-handler - [${o ? "ERROR" : "WARN"}] a request has exceeded the configured ${r} ms requestTimeout.`; if (o) { let a = Object.assign(new Error(i), { name: "TimeoutError", code: "ETIMEDOUT" }); e.destroy(a), t(a) } else i += " Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.", n?.warn?.(i) }, r) : -1 }); var f3t, xqe, Eqe = s(() => { Ap(); f3t = 3e3, xqe = (e, { keepAlive: t, keepAliveMsecs: r }, o = f3t) => { if (t !== !0) return -1; let n = () => { e.socket ? e.socket.setKeepAlive(t, r || 0) : e.on("socket", i => { i.setKeepAlive(t, r || 0) }) }; return o === 0 ? (n(), 0) : yr.setTimeout(n, o) } }); var yqe, Sqe, _qe = s(() => { Ap(); yqe = 3e3, Sqe = (e, t, r = 0) => { let o = n => { let i = r - n, a = () => { e.destroy(), t(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${r} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" })) }; e.socket ? (e.socket.setTimeout(i, a), e.on("close", () => e.socket?.removeListener("timeout", a))) : e.setTimeout(i, a) }; return 0 < r && r < 6e3 ? (o(0), 0) : yr.setTimeout(o.bind(null, r === 0 ? 0 : yqe), yqe) } }); import { Readable as h3t } from "stream"; async function Rqe(e, t, r = Cqe, o = !1) { let n = t.headers ?? {}, i = n.Expect || n.expect, a = -1, c = !0; !o && i === "100-continue" && (c = await Promise.race([new Promise(p => { a = Number(yr.setTimeout(() => p(!0), Math.max(Cqe, r))) }), new Promise(p => { e.on("continue", () => { yr.clearTimeout(a), p(!0) }), e.on("response", () => { yr.clearTimeout(a), p(!1) }), e.on("error", () => { yr.clearTimeout(a), p(!1) }) })])), c && g3t(e, t.body) } function g3t(e, t) { if (t instanceof h3t) { t.pipe(e); return } if (t) { if (Buffer.isBuffer(t) || typeof t == "string") { e.end(t); return } let r = t; if (typeof r == "object" && r.buffer && typeof r.byteOffset == "number" && typeof r.byteLength == "number") { e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength)); return } e.end(Buffer.from(t)); return } e.end() } var Cqe, Aqe = s(() => { Ap(); Cqe = 6e3 }); import { Agent as $2, request as x3t } from "http"; import { Agent as F2, request as E3t } from "https"; var kd, Tqe = s(() => {
  Hi(); aqe(); pqe(); mqe(); fqe(); gqe(); Eqe(); _qe(); Ap(); Aqe(); kd = class e {
    config; configProvider; socketWarningTimestamp = 0; externalAgent = !1; metadata = { handlerProtocol: "http/1.1" }; static create(t) { return typeof t?.handle == "function" ? t : new e(t) } static checkSocketUsage(t, r, o = console) {
      let { sockets: n, requests: i, maxSockets: a } = t; if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r) return r; if (n && i) for (let p in n) {
        let u = n[p]?.length ?? 0, l = i[p]?.length ?? 0; if (u >= a && l >= 2 * a) return o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${u} and ${l} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`), Date.now()
      } return r
    } constructor(t) { this.configProvider = new Promise((r, o) => { typeof t == "function" ? t().then(n => { r(this.resolveDefaultConfig(n)) }).catch(o) : r(this.resolveDefaultConfig(t)) }) } resolveDefaultConfig(t) { let { requestTimeout: r, connectionTimeout: o, socketTimeout: n, socketAcquisitionWarningTimeout: i, httpAgent: a, httpsAgent: c, throwOnRequestTimeout: p } = t || {}, u = !0, l = 50; return { connectionTimeout: o, requestTimeout: r, socketTimeout: n, socketAcquisitionWarningTimeout: i, throwOnRequestTimeout: p, httpAgent: a instanceof $2 || typeof a?.destroy == "function" ? (this.externalAgent = !0, a) : new $2({ keepAlive: u, maxSockets: l, ...a }), httpsAgent: c instanceof F2 || typeof c?.destroy == "function" ? (this.externalAgent = !0, c) : new F2({ keepAlive: u, maxSockets: l, ...c }), logger: console } } destroy() { this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy() } async handle(t, { abortSignal: r, requestTimeout: o } = {}) { return this.config || (this.config = await this.configProvider), new Promise((n, i) => { let a = this.config, c, p = [], u = async O => { await c, p.forEach(yr.clearTimeout), n(O) }, l = async O => { await c, p.forEach(yr.clearTimeout), i(O) }; if (r?.aborted) { let O = new Error("Request aborted"); O.name = "AbortError", l(O); return } let m = t.protocol === "https:", f = t.headers ?? {}, h = (f.Expect ?? f.expect) === "100-continue", E = m ? a.httpsAgent : a.httpAgent; h && !this.externalAgent && (E = new (m ? F2 : $2)({ keepAlive: !1, maxSockets: 1 / 0 })), p.push(yr.setTimeout(() => { this.socketWarningTimestamp = e.checkSocketUsage(E, this.socketWarningTimestamp, a.logger) }, a.socketAcquisitionWarningTimeout ?? (a.requestTimeout ?? 2e3) + (a.connectionTimeout ?? 1e3))); let S = iqe(t.query || {}), y; if (t.username != null || t.password != null) { let O = t.username ?? "", ie = t.password ?? ""; y = `${O}:${ie}` } let C = t.path; S && (C += `?${S}`), t.fragment && (C += `#${t.fragment}`); let b = t.hostname ?? ""; b[0] === "[" && b.endsWith("]") ? b = t.hostname.slice(1, -1) : b = t.hostname; let L = { headers: t.headers, host: b, method: t.method, path: C, port: t.port, agent: E, auth: y }, j = (m ? E3t : x3t)(L, O => { let ie = new kl({ statusCode: O.statusCode || -1, reason: O.statusMessage, headers: uqe(O.headers), body: O }); u({ response: ie }) }); if (j.on("error", O => { cqe.includes(O.code) ? l(Object.assign(O, { name: "TimeoutError" })) : l(O) }), r) { let O = () => { j.destroy(); let ie = new Error("Request aborted"); ie.name = "AbortError", l(ie) }; if (typeof r.addEventListener == "function") { let ie = r; ie.addEventListener("abort", O, { once: !0 }), j.once("close", () => ie.removeEventListener("abort", O)) } else r.onabort = O } let re = o ?? a.requestTimeout; p.push(dqe(j, l, a.connectionTimeout)), p.push(hqe(j, l, re, a.throwOnRequestTimeout, a.logger ?? console)), p.push(Sqe(j, l, a.socketTimeout)); let Ce = L.agent; typeof Ce == "object" && "keepAlive" in Ce && p.push(xqe(j, { keepAlive: Ce.keepAlive, keepAliveMsecs: Ce.keepAliveMsecs })), c = Rqe(j, t, re, this.externalAgent).catch(O => (p.forEach(yr.clearTimeout), i(O))) }) } updateHttpClientConfig(t, r) { this.config = void 0, this.configProvider = this.configProvider.then(o => ({ ...o, [t]: r })) } httpHandlerConfigs() { return this.config ?? {} }
  }
}); var wqe = s(() => { }); import { Writable as y3t } from "stream"; var pI, bqe = s(() => { pI = class extends y3t { bufferedBytes = []; _write(t, r, o) { this.bufferedBytes.push(t), o() } } }); async function _3t(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } var Nd, S3t, Iqe = s(() => { bqe(); Nd = e => S3t(e) ? _3t(e) : new Promise((t, r) => { let o = new pI; e.pipe(o), e.on("error", n => { o.end(), r(n) }), o.on("error", r), o.on("finish", function () { let n = new Uint8Array(Buffer.concat(this.bufferedBytes)); t(n) }) }), S3t = e => typeof ReadableStream == "function" && e instanceof ReadableStream }); var uI = s(() => { Tqe(); wqe(); Iqe() }); import { fstatSync as C3t, lstatSync as R3t, ReadStream as A3t } from "node:fs"; var mI, vqe = s(() => { mI = e => { if (!e) return 0; if (typeof e == "string") return Buffer.byteLength(e); if (typeof e.byteLength == "number") return e.byteLength; if (typeof e.size == "number") return e.size; if (typeof e.start == "number" && typeof e.end == "number") return e.end + 1 - e.start; if (e instanceof A3t) { if (e.path != null) return R3t(e.path).size; if (typeof e.fd == "number") return C3t(e.fd).size } throw new Error(`Body Length computation failed for ${e}`) } }); var U2 = s(() => { vqe() }); var Pqe, H2, G2, Oqe, Dqe, kqe, Nqe = s(() => { Pqe = "AWS_EXECUTION_ENV", H2 = "AWS_REGION", G2 = "AWS_DEFAULT_REGION", Oqe = "AWS_EC2_METADATA_DISABLED", Dqe = ["in-region", "cross-region", "mobile", "standard", "legacy"], kqe = "/latest/meta-data/placement/region" }); var T3t, w3t, Bqe, Lqe = s(() => { T3t = "AWS_DEFAULTS_MODE", w3t = "defaults_mode", Bqe = { environmentVariableSelector: e => e[T3t], configFileSelector: e => e[w3t], default: "legacy" } }); var lI, b3t, I3t, Mqe = s(() => { $l(); pp(); Z(); Nqe(); Lqe(); lI = ({ region: e = ht(Ml), defaultsMode: t = ht(Bqe) } = {}) => jr(async () => { let r = typeof t == "function" ? await t() : t; switch (r?.toLowerCase()) { case "auto": return b3t(e); case "in-region": case "cross-region": case "mobile": case "standard": case "legacy": return Promise.resolve(r?.toLocaleLowerCase()); case void 0: return Promise.resolve("legacy"); default: throw new Error(`Invalid parameter for "defaultsMode", expect ${Dqe.join(", ")}, got ${r}`) } }), b3t = async e => { if (e) { let t = typeof e == "function" ? await e() : e, r = await I3t(); return r ? t === r ? "in-region" : "cross-region" : "standard" } return "standard" }, I3t = async () => { if (process.env[Pqe] && (process.env[H2] || process.env[G2])) return process.env[H2] ?? process.env[G2]; if (!process.env[Oqe]) try { let { getInstanceMetadataEndpoint: e, httpRequest: t } = await Promise.resolve().then(() => (Px(), vx)), r = await e(); return (await t({ ...r, path: kqe })).toString() } catch { } } }); var j2 = s(() => { Mqe() }); import { Buffer as q2 } from "buffer"; var $qe, Fqe, V2 = s(() => { cr(); $qe = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return q2.from(e, t, r) }, Fqe = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? q2.from(e, t) : q2.from(e) } }); var v3t, Bd, Uqe = s(() => { V2(); v3t = /^[A-Za-z0-9+/]*={0,2}$/, Bd = e => { if (e.length * 3 % 4 !== 0) throw new TypeError("Incorrect padding on base64 string."); if (!v3t.exec(e)) throw new TypeError("Invalid base64 string."); let t = Fqe(e, "base64"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength) } }); var Ld, Hqe = s(() => { V2(); Dd(); Ld = e => { let t; if (typeof e == "string" ? t = ac(e) : t = e, typeof t != "object" || typeof t.byteOffset != "number" || typeof t.byteLength != "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."); return $qe(t.buffer, t.byteOffset, t.byteLength).toString("base64") } }); var Ox = s(() => { Uqe(); Hqe() }); var Xqe, Yn, Xn, Fd, Gqe, Dx, Md, $d, Ki, z2, W2, jqe, qqe, Vqe, Jqe, Zqe, Qn, zqe, eVe, Wqe, Kqe, Qqe, Yqe, P3t, tVe, rVe = s(() => { Xqe = "required", Yn = "fn", Xn = "argv", Fd = "ref", Gqe = "isSet", Dx = "booleanEquals", Md = "error", $d = "endpoint", Ki = "tree", z2 = "PartitionResult", W2 = "getAttr", jqe = { [Xqe]: !1, type: "string" }, qqe = { [Xqe]: !0, default: !1, type: "boolean" }, Vqe = { [Fd]: "Endpoint" }, Jqe = { [Yn]: Dx, [Xn]: [{ [Fd]: "UseFIPS" }, !0] }, Zqe = { [Yn]: Dx, [Xn]: [{ [Fd]: "UseDualStack" }, !0] }, Qn = {}, zqe = { [Yn]: W2, [Xn]: [{ [Fd]: z2 }, "supportsFIPS"] }, eVe = { [Fd]: z2 }, Wqe = { [Yn]: Dx, [Xn]: [!0, { [Yn]: W2, [Xn]: [eVe, "supportsDualStack"] }] }, Kqe = [Jqe], Qqe = [Zqe], Yqe = [{ [Fd]: "Region" }], P3t = { version: "1.0", parameters: { Region: jqe, UseDualStack: qqe, UseFIPS: qqe, Endpoint: jqe }, rules: [{ conditions: [{ [Yn]: Gqe, [Xn]: [Vqe] }], rules: [{ conditions: Kqe, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: Md }, { conditions: Qqe, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: Md }, { endpoint: { url: Vqe, properties: Qn, headers: Qn }, type: $d }], type: Ki }, { conditions: [{ [Yn]: Gqe, [Xn]: Yqe }], rules: [{ conditions: [{ [Yn]: "aws.partition", [Xn]: Yqe, assign: z2 }], rules: [{ conditions: [Jqe, Zqe], rules: [{ conditions: [{ [Yn]: Dx, [Xn]: [!0, zqe] }, Wqe], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Qn, headers: Qn }, type: $d }], type: Ki }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: Md }], type: Ki }, { conditions: Kqe, rules: [{ conditions: [{ [Yn]: Dx, [Xn]: [zqe, !0] }], rules: [{ conditions: [{ [Yn]: "stringEquals", [Xn]: [{ [Yn]: W2, [Xn]: [eVe, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: Qn, headers: Qn }, type: $d }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: Qn, headers: Qn }, type: $d }], type: Ki }, { error: "FIPS is enabled but this partition does not support FIPS", type: Md }], type: Ki }, { conditions: Qqe, rules: [{ conditions: [Wqe], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: Qn, headers: Qn }, type: $d }], type: Ki }, { error: "DualStack is enabled but this partition does not support DualStack", type: Md }], type: Ki }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: Qn, headers: Qn }, type: $d }], type: Ki }], type: Ki }, { error: "Invalid Configuration: Missing Region", type: Md }] }, tVe = P3t }); var O3t, oVe, nVe = s(() => { Jw(); Ft(); rVe(); O3t = new Rr({ size: 50, params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"] }), oVe = (e, t = {}) => O3t.get(e, () => Ur(tVe, { endpointParams: e, logger: t.logger })); Rt.aws = Ng }); var sVe, iVe = s(() => { Ye(); yn(); Ie(); F(); Bg(); Ox(); Dd(); P2(); nVe(); sVe = e => ({ apiVersion: "2019-06-10", base64Decoder: e?.base64Decoder ?? Bd, base64Encoder: e?.base64Encoder ?? Ld, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? oVe, extensions: e?.extensions ?? [], httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? M4e, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }, { schemeId: "smithy.api#noAuth", identityProvider: t => t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})), signer: new po }], logger: e?.logger ?? new Ya, protocol: e?.protocol ?? En, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.sso", version: "2019-06-10", serviceTarget: "SWBPortalService" }, serviceId: e?.serviceId ?? "SSO", urlParser: e?.urlParser ?? Js, utf8Decoder: e?.utf8Decoder ?? ac, utf8Encoder: e?.utf8Encoder ?? Od }) }); var aVe, cVe = s(() => { U4e(); Ye(); O2(); $l(); M2(); jg(); pp(); uI(); F(); U2(); j2(); Gg(); iVe(); aVe = e => { kb(process.version); let t = lI(e), r = () => t().then(Db), o = sVe(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, authSchemePreference: e?.authSchemePreference ?? ht(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? mI, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? iI({ serviceId: o.serviceId, clientVersion: H4e.version }), maxAttempts: e?.maxAttempts ?? ht(bb, e), region: e?.region ?? ht(Ml, { ...ib, ...n }), requestHandler: kd.create(e?.requestHandler ?? r), retryMode: e?.retryMode ?? ht({ ...vb, default: async () => (await r()).retryMode || Hl }, e), sha256: e?.sha256 ?? cc.bind(null, "sha256"), streamCollector: e?.streamCollector ?? Nd, useDualstackEndpoint: e?.useDualstackEndpoint ?? ht(nb, n), useFipsEndpoint: e?.useFipsEndpoint ?? ht(sb, n), userAgentAppId: e?.userAgentAppId ?? ht(aI, n) } } }); var pVe, uVe, mVe = s(() => { pVe = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, uVe = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var lVe, dVe = s(() => { ps(); Hi(); F(); mVe(); lVe = (e, t) => { let r = Object.assign(Vr(e), Nb(e), Fw(e), pVe(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), Bb(r), Uw(r), uVe(r)) } }); var ii, kx = s(() => { N1(); B1(); $1(); ob(); $l(); Ie(); Oe(); e3(); V(); jg(); F(); P2(); Pd(); cVe(); dVe(); ii = class extends ql { config; constructor(...[t]) { let r = aVe(t || {}); super(r), this.initConfig = r; let o = F4e(r), n = Xw(o), i = Ib(n), a = cb(i), c = a, p = _b(c), u = $4e(p), l = lVe(u, t?.extensions || []); this.config = l, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(rb(this.config)), this.middlewareStack.use(Lb(this.config)), this.middlewareStack.use(pb(this.config)), this.middlewareStack.use(Hw(this.config)), this.middlewareStack.use(Gw(this.config)), this.middlewareStack.use(jw(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: L4e, identityProviderConfigProvider: async m => new Cr({ "aws.auth#sigv4": m.credentials }) })), this.middlewareStack.use($r(this.config)) } destroy() { super.destroy() } } }); var Qi, K2 = s(() => { F(); Qi = class e extends Vl { constructor(t) { super(t), Object.setPrototypeOf(this, e.prototype) } } }); var dI, fI, hI, gI, Q2 = s(() => { K2(); dI = class e extends Qi { name = "InvalidRequestException"; $fault = "client"; constructor(t) { super({ name: "InvalidRequestException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, fI = class e extends Qi { name = "ResourceNotFoundException"; $fault = "client"; constructor(t) { super({ name: "ResourceNotFoundException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, hI = class e extends Qi { name = "TooManyRequestsException"; $fault = "client"; constructor(t) { super({ name: "TooManyRequestsException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } }, gI = class e extends Qi { name = "UnauthorizedException"; $fault = "client"; constructor(t) { super({ name: "UnauthorizedException", $fault: "client", ...t }), Object.setPrototypeOf(this, e.prototype) } } }); var k3t, N3t, B3t, L3t, M3t, $3t, F3t, U3t, H3t, G3t, j3t, q3t, V3t, z3t, W3t, K3t, Q3t, Y3t, X3t, J3t, Z3t, eHt, tHt, xI, rHt, oHt, nHt, EI, fVe, yI, SI, sHt, iHt, _I, CI, RI, Tp, AI, hVe, gVe, TI, xVe, aHt, cHt, EVe, pHt, yVe, uHt, mHt, wI, $t, bI, lHt, dHt, fHt, hHt, gHt, xHt, EHt, yHt, SHt, _Ht, CHt, RHt, AHt, THt, wHt, bHt, IHt, vHt, PHt, OHt, SVe, _Ve, CVe, RVe, Ud = s(() => { Oe(); Q2(); K2(); k3t = "AccountInfo", N3t = "AccountListType", B3t = "AccessTokenType", L3t = "GetRoleCredentials", M3t = "GetRoleCredentialsRequest", $3t = "GetRoleCredentialsResponse", F3t = "InvalidRequestException", U3t = "Logout", H3t = "ListAccounts", G3t = "ListAccountsRequest", j3t = "ListAccountRolesRequest", q3t = "ListAccountRolesResponse", V3t = "ListAccountsResponse", z3t = "ListAccountRoles", W3t = "LogoutRequest", K3t = "RoleCredentials", Q3t = "RoleInfo", Y3t = "RoleListType", X3t = "ResourceNotFoundException", J3t = "SecretAccessKeyType", Z3t = "SessionTokenType", eHt = "TooManyRequestsException", tHt = "UnauthorizedException", xI = "accountId", rHt = "accessKeyId", oHt = "accountList", nHt = "accountName", EI = "accessToken", fVe = "account_id", yI = "client", SI = "error", sHt = "emailAddress", iHt = "expiration", _I = "http", CI = "httpError", RI = "httpHeader", Tp = "httpQuery", AI = "message", hVe = "maxResults", gVe = "max_result", TI = "nextToken", xVe = "next_token", aHt = "roleCredentials", cHt = "roleList", EVe = "roleName", pHt = "role_name", yVe = "smithy.ts.sdk.synthetic.com.amazonaws.sso", uHt = "secretAccessKey", mHt = "sessionToken", wI = "x-amz-sso_bearer_token", $t = "com.amazonaws.sso", bI = [0, $t, B3t, 8, 0], lHt = [0, $t, J3t, 8, 0], dHt = [0, $t, Z3t, 8, 0], fHt = [3, $t, k3t, 0, [xI, nHt, sHt], [0, 0, 0]], hHt = [3, $t, M3t, 0, [EVe, xI, EI], [[0, { [Tp]: pHt }], [0, { [Tp]: fVe }], [() => bI, { [RI]: wI }]]], gHt = [3, $t, $3t, 0, [aHt], [[() => AHt, 0]]], xHt = [-3, $t, F3t, { [SI]: yI, [CI]: 400 }, [AI], [0]]; k.for($t).registerError(xHt, dI); EHt = [3, $t, j3t, 0, [TI, hVe, EI, xI], [[0, { [Tp]: xVe }], [1, { [Tp]: gVe }], [() => bI, { [RI]: wI }], [0, { [Tp]: fVe }]]], yHt = [3, $t, q3t, 0, [TI, cHt], [0, () => OHt]], SHt = [3, $t, G3t, 0, [TI, hVe, EI], [[0, { [Tp]: xVe }], [1, { [Tp]: gVe }], [() => bI, { [RI]: wI }]]], _Ht = [3, $t, V3t, 0, [TI, oHt], [0, () => PHt]], CHt = [3, $t, W3t, 0, [EI], [[() => bI, { [RI]: wI }]]], RHt = [-3, $t, X3t, { [SI]: yI, [CI]: 404 }, [AI], [0]]; k.for($t).registerError(RHt, fI); AHt = [3, $t, K3t, 0, [rHt, uHt, mHt, iHt], [0, [() => lHt, 0], [() => dHt, 0], 1]], THt = [3, $t, Q3t, 0, [EVe, xI], [0, 0]], wHt = [-3, $t, eHt, { [SI]: yI, [CI]: 429 }, [AI], [0]]; k.for($t).registerError(wHt, hI); bHt = [-3, $t, tHt, { [SI]: yI, [CI]: 401 }, [AI], [0]]; k.for($t).registerError(bHt, gI); IHt = "unit", vHt = [-3, yVe, "SSOServiceException", 0, [], []]; k.for(yVe).registerError(vHt, Qi); PHt = [1, $t, N3t, 0, () => fHt], OHt = [1, $t, Y3t, 0, () => THt], SVe = [9, $t, L3t, { [_I]: ["GET", "/federation/credentials", 200] }, () => hHt, () => gHt], _Ve = [9, $t, z3t, { [_I]: ["GET", "/assignment/roles", 200] }, () => EHt, () => yHt], CVe = [9, $t, H3t, { [_I]: ["GET", "/assignment/accounts", 200] }, () => SHt, () => _Ht], RVe = [9, $t, U3t, { [_I]: ["POST", "/logout", 200] }, () => CHt, () => IHt] }); var Hd, Y2 = s(() => { V(); F(); Pd(); Ud(); Hd = class extends R.classBuilder().ep(ic).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").sc(SVe).build() { } }); var Gd, II = s(() => { V(); F(); Pd(); Ud(); Gd = class extends R.classBuilder().ep(ic).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").sc(_Ve).build() { } }); var jd, vI = s(() => { V(); F(); Pd(); Ud(); jd = class extends R.classBuilder().ep(ic).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").sc(CVe).build() { } }); var PI, X2 = s(() => { V(); F(); Pd(); Ud(); PI = class extends R.classBuilder().ep(ic).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").sc(RVe).build() { } }); var DHt, J2, AVe = s(() => { F(); Y2(); II(); vI(); X2(); kx(); DHt = { GetRoleCredentialsCommand: Hd, ListAccountRolesCommand: Gd, ListAccountsCommand: jd, LogoutCommand: PI }, J2 = class extends ii { }; Ob(DHt, J2) }); var TVe = s(() => { Y2(); II(); vI(); X2() }); var wVe = s(() => { }); var _vo, bVe = s(() => { Ie(); II(); kx(); _vo = qe(ii, Gd, "nextToken", "nextToken", "maxResults") }); var wvo, IVe = s(() => { Ie(); vI(); kx(); wvo = qe(ii, jd, "nextToken", "nextToken", "maxResults") }); var vVe = s(() => { wVe(); bVe(); IVe() }); var PVe = s(() => { }); var OVe = s(() => { kx(); AVe(); TVe(); Ud(); vVe(); Q2(); PVe() }); var DVe = {}; Qe(DVe, { GetRoleCredentialsCommand: () => Hd, SSOClient: () => ii }); var kVe = s(() => { OVe() }); var Nx, Z2, NVe = s(() => { He(); B4e(); Z(); nn(); Nx = !1, Z2 = async ({ ssoStartUrl: e, ssoSession: t, ssoAccountId: r, ssoRegion: o, ssoRoleName: n, ssoClient: i, clientConfig: a, parentClientConfig: c, callerClientConfig: p, profile: u, filepath: l, configFilepath: m, ignoreCache: f, logger: h }) => { let E, S = "To refresh this SSO session run aws sso login with the corresponding profile."; if (t) try { let dt = await O4e({ profile: u, filepath: l, configFilepath: m, ignoreCache: f })(); E = { accessToken: dt.token, expiresAt: new Date(dt.expiration).toISOString() } } catch (dt) { throw new I(dt.message, { tryNextLink: Nx, logger: h }) } else try { E = await Mg(e) } catch { throw new I(`The SSO session associated with this profile is invalid. ${S}`, { tryNextLink: Nx, logger: h }) } if (new Date(E.expiresAt).getTime() - Date.now() <= 0) throw new I(`The SSO session associated with this profile has expired. ${S}`, { tryNextLink: Nx, logger: h }); let { accessToken: y } = E, { SSOClient: C, GetRoleCredentialsCommand: b } = await Promise.resolve().then(() => (kVe(), DVe)), L = i || new C(Object.assign({}, a ?? {}, { logger: a?.logger ?? p?.logger ?? c?.logger, region: a?.region ?? o, userAgentAppId: a?.userAgentAppId ?? p?.userAgentAppId ?? c?.userAgentAppId })), N; try { N = await L.send(new b({ accountId: r, roleName: n, accessToken: y })) } catch (dt) { throw new I(dt, { tryNextLink: Nx, logger: h }) } let { roleCredentials: { accessKeyId: j, secretAccessKey: re, sessionToken: Ce, expiration: O, credentialScope: ie, accountId: st } = {} } = N; if (!j || !re || !Ce || !O) throw new I("SSO returns an invalid temporary credential.", { tryNextLink: Nx, logger: h }); let Ct = { accessKeyId: j, secretAccessKey: re, sessionToken: Ce, expiration: new Date(O), ...ie && { credentialScope: ie }, ...st && { accountId: st } }; return t ? ee(Ct, "CREDENTIALS_SSO", "s") : ee(Ct, "CREDENTIALS_SSO_LEGACY", "u"), Ct } }); var eG, tG = s(() => {
  Z(); eG = (e, t) => {
    let { sso_start_url: r, sso_account_id: o, sso_region: n, sso_role_name: i } = e; if (!r || !o || !n || !i) throw new I(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: !1, logger: t }); return e
  }
}); var kHt, BVe = s(() => { Z(); nn(); I2(); NVe(); tG(); kHt = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO"); let { ssoStartUrl: r, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoSession: a } = e, { ssoClient: c } = e, p = jn({ profile: e.profile ?? t?.profile }); if (!r && !o && !n && !i && !a) { let l = (await Ka(e))[p]; if (!l) throw new I(`Profile ${p} was not found.`, { logger: e.logger }); if (!b2(l)) throw new I(`Profile ${p} is not configured with SSO credentials.`, { logger: e.logger }); if (l?.sso_session) { let C = (await xb(e))[l.sso_session], b = ` configurations in profile ${p} and sso-session ${l.sso_session}`; if (n && n !== C.sso_region) throw new I("Conflicting SSO region" + b, { tryNextLink: !1, logger: e.logger }); if (r && r !== C.sso_start_url) throw new I("Conflicting SSO start_url" + b, { tryNextLink: !1, logger: e.logger }); l.sso_region = C.sso_region, l.sso_start_url = C.sso_start_url } let { sso_start_url: m, sso_account_id: f, sso_region: h, sso_role_name: E, sso_session: S } = eG(l, e.logger); return Z2({ ssoStartUrl: m, ssoSession: S, ssoAccountId: f, ssoRegion: h, ssoRoleName: E, ssoClient: c, clientConfig: e.clientConfig, parentClientConfig: e.parentClientConfig, callerClientConfig: e.callerClientConfig, profile: p, filepath: e.filepath, configFilepath: e.configFilepath, ignoreCache: e.ignoreCache, logger: e.logger }) } else { if (!r || !o || !n || !i) throw new I('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', { tryNextLink: !1, logger: e.logger }); return Z2({ ssoStartUrl: r, ssoSession: a, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoClient: c, clientConfig: e.clientConfig, parentClientConfig: e.parentClientConfig, callerClientConfig: e.callerClientConfig, profile: p, filepath: e.filepath, configFilepath: e.configFilepath, ignoreCache: e.ignoreCache, logger: e.logger }) } } }); var LVe = s(() => { }); var rG = {}; Qe(rG, { fromSSO: () => kHt, isSsoProfile: () => b2, validateSsoProfile: () => eG }); var oG = s(() => { BVe(); I2(); LVe(); tG() }); var MVe, nG, $Ve = s(() => { He(); Z(); MVe = (e, t, r) => { let o = { EcsContainer: async n => { let { fromHttp: i } = await Promise.resolve().then(() => (vc(), Ic)), { fromContainerMetadata: a } = await Promise.resolve().then(() => (Px(), vx)); return r?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"), async () => sr(i(n ?? {}), a(n))().then(nG) }, Ec2InstanceMetadata: async n => { r?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata"); let { fromInstanceMetadata: i } = await Promise.resolve().then(() => (Px(), vx)); return async () => i(n)().then(nG) }, Environment: async n => { r?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment"); let { fromEnv: i } = await Promise.resolve().then(() => (E2(), t4e)); return async () => i(n)().then(nG) } }; if (e in o) return o[e]; throw new I(`Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger: r }) }, nG = e => ee(e, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p") }); var UVe, NHt, BHt, HVe, FVe, GVe = s(() => { He(); Z(); nn(); $Ve(); UVe = (e, { profile: t = "default", logger: r } = {}) => !!e && typeof e == "object" && typeof e.role_arn == "string" && ["undefined", "string"].indexOf(typeof e.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof e.external_id) > -1 && ["undefined", "string"].indexOf(typeof e.mfa_serial) > -1 && (NHt(e, { profile: t, logger: r }) || BHt(e, { profile: t, logger: r })), NHt = (e, { profile: t, logger: r }) => { let o = typeof e.source_profile == "string" && typeof e.credential_source > "u"; return o && r?.debug?.(`    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`), o }, BHt = (e, { profile: t, logger: r }) => { let o = typeof e.credential_source == "string" && typeof e.source_profile > "u"; return o && r?.debug?.(`    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`), o }, HVe = async (e, t, r, o, n = {}, i) => { r.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)"); let a = t[e], { source_profile: c, region: p } = a; if (!r.roleAssumer) { let { getDefaultRoleAssumer: l } = await Promise.resolve().then(() => (Qc(), Kc)); r.roleAssumer = l({ ...r.clientConfig, credentialProviderLogger: r.logger, parentClientConfig: { ...o, ...r?.parentClientConfig, region: p ?? r?.parentClientConfig?.region ?? o?.region } }, r.clientPlugins) } if (c && c in n) throw new I(`Detected a cycle attempting to resolve credentials for profile ${jn(r)}. Profiles visited: ` + Object.keys(n).join(", "), { logger: r.logger }); r.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${c ? `source_profile=[${c}]` : `profile=[${e}]`}`); let u = c ? i(c, t, r, o, { ...n, [c]: !0 }, FVe(t[c] ?? {})) : (await MVe(a.credential_source, e, r.logger)(r))(); if (FVe(a)) return u.then(l => ee(l, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")); { let l = { RoleArn: a.role_arn, RoleSessionName: a.role_session_name || `aws-sdk-js-${Date.now()}`, ExternalId: a.external_id, DurationSeconds: parseInt(a.duration_seconds || "3600", 10) }, { mfa_serial: m } = a; if (m) { if (!r.mfaCodeProvider) throw new I(`Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`, { logger: r.logger, tryNextLink: !1 }); l.SerialNumber = m, l.TokenCode = await r.mfaCodeProvider(m) } let f = await u; return r.roleAssumer(f, l).then(h => ee(h, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")) } }, FVe = e => !e.role_arn && !!e.credential_source }); var jVe, qVe, VVe = s(() => { He(); NC(); jVe = e => !!(e && e.login_session), qVe = async (e, t, r) => { let o = await qm({ ...t, profile: e })({ callerClientConfig: r }); return ee(o, "CREDENTIALS_PROFILE_LOGIN", "AC") } }); var zVe, WVe = s(() => { He(); zVe = (e, t, r) => { if (t.Version !== 1) throw Error(`Profile ${e} credential_process did not return Version 1.`); if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0) throw Error(`Profile ${e} credential_process returned invalid credentials.`); if (t.Expiration) { let i = new Date; if (new Date(t.Expiration) < i) throw Error(`Profile ${e} credential_process returned expired credentials.`) } let o = t.AccountId; !o && r?.[e]?.aws_account_id && (o = r[e].aws_account_id); let n = { accessKeyId: t.AccessKeyId, secretAccessKey: t.SecretAccessKey, ...t.SessionToken && { sessionToken: t.SessionToken }, ...t.Expiration && { expiration: new Date(t.Expiration) }, ...t.CredentialScope && { credentialScope: t.CredentialScope }, ...o && { accountId: o } }; return ee(n, "CREDENTIALS_PROCESS", "w"), n } }); import { exec as LHt } from "child_process"; import { promisify as MHt } from "util"; var KVe, QVe = s(() => { Z(); nn(); WVe(); KVe = async (e, t, r) => { let o = t[e]; if (t[e]) { let n = o.credential_process; if (n !== void 0) { let i = MHt(Hg?.getTokenRecord?.().exec ?? LHt); try { let { stdout: a } = await i(n), c; try { c = JSON.parse(a.trim()) } catch { throw Error(`Profile ${e} credential_process returned invalid JSON.`) } return zVe(e, c, t) } catch (a) { throw new I(a.message, { logger: r }) } } else throw new I(`Profile ${e} did not contain credential_process.`, { logger: r }) } else throw new I(`Profile ${e} could not be found in shared credentials file.`, { logger: r }) } }); var $Ht, YVe = s(() => { nn(); QVe(); $Ht = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess"); let r = await Ka(e); return KVe(jn({ profile: e.profile ?? t?.profile }), r, e.logger) } }); var sG = {}; Qe(sG, { fromProcess: () => $Ht }); var iG = s(() => { YVe() }); var XVe, JVe, ZVe = s(() => { He(); XVe = e => !!e && typeof e == "object" && typeof e.credential_process == "string", JVe = async (e, t) => Promise.resolve().then(() => (iG(), sG)).then(({ fromProcess: r }) => r({ ...e, profile: t })().then(o => ee(o, "CREDENTIALS_PROFILE_PROCESS", "v"))) }); var eze, tze, rze = s(() => { He(); eze = async (e, t, r = {}, o) => { let { fromSSO: n } = await Promise.resolve().then(() => (oG(), rG)); return n({ profile: e, logger: r.logger, parentClientConfig: r.parentClientConfig, clientConfig: r.clientConfig })({ callerClientConfig: o }).then(i => t.sso_session ? ee(i, "CREDENTIALS_PROFILE_SSO", "r") : ee(i, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")) }, tze = e => e && (typeof e.sso_start_url == "string" || typeof e.sso_account_id == "string" || typeof e.sso_session == "string" || typeof e.sso_region == "string" || typeof e.sso_role_name == "string") }); var aG, cG, oze = s(() => { He(); aG = e => !!e && typeof e == "object" && typeof e.aws_access_key_id == "string" && typeof e.aws_secret_access_key == "string" && ["undefined", "string"].indexOf(typeof e.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof e.aws_account_id) > -1, cG = async (e, t) => { t?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials"); let r = { accessKeyId: e.aws_access_key_id, secretAccessKey: e.aws_secret_access_key, sessionToken: e.aws_session_token, ...e.aws_credential_scope && { credentialScope: e.aws_credential_scope }, ...e.aws_account_id && { accountId: e.aws_account_id } }; return ee(r, "CREDENTIALS_PROFILE", "n") } }); var pG, uG = s(() => { pG = e => async t => { e.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken"); let { roleArn: r, roleSessionName: o, webIdentityToken: n, providerId: i, policyArns: a, policy: c, durationSeconds: p } = e, { roleAssumerWithWebIdentity: u } = e; if (!u) { let { getDefaultRoleAssumerWithWebIdentity: l } = await Promise.resolve().then(() => (Qc(), Kc)); u = l({ ...e.clientConfig, credentialProviderLogger: e.logger, parentClientConfig: { ...t?.callerClientConfig, ...e.parentClientConfig } }, e.clientPlugins) } return u({ RoleArn: r, RoleSessionName: o ?? `aws-sdk-js-session-${Date.now()}`, WebIdentityToken: n, ProviderId: i, PolicyArns: a, Policy: c, DurationSeconds: p }) } }); import { readFileSync as FHt } from "fs"; var nze, UHt, HHt, GHt, sze = s(() => { He(); Z(); nn(); uG(); nze = "AWS_WEB_IDENTITY_TOKEN_FILE", UHt = "AWS_ROLE_ARN", HHt = "AWS_ROLE_SESSION_NAME", GHt = (e = {}) => async t => { e.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile"); let r = e?.webIdentityTokenFile ?? process.env[nze], o = e?.roleArn ?? process.env[UHt], n = e?.roleSessionName ?? process.env[HHt]; if (!r || !o) throw new I("Web identity configuration not specified", { logger: e.logger }); let i = await pG({ ...e, webIdentityToken: Hg?.getTokenRecord?.()[r] ?? FHt(r, { encoding: "ascii" }), roleArn: o, roleSessionName: n })(t); return r === process.env[nze] && ee(i, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h"), i } }); var mG = {}; Qe(mG, { fromTokenFile: () => GHt, fromWebToken: () => pG }); var lG = s(() => { sze(); uG() }); var ize, aze, cze = s(() => { He(); ize = e => !!e && typeof e == "object" && typeof e.web_identity_token_file == "string" && typeof e.role_arn == "string" && ["undefined", "string"].indexOf(typeof e.role_session_name) > -1, aze = async (e, t, r) => Promise.resolve().then(() => (lG(), mG)).then(({ fromTokenFile: o }) => o({ webIdentityTokenFile: e.web_identity_token_file, roleArn: e.role_arn, roleSessionName: e.role_session_name, roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity, logger: t.logger, parentClientConfig: t.parentClientConfig })({ callerClientConfig: r }).then(n => ee(n, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))) }); var dG, pze = s(() => { Z(); GVe(); VVe(); ZVe(); rze(); oze(); cze(); dG = async (e, t, r, o, n = {}, i = !1) => { let a = t[e]; if (Object.keys(n).length > 0 && aG(a)) return cG(a, r); if (i || UVe(a, { profile: e, logger: r.logger })) return HVe(e, t, r, o, n, dG); if (aG(a)) return cG(a, r); if (ize(a)) return aze(a, r, o); if (XVe(a)) return JVe(r, e); if (tze(a)) return await eze(e, a, r, o); if (jVe(a)) return qVe(e, r, o); throw new I(`Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`, { logger: r.logger }) } }); var jHt, uze = s(() => { nn(); pze(); jHt = (e = {}) => async ({ callerClientConfig: t } = {}) => { e.logger?.debug("@aws-sdk/credential-provider-ini - fromIni"); let r = await Ka(e); return dG(jn({ profile: e.profile ?? t?.profile }), r, e, t) } }); var mze = {}; Qe(mze, { fromIni: () => jHt }); var lze = s(() => { uze() }); var dze, fze, qHt, hze = s(() => {
  E2(); Z(); nn(); E4e(); S4e(); dze = !1, fze = (e = {}) => y4e([async () => {
    if (e.profile ?? process.env[o3]) throw process.env[K0] && process.env[Q0] && (dze || ((e.logger?.warn && e.logger?.constructor?.name !== "NoOpLogger" ? e.logger.warn.bind(e.logger) : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`), dze = !0)), new I("AWS_PROFILE is set, skipping fromEnv provider.", { logger: e.logger, tryNextLink: !0 }); return e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv"), x2(e)()
  }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO"); let { ssoStartUrl: r, ssoAccountId: o, ssoRegion: n, ssoRoleName: i, ssoSession: a } = e; if (!r && !o && !n && !i && !a) throw new I("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: e.logger }); let { fromSSO: c } = await Promise.resolve().then(() => (oG(), rG)); return c(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni"); let { fromIni: r } = await Promise.resolve().then(() => (lze(), mze)); return r(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess"); let { fromProcess: r } = await Promise.resolve().then(() => (iG(), sG)); return r(e)(t) }, async t => { e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile"); let { fromTokenFile: r } = await Promise.resolve().then(() => (lG(), mG)); return r(e)(t) }, async () => (e.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"), (await x4e(e))()), async () => { throw new I("Could not load credentials from any providers", { tryNextLink: !1, logger: e.logger }) }], qHt), qHt = e => e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5
}); var gze = s(() => { hze() }); var xze = s(() => { }); var VHt, zHt, Eze, yze = s(() => { os(); VHt = "AWS_S3_USE_ARN_REGION", zHt = "s3_use_arn_region", Eze = { environmentVariableSelector: e => xt(e, VHt, ct.ENV), configFileSelector: e => xt(e, zHt, ct.CONFIG), default: void 0 } }); var Sze = s(() => { }); var _ze = s(() => { }); var Cze = s(() => { }); var Rze = s(() => { xze(); yze(); _ze(); Sze(); Cze() }); function Aze(e) { for (let t = 0; t < 8; t++)e[t] ^= 255; for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--); } var qd, fG = s(() => { Oo(); qd = class e { bytes; constructor(t) { if (this.bytes = t, t.byteLength !== 8) throw new Error("Int64 buffers must be exactly 8 bytes") } static fromNumber(t) { if (t > 9223372036854776e3 || t < -9223372036854776e3) throw new Error(`${t} is too large (or, if negative, too small) to represent as an Int64`); let r = new Uint8Array(8); for (let o = 7, n = Math.abs(Math.round(t)); o > -1 && n > 0; o--, n /= 256)r[o] = n; return t < 0 && Aze(r), new e(r) } valueOf() { let t = this.bytes.slice(0), r = t[0] & 128; return r && Aze(t), parseInt(it(t), 16) * (r ? -1 : 1) } toString() { return String(this.valueOf()) } } }); var OI, Tze, wze, WHt, KHt, QHt, YHt, XHt, JHt, ZHt, e2t, t2t, hG = s(() => { Oo(); fG(); OI = class { toUtf8; fromUtf8; constructor(t, r) { this.toUtf8 = t, this.fromUtf8 = r } format(t) { let r = []; for (let i of Object.keys(t)) { let a = this.fromUtf8(i); r.push(Uint8Array.from([a.byteLength]), a, this.formatHeaderValue(t[i])) } let o = new Uint8Array(r.reduce((i, a) => i + a.byteLength, 0)), n = 0; for (let i of r) o.set(i, n), n += i.byteLength; return o } formatHeaderValue(t) { switch (t.type) { case "boolean": return Uint8Array.from([t.value ? 0 : 1]); case "byte": return Uint8Array.from([2, t.value]); case "short": let r = new DataView(new ArrayBuffer(3)); return r.setUint8(0, 3), r.setInt16(1, t.value, !1), new Uint8Array(r.buffer); case "integer": let o = new DataView(new ArrayBuffer(5)); return o.setUint8(0, 4), o.setInt32(1, t.value, !1), new Uint8Array(o.buffer); case "long": let n = new Uint8Array(9); return n[0] = 5, n.set(t.value.bytes, 1), n; case "binary": let i = new DataView(new ArrayBuffer(3 + t.value.byteLength)); i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, !1); let a = new Uint8Array(i.buffer); return a.set(t.value, 3), a; case "string": let c = this.fromUtf8(t.value), p = new DataView(new ArrayBuffer(3 + c.byteLength)); p.setUint8(0, 7), p.setUint16(1, c.byteLength, !1); let u = new Uint8Array(p.buffer); return u.set(c, 3), u; case "timestamp": let l = new Uint8Array(9); return l[0] = 8, l.set(qd.fromNumber(t.value.valueOf()).bytes, 1), l; case "uuid": if (!t2t.test(t.value)) throw new Error(`Invalid UUID received: ${t.value}`); let m = new Uint8Array(17); return m[0] = 9, m.set(pE(t.value.replace(/\-/g, "")), 1), m } } parse(t) { let r = {}, o = 0; for (; o < t.byteLength;) { let n = t.getUint8(o++), i = this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + o, n)); switch (o += n, t.getUint8(o++)) { case 0: r[i] = { type: wze, value: !0 }; break; case 1: r[i] = { type: wze, value: !1 }; break; case 2: r[i] = { type: WHt, value: t.getInt8(o++) }; break; case 3: r[i] = { type: KHt, value: t.getInt16(o, !1) }, o += 2; break; case 4: r[i] = { type: QHt, value: t.getInt32(o, !1) }, o += 4; break; case 5: r[i] = { type: YHt, value: new qd(new Uint8Array(t.buffer, t.byteOffset + o, 8)) }, o += 8; break; case 6: let a = t.getUint16(o, !1); o += 2, r[i] = { type: XHt, value: new Uint8Array(t.buffer, t.byteOffset + o, a) }, o += a; break; case 7: let c = t.getUint16(o, !1); o += 2, r[i] = { type: JHt, value: this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + o, c)) }, o += c; break; case 8: r[i] = { type: ZHt, value: new Date(new qd(new Uint8Array(t.buffer, t.byteOffset + o, 8)).valueOf()) }, o += 8; break; case 9: let p = new Uint8Array(t.buffer, t.byteOffset + o, 16); o += 16, r[i] = { type: e2t, value: `${it(p.subarray(0, 4))}-${it(p.subarray(4, 6))}-${it(p.subarray(6, 8))}-${it(p.subarray(8, 10))}-${it(p.subarray(10))}` }; break; default: throw new Error("Unrecognized header type tag") } } return r } }; (function (e) { e[e.boolTrue = 0] = "boolTrue", e[e.boolFalse = 1] = "boolFalse", e[e.byte = 2] = "byte", e[e.short = 3] = "short", e[e.integer = 4] = "integer", e[e.long = 5] = "long", e[e.byteArray = 6] = "byteArray", e[e.string = 7] = "string", e[e.timestamp = 8] = "timestamp", e[e.uuid = 9] = "uuid" })(Tze || (Tze = {})); wze = "boolean", WHt = "byte", KHt = "short", QHt = "integer", YHt = "long", XHt = "binary", JHt = "string", ZHt = "timestamp", e2t = "uuid", t2t = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/ }); function Ize({ byteLength: e, byteOffset: t, buffer: r }) { if (e < r2t) throw new Error("Provided message too short to accommodate event stream message overhead"); let o = new DataView(r, t, e), n = o.getUint32(0, !1); if (e !== n) throw new Error("Reported message length does not match received message length"); let i = o.getUint32(bze, !1), a = o.getUint32(pc, !1), c = o.getUint32(e - wp, !1), p = new cp().update(new Uint8Array(r, t, pc)); if (a !== p.digest()) throw new Error(`The prelude checksum specified in the message (${a}) does not match the calculated CRC32 checksum (${p.digest()})`); if (p.update(new Uint8Array(r, t + pc, e - (pc + wp))), c !== p.digest()) throw new Error(`The message checksum (${p.digest()}) did not match the expected value of ${c}`); return { headers: new DataView(r, t + pc + wp, i), body: new Uint8Array(r, t + pc + wp + i, n - i - (pc + wp + wp)) } } var bze, pc, wp, r2t, vze = s(() => { Pg(); bze = 4, pc = bze * 2, wp = 4, r2t = pc + wp * 2 }); var DI, Pze = s(() => { Pg(); hG(); vze(); DI = class { headerMarshaller; messageBuffer; isEndOfStream; constructor(t, r) { this.headerMarshaller = new OI(t, r), this.messageBuffer = [], this.isEndOfStream = !1 } feed(t) { this.messageBuffer.push(this.decode(t)) } endOfStream() { this.isEndOfStream = !0 } getMessage() { let t = this.messageBuffer.pop(), r = this.isEndOfStream; return { getMessage() { return t }, isEndOfStream() { return r } } } getAvailableMessages() { let t = this.messageBuffer; this.messageBuffer = []; let r = this.isEndOfStream; return { getMessages() { return t }, isEndOfStream() { return r } } } encode({ headers: t, body: r }) { let o = this.headerMarshaller.format(t), n = o.byteLength + r.byteLength + 16, i = new Uint8Array(n), a = new DataView(i.buffer, i.byteOffset, i.byteLength), c = new cp; return a.setUint32(0, n, !1), a.setUint32(4, o.byteLength, !1), a.setUint32(8, c.update(i.subarray(0, 8)).digest(), !1), i.set(o, 12), i.set(r, o.byteLength + 12), a.setUint32(n - 4, c.update(i.subarray(8, n - 4)).digest(), !1), i } decode(t) { let { headers: r, body: o } = Ize(t); return { headers: this.headerMarshaller.parse(r), body: o } } formatHeaders(t) { return this.headerMarshaller.format(t) } } }); var Oze = s(() => { }); var kI, Dze = s(() => { kI = class { options; constructor(t) { this.options = t } [Symbol.asyncIterator]() { return this.asyncIterator() } async*asyncIterator() { for await (let t of this.options.inputStream) yield this.options.decoder.decode(t) } } }); var NI, kze = s(() => { NI = class { options; constructor(t) { this.options = t } [Symbol.asyncIterator]() { return this.asyncIterator() } async*asyncIterator() { for await (let t of this.options.messageStream) yield this.options.encoder.encode(t); this.options.includeEndFrame && (yield new Uint8Array(0)) } } }); var BI, Nze = s(() => { BI = class { options; constructor(t) { this.options = t } [Symbol.asyncIterator]() { return this.asyncIterator() } async*asyncIterator() { for await (let t of this.options.messageStream) { let r = await this.options.deserializer(t); r !== void 0 && (yield r) } } } }); var LI, Bze = s(() => { LI = class { options; constructor(t) { this.options = t } [Symbol.asyncIterator]() { return this.asyncIterator() } async*asyncIterator() { for await (let t of this.options.inputStream) yield this.options.serializer(t) } } }); var Lze = s(() => { Pze(); hG(); fG(); Oze(); Dze(); kze(); Nze(); Bze() }); function Mze(e) { let t = 0, r = 0, o = null, n = null, i = c => { if (typeof c != "number") throw new Error("Attempted to allocate an event message where size was not a number: " + c); t = c, r = 4, o = new Uint8Array(c), new DataView(o.buffer).setUint32(0, c, !1) }, a = async function* () { let c = e[Symbol.asyncIterator](); for (; ;) { let { value: p, done: u } = await c.next(); if (u) { if (t) if (t === r) yield o; else throw new Error("Truncated event message received."); else return; return } let l = p.length, m = 0; for (; m < l;) { if (!o) { let h = l - m; n || (n = new Uint8Array(4)); let E = Math.min(4 - r, h); if (n.set(p.slice(m, m + E), r), r += E, m += E, r < 4) break; i(new DataView(n.buffer).getUint32(0, !1)), n = null } let f = Math.min(t - r, l - m); o.set(p.slice(m, m + f), r), r += f, m += f, t && t === r && (yield o, o = null, t = 0, r = 0) } } }; return { [Symbol.asyncIterator]: a } } var $ze = s(() => { }); function Fze(e, t) { return async function (r) { let { value: o } = r.headers[":message-type"]; if (o === "error") { let n = new Error(r.headers[":error-message"].value || "UnknownError"); throw n.name = r.headers[":error-code"].value, n } else if (o === "exception") { let n = r.headers[":exception-type"].value, i = { [n]: r }, a = await e(i); if (a.$unknown) { let c = new Error(t(r.body)); throw c.name = n, c } throw a[n] } else if (o === "event") { let n = { [r.headers[":event-type"].value]: r }, i = await e(n); return i.$unknown ? void 0 : i } else throw Error(`Unrecognizable event type: ${r.headers[":event-type"].value}`) } } var Uze = s(() => { }); var MI, Hze = s(() => { Lze(); $ze(); Uze(); MI = class { eventStreamCodec; utfEncoder; constructor({ utf8Encoder: t, utf8Decoder: r }) { this.eventStreamCodec = new DI(t, r), this.utfEncoder = t } deserialize(t, r) { let o = Mze(t); return new BI({ messageStream: new kI({ inputStream: o, decoder: this.eventStreamCodec }), deserializer: Fze(r, this.utfEncoder) }) } serialize(t, r) { return new NI({ messageStream: new LI({ inputStream: t, serializer: r }), encoder: this.eventStreamCodec, includeEndFrame: !0 }) } } }); var Gze = s(() => { }); var jze = s(() => { Hze(); Gze() }); async function* qze(e) { let t = !1, r = !1, o = new Array; for (e.on("error", n => { if (t || (t = !0), n) throw n }), e.on("data", n => { o.push(n) }), e.on("end", () => { t = !0 }); !r;) { let n = await new Promise(i => setTimeout(() => i(o.shift()), 0)); n && (yield n), r = t && o.length === 0 } } var Vze = s(() => { }); import { Readable as o2t } from "stream"; var $I, gG = s(() => { jze(); Vze(); $I = class { universalMarshaller; constructor({ utf8Encoder: t, utf8Decoder: r }) { this.universalMarshaller = new MI({ utf8Decoder: r, utf8Encoder: t }) } deserialize(t, r) { let o = typeof t[Symbol.asyncIterator] == "function" ? t : qze(t); return this.universalMarshaller.deserialize(o, r) } serialize(t, r) { return o2t.from(this.universalMarshaller.serialize(t, r)) } } }); var zze, Wze = s(() => { gG(); zze = e => new $I(e) }); var Kze = s(() => { gG(); Wze() }); import { Buffer as Qze } from "buffer"; var Yze, Xze = s(() => { Yze = (e, t) => { if (typeof e != "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof e} (${e})`); return t ? Qze.from(e, t) : Qze.from(e) } }); var Jze, xG = s(() => { Xze(); Jze = e => { let t = Yze(e, "utf8"); return new Uint8Array(t.buffer, t.byteOffset, t.byteLength / Uint8Array.BYTES_PER_ELEMENT) } }); var Zze, eWe = s(() => { xG(); Zze = e => typeof e == "string" ? Jze(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e) }); var tWe = s(() => { }); var rWe = s(() => { xG(); eWe(); tWe() }); import { Writable as n2t } from "stream"; var FI, oWe = s(() => { rWe(); FI = class extends n2t { hash; constructor(t, r) { super(r), this.hash = t } _write(t, r, o) { try { this.hash.update(Zze(t)) } catch (n) { return o(n) } o() } } }); var nWe = s(() => { }); var sWe, iWe = s(() => { oWe(); sWe = (e, t) => { if (t.readableFlowing !== null) throw new Error("Unable to calculate hash for flowing readable stream"); let r = new e, o = new FI(r); return t.pipe(o), new Promise((n, i) => { t.on("error", a => { o.end(), i(a) }), o.on("error", i), o.on("finish", () => { r.digest().then(n).catch(i) }) }) } }); var aWe = s(() => { nWe(); iWe() }); var cWe = s(() => { }); var pWe = s(() => { }); var EG, yG = s(() => { EG = e => typeof ReadableStream == "function" && (e?.constructor?.name === ReadableStream.name || e instanceof ReadableStream) }); var uWe = s(() => { }); var mWe = s(() => { }); import { Readable as s2t } from "stream"; var lWe, dWe = s(() => {
  lWe = (e, t) => {
    let { base64Encoder: r, bodyLengthChecker: o, checksumAlgorithmFn: n, checksumLocationName: i, streamHasher: a } = t, c = r !== void 0 && n !== void 0 && i !== void 0 && a !== void 0, p = c ? a(n, e) : void 0, u = new s2t({ read: () => { } }); return e.on("data", l => {
      let m = o(l) || 0; u.push(`${m.toString(16)}\r
`), u.push(l), u.push(`\r
`)
    }), e.on("end", async () => {
      if (u.push(`0\r
`), c) {
        let l = r(await p); u.push(`${i}:${l}\r
`), u.push(`\r
`)
      } u.push(null)
    }), u
  }
}); var fWe = s(() => { }); import { Buffer as i2t } from "buffer"; var hWe, gWe = s(() => { cr(); hWe = (e, t = 0, r = e.byteLength - t) => { if (!Le(e)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`); return i2t.from(e, t, r) } }); var xWe = s(() => { }); async function a2t(e) { let t = await p2t(e), r = Bd(t); return new Uint8Array(r) } async function c2t(e) { let t = [], r = e.getReader(), o = !1, n = 0; for (; !o;) { let { done: c, value: p } = await r.read(); p && (t.push(p), n += p.length), o = c } let i = new Uint8Array(n), a = 0; for (let c of t) i.set(c, a), a += c.length; return i } function p2t(e) { return new Promise((t, r) => { let o = new FileReader; o.onloadend = () => { if (o.readyState !== 2) return r(new Error("Reader aborted too early")); let n = o.result ?? "", i = n.indexOf(","), a = i > -1 ? i + 1 : n.length; t(n.substring(a)) }, o.onabort = () => r(new Error("Read aborted")), o.onerror = () => r(o.error), o.readAsDataURL(e) }) } var EWe, yWe = s(() => { Ox(); EWe = async e => typeof Blob == "function" && e instanceof Blob || e.constructor?.name === "Blob" ? Blob.prototype.arrayBuffer !== void 0 ? new Uint8Array(await e.arrayBuffer()) : a2t(e) : c2t(e) }); var SWe = s(() => { xWe(); yWe() }); var _We, RWe, CWe, AWe = s(() => {
  SWe(); Ox(); Oo(); Dd(); yG(); _We = "The stream has already been transformed.", RWe = e => {
    if (!CWe(e) && !EG(e)) { let n = e?.__proto__?.constructor?.name || e; throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${n}`) } let t = !1, r = async () => { if (t) throw new Error(_We); return t = !0, await EWe(e) }, o = n => {
      if (typeof n.stream != "function") throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`); return n.stream()
    }; return Object.assign(e, { transformToByteArray: r, transformToString: async n => { let i = await r(); if (n === "base64") return Ld(i); if (n === "hex") return it(i); if (n === void 0 || n === "utf8" || n === "utf-8") return Od(i); if (typeof TextDecoder == "function") return new TextDecoder(n).decode(i); throw new Error("TextDecoder is not available, please make sure polyfill is provided.") }, transformToWebStream: () => { if (t) throw new Error(_We); if (t = !0, CWe(e)) return o(e); if (EG(e)) return e; throw new Error(`Cannot transform payload to web stream, got ${e}`) } })
  }, CWe = e => typeof Blob == "function" && e instanceof Blob
}); import { Readable as SG } from "stream"; var TWe, wWe, bWe = s(() => { uI(); gWe(); AWe(); TWe = "The stream has already been transformed.", wWe = e => { if (!(e instanceof SG)) try { return RWe(e) } catch { let n = e?.__proto__?.constructor?.name || e; throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${n}`) } let t = !1, r = async () => { if (t) throw new Error(TWe); return t = !0, await Nd(e) }; return Object.assign(e, { transformToByteArray: r, transformToString: async o => { let n = await r(); return o === void 0 || Buffer.isEncoding(o) ? hWe(n.buffer, n.byteOffset, n.byteLength).toString(o) : new TextDecoder(o).decode(n) }, transformToWebStream: () => { if (t) throw new Error(TWe); if (e.readableFlowing !== null) throw new Error("The stream has been consumed by other callbacks."); if (typeof SG.toWeb != "function") throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available."); return t = !0, SG.toWeb(e) } }) } }); var IWe = s(() => { }); var vWe = s(() => { cWe(); pWe(); uWe(); mWe(); dWe(); fWe(); bWe(); IWe(); yG() }); var PWe, OWe = s(() => { Ye(); yn(); _3(); F(); Bg(); Ox(); vWe(); Dd(); tH(); eH(); PWe = e => ({ apiVersion: "2006-03-01", base64Decoder: e?.base64Decoder ?? Bd, base64Encoder: e?.base64Encoder ?? Ld, disableHostPrefix: e?.disableHostPrefix ?? !1, endpointProvider: e?.endpointProvider ?? zb, extensions: e?.extensions ?? [], getAwsChunkedEncodingStream: e?.getAwsChunkedEncodingStream ?? lWe, httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? l1e, httpAuthSchemes: e?.httpAuthSchemes ?? [{ schemeId: "aws.auth#sigv4", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4"), signer: new Vt }, { schemeId: "aws.auth#sigv4a", identityProvider: t => t.getIdentityProvider("aws.auth#sigv4a"), signer: new Tf }], logger: e?.logger ?? new Ya, protocol: e?.protocol ?? ry, protocolSettings: e?.protocolSettings ?? { defaultNamespace: "com.amazonaws.s3", xmlNamespace: "http://s3.amazonaws.com/doc/2006-03-01/", version: "2006-03-01", serviceTarget: "AmazonS3" }, sdkStreamMixin: e?.sdkStreamMixin ?? wWe, serviceId: e?.serviceId ?? "S3", signerConstructor: e?.signerConstructor ?? zl, signingEscapePath: e?.signingEscapePath ?? !1, urlParser: e?.urlParser ?? Js, useArnRegion: e?.useArnRegion ?? void 0, utf8Decoder: e?.utf8Decoder ?? ac, utf8Encoder: e?.utf8Encoder ?? Od }) }); var DWe, kWe = s(() => { Kje(); Ye(); gze(); Rze(); lt(); pe(); O2(); $l(); Kze(); M2(); aWe(); jg(); pp(); uI(); F(); U2(); j2(); Gg(); OWe(); DWe = e => { kb(process.version); let t = lI(e), r = () => t().then(Db), o = PWe(e); Hr(process.version); let n = { profile: e?.profile, logger: o.logger }; return { ...o, ...e, runtime: "node", defaultsMode: t, authSchemePreference: e?.authSchemePreference ?? ht(Gr, n), bodyLengthChecker: e?.bodyLengthChecker ?? mI, credentialDefaultProvider: e?.credentialDefaultProvider ?? fze, defaultUserAgentProvider: e?.defaultUserAgentProvider ?? iI({ serviceId: o.serviceId, clientVersion: Qje.version }), disableS3ExpressSessionAuth: e?.disableS3ExpressSessionAuth ?? ht(H1, n), eventStreamSerdeProvider: e?.eventStreamSerdeProvider ?? zze, maxAttempts: e?.maxAttempts ?? ht(bb, e), md5: e?.md5 ?? cc.bind(null, "md5"), region: e?.region ?? ht(Ml, { ...ib, ...n }), requestChecksumCalculation: e?.requestChecksumCalculation ?? ht(cDe, n), requestHandler: kd.create(e?.requestHandler ?? r), responseChecksumValidation: e?.responseChecksumValidation ?? ht(uDe, n), retryMode: e?.retryMode ?? ht({ ...vb, default: async () => (await r()).retryMode || Hl }, e), sha1: e?.sha1 ?? cc.bind(null, "sha1"), sha256: e?.sha256 ?? cc.bind(null, "sha256"), sigv4aSigningRegionSet: e?.sigv4aSigningRegionSet ?? ht(xQ, n), streamCollector: e?.streamCollector ?? Nd, streamHasher: e?.streamHasher ?? sWe, useArnRegion: e?.useArnRegion ?? ht(Eze, n), useDualstackEndpoint: e?.useDualstackEndpoint ?? ht(nb, n), useFipsEndpoint: e?.useFipsEndpoint ?? ht(sb, n), userAgentAppId: e?.userAgentAppId ?? ht(aI, n) } } }); var NWe, BWe, LWe = s(() => { NWe = e => { let t = e.httpAuthSchemes, r = e.httpAuthSchemeProvider, o = e.credentials; return { setHttpAuthScheme(n) { let i = t.findIndex(a => a.schemeId === n.schemeId); i === -1 ? t.push(n) : t.splice(i, 1, n) }, httpAuthSchemes() { return t }, setHttpAuthSchemeProvider(n) { r = n }, httpAuthSchemeProvider() { return r }, setCredentials(n) { o = n }, credentials() { return o } } }, BWe = e => ({ httpAuthSchemes: e.httpAuthSchemes(), httpAuthSchemeProvider: e.httpAuthSchemeProvider(), credentials: e.credentials() }) }); var MWe, $We = s(() => { ps(); Hi(); F(); LWe(); MWe = (e, t) => { let r = Object.assign(Vr(e), Nb(e), Fw(e), NWe(e)); return t.forEach(o => o.configure(r)), Object.assign(e, zr(r), Bb(r), Uw(r), BWe(r)) } }); var Wo, bp = s(() => { iDe(); lt(); N1(); B1(); $1(); pe(); ob(); $l(); Ie(); Oe(); MMe(); e3(); V(); jg(); F(); tH(); W0(); K(); kWe(); $We(); Wo = class extends ql { config; constructor(...[t]) { let r = DWe(t || {}); super(r), this.initConfig = r; let o = f1e(r), n = Xw(o), i = Uke(n), a = Ib(i), c = cb(a), p = c, u = _b(p), l = BMe(u), m = d1e(l), f = gLe(m, { session: [() => this, Id] }), h = MWe(f, t?.extensions || []); this.config = h, this.middlewareStack.use(Fr(this.config)), this.middlewareStack.use(rb(this.config)), this.middlewareStack.use(Lb(this.config)), this.middlewareStack.use(pb(this.config)), this.middlewareStack.use(Hw(this.config)), this.middlewareStack.use(Gw(this.config)), this.middlewareStack.use(jw(this.config)), this.middlewareStack.use(Mr(this.config, { httpAuthSchemeParametersProvider: p1e, identityProviderConfigProvider: async E => new Cr({ "aws.auth#sigv4": E.credentials, "aws.auth#sigv4a": E.credentials }) })), this.middlewareStack.use($r(this.config)), this.middlewareStack.use(HLe(this.config)), this.middlewareStack.use(sDe(this.config)), this.middlewareStack.use(XBe(this.config)), this.middlewareStack.use(G1(this.config)), this.middlewareStack.use(j1(this.config)) } destroy() { super.destroy() } } }); var UI, _G = s(() => { pe(); V(); F(); K(); Q(); UI = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "AbortMultipartUpload", {}).n("S3Client", "AbortMultipartUploadCommand").sc(Y2e).build() { } }); function u2t(e) { return t => async r => { let o = { ...r.input }, n = [{ target: "SSECustomerKey", hash: "SSECustomerKeyMD5" }, { target: "CopySourceSSECustomerKey", hash: "CopySourceSSECustomerKeyMD5" }]; for (let i of n) { let a = o[i.target]; if (a) { let c; typeof a == "string" ? l2t(a, e) ? c = e.base64Decoder(a) : (c = e.utf8Decoder(a), o[i.target] = e.base64Encoder(c)) : (c = ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : new Uint8Array(a), o[i.target] = e.base64Encoder(c)); let p = new e.md5; p.update(c), o[i.hash] = e.base64Encoder(await p.digest()) } } return t({ ...r, input: o }) } } function l2t(e, t) { if (!/^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)) return !1; try { return t.base64Decoder(e).length === 32 } catch { return !1 } } var m2t, ar, Jn = s(() => { m2t = { name: "ssecMiddleware", step: "initialize", tags: ["SSE"], override: !0 }, ar = e => ({ applyToStack: t => { t.add(u2t(e), m2t) } }) }); var HI, CG = s(() => { pe(); Jn(); V(); F(); K(); Q(); HI = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), ar(o)] }).s("AmazonS3", "CompleteMultipartUpload", {}).n("S3Client", "CompleteMultipartUploadCommand").sc(X2e).build() { } }); var GI, RG = s(() => { pe(); Jn(); V(); F(); K(); Q(); GI = class extends R.classBuilder().ep({ ...w, DisableS3ExpressSessionAuth: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" }, CopySource: { type: "contextParams", name: "CopySource" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), ar(o)] }).s("AmazonS3", "CopyObject", {}).n("S3Client", "CopyObjectCommand").sc(J2e).build() { } }); function d2t(e) { return t => async r => { let { CreateBucketConfiguration: o } = r.input, n = await e.region(); return !o?.LocationConstraint && !o?.Location && n !== "us-east-1" && (r.input.CreateBucketConfiguration = r.input.CreateBucketConfiguration ?? {}, r.input.CreateBucketConfiguration.LocationConstraint = n), t(r) } } var f2t, FWe, UWe = s(() => { f2t = { step: "initialize", tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"], name: "locationConstraintMiddleware", override: !0 }, FWe = e => ({ applyToStack: t => { t.add(d2t(e), f2t) } }) }); var jI, AG = s(() => { UWe(); pe(); V(); F(); K(); Q(); jI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, DisableAccessPoints: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), FWe(o)] }).s("AmazonS3", "CreateBucket", {}).n("S3Client", "CreateBucketCommand").sc(Z2e).build() { } }); var qI, TG = s(() => { lt(); V(); F(); K(); Q(); qI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "CreateBucketMetadataConfiguration", {}).n("S3Client", "CreateBucketMetadataConfigurationCommand").sc(eGe).build() { } }); var VI, wG = s(() => { lt(); V(); F(); K(); Q(); VI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "CreateBucketMetadataTableConfiguration", {}).n("S3Client", "CreateBucketMetadataTableConfigurationCommand").sc(tGe).build() { } }); var zI, bG = s(() => { pe(); Jn(); V(); F(); K(); Q(); zI = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), ar(o)] }).s("AmazonS3", "CreateMultipartUpload", {}).n("S3Client", "CreateMultipartUploadCommand").sc(rGe).build() { } }); var WI, IG = s(() => { V(); F(); K(); Q(); WI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketAnalyticsConfiguration", {}).n("S3Client", "DeleteBucketAnalyticsConfigurationCommand").sc(sGe).build() { } }); var KI, vG = s(() => { V(); F(); K(); Q(); KI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucket", {}).n("S3Client", "DeleteBucketCommand").sc(nGe).build() { } }); var QI, PG = s(() => { V(); F(); K(); Q(); QI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketCors", {}).n("S3Client", "DeleteBucketCorsCommand").sc(iGe).build() { } }); var YI, OG = s(() => { V(); F(); K(); Q(); YI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketEncryption", {}).n("S3Client", "DeleteBucketEncryptionCommand").sc(aGe).build() { } }); var XI, DG = s(() => { V(); F(); K(); Q(); XI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketIntelligentTieringConfiguration", {}).n("S3Client", "DeleteBucketIntelligentTieringConfigurationCommand").sc(cGe).build() { } }); var JI, kG = s(() => { V(); F(); K(); Q(); JI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketInventoryConfiguration", {}).n("S3Client", "DeleteBucketInventoryConfigurationCommand").sc(pGe).build() { } }); var ZI, NG = s(() => { V(); F(); K(); Q(); ZI = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketLifecycle", {}).n("S3Client", "DeleteBucketLifecycleCommand").sc(uGe).build() { } }); var ev, BG = s(() => { V(); F(); K(); Q(); ev = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketMetadataConfiguration", {}).n("S3Client", "DeleteBucketMetadataConfigurationCommand").sc(mGe).build() { } }); var tv, LG = s(() => { V(); F(); K(); Q(); tv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketMetadataTableConfiguration", {}).n("S3Client", "DeleteBucketMetadataTableConfigurationCommand").sc(lGe).build() { } }); var rv, MG = s(() => { V(); F(); K(); Q(); rv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketMetricsConfiguration", {}).n("S3Client", "DeleteBucketMetricsConfigurationCommand").sc(dGe).build() { } }); var ov, $G = s(() => { V(); F(); K(); Q(); ov = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketOwnershipControls", {}).n("S3Client", "DeleteBucketOwnershipControlsCommand").sc(fGe).build() { } }); var nv, FG = s(() => { V(); F(); K(); Q(); nv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketPolicy", {}).n("S3Client", "DeleteBucketPolicyCommand").sc(hGe).build() { } }); var sv, UG = s(() => { V(); F(); K(); Q(); sv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketReplication", {}).n("S3Client", "DeleteBucketReplicationCommand").sc(gGe).build() { } }); var iv, HG = s(() => { V(); F(); K(); Q(); iv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketTagging", {}).n("S3Client", "DeleteBucketTaggingCommand").sc(xGe).build() { } }); var av, GG = s(() => { V(); F(); K(); Q(); av = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeleteBucketWebsite", {}).n("S3Client", "DeleteBucketWebsiteCommand").sc(EGe).build() { } }); var Vd, jG = s(() => { pe(); V(); F(); K(); Q(); Vd = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "DeleteObject", {}).n("S3Client", "DeleteObjectCommand").sc(yGe).build() { } }); var cv, qG = s(() => { lt(); pe(); V(); F(); K(); Q(); cv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 }), M(o)] }).s("AmazonS3", "DeleteObjects", {}).n("S3Client", "DeleteObjectsCommand").sc(SGe).build() { } }); var pv, VG = s(() => { pe(); V(); F(); K(); Q(); pv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "DeleteObjectTagging", {}).n("S3Client", "DeleteObjectTaggingCommand").sc(_Ge).build() { } }); var uv, zG = s(() => { V(); F(); K(); Q(); uv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "DeletePublicAccessBlock", {}).n("S3Client", "DeletePublicAccessBlockCommand").sc(CGe).build() { } }); var mv, WG = s(() => { pe(); V(); F(); K(); Q(); mv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketAbac", {}).n("S3Client", "GetBucketAbacCommand").sc(RGe).build() { } }); var lv, KG = s(() => { pe(); V(); F(); K(); Q(); lv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketAccelerateConfiguration", {}).n("S3Client", "GetBucketAccelerateConfigurationCommand").sc(AGe).build() { } }); var dv, QG = s(() => { pe(); V(); F(); K(); Q(); dv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketAcl", {}).n("S3Client", "GetBucketAclCommand").sc(TGe).build() { } }); var fv, YG = s(() => { pe(); V(); F(); K(); Q(); fv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketAnalyticsConfiguration", {}).n("S3Client", "GetBucketAnalyticsConfigurationCommand").sc(wGe).build() { } }); var hv, XG = s(() => { pe(); V(); F(); K(); Q(); hv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketCors", {}).n("S3Client", "GetBucketCorsCommand").sc(bGe).build() { } }); var gv, JG = s(() => { pe(); V(); F(); K(); Q(); gv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketEncryption", {}).n("S3Client", "GetBucketEncryptionCommand").sc(IGe).build() { } }); var xv, ZG = s(() => { pe(); V(); F(); K(); Q(); xv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketIntelligentTieringConfiguration", {}).n("S3Client", "GetBucketIntelligentTieringConfigurationCommand").sc(vGe).build() { } }); var Ev, ej = s(() => { pe(); V(); F(); K(); Q(); Ev = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketInventoryConfiguration", {}).n("S3Client", "GetBucketInventoryConfigurationCommand").sc(PGe).build() { } }); var yv, tj = s(() => { pe(); V(); F(); K(); Q(); yv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketLifecycleConfiguration", {}).n("S3Client", "GetBucketLifecycleConfigurationCommand").sc(OGe).build() { } }); var Sv, rj = s(() => { pe(); V(); F(); K(); Q(); Sv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketLocation", {}).n("S3Client", "GetBucketLocationCommand").sc(DGe).build() { } }); var _v, oj = s(() => { pe(); V(); F(); K(); Q(); _v = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketLogging", {}).n("S3Client", "GetBucketLoggingCommand").sc(kGe).build() { } }); var Cv, nj = s(() => { pe(); V(); F(); K(); Q(); Cv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketMetadataConfiguration", {}).n("S3Client", "GetBucketMetadataConfigurationCommand").sc(NGe).build() { } }); var Rv, sj = s(() => { pe(); V(); F(); K(); Q(); Rv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketMetadataTableConfiguration", {}).n("S3Client", "GetBucketMetadataTableConfigurationCommand").sc(BGe).build() { } }); var Av, ij = s(() => { pe(); V(); F(); K(); Q(); Av = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketMetricsConfiguration", {}).n("S3Client", "GetBucketMetricsConfigurationCommand").sc(LGe).build() { } }); var Tv, aj = s(() => { pe(); V(); F(); K(); Q(); Tv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketNotificationConfiguration", {}).n("S3Client", "GetBucketNotificationConfigurationCommand").sc(MGe).build() { } }); var wv, cj = s(() => { pe(); V(); F(); K(); Q(); wv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketOwnershipControls", {}).n("S3Client", "GetBucketOwnershipControlsCommand").sc($Ge).build() { } }); var bv, pj = s(() => { pe(); V(); F(); K(); Q(); bv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketPolicy", {}).n("S3Client", "GetBucketPolicyCommand").sc(FGe).build() { } }); var Iv, uj = s(() => { pe(); V(); F(); K(); Q(); Iv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketPolicyStatus", {}).n("S3Client", "GetBucketPolicyStatusCommand").sc(UGe).build() { } }); var vv, mj = s(() => { pe(); V(); F(); K(); Q(); vv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketReplication", {}).n("S3Client", "GetBucketReplicationCommand").sc(HGe).build() { } }); var Pv, lj = s(() => { pe(); V(); F(); K(); Q(); Pv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketRequestPayment", {}).n("S3Client", "GetBucketRequestPaymentCommand").sc(GGe).build() { } }); var Ov, dj = s(() => { pe(); V(); F(); K(); Q(); Ov = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketTagging", {}).n("S3Client", "GetBucketTaggingCommand").sc(jGe).build() { } }); var Dv, fj = s(() => { pe(); V(); F(); K(); Q(); Dv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketVersioning", {}).n("S3Client", "GetBucketVersioningCommand").sc(qGe).build() { } }); var kv, hj = s(() => { pe(); V(); F(); K(); Q(); kv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetBucketWebsite", {}).n("S3Client", "GetBucketWebsiteCommand").sc(VGe).build() { } }); var Nv, gj = s(() => { pe(); V(); F(); K(); Q(); Nv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetObjectAcl", {}).n("S3Client", "GetObjectAclCommand").sc(WGe).build() { } }); var Bv, xj = s(() => { pe(); Jn(); V(); F(); K(); Q(); Bv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), ar(o)] }).s("AmazonS3", "GetObjectAttributes", {}).n("S3Client", "GetObjectAttributesCommand").sc(KGe).build() { } }); var zd, Ej = s(() => { lt(); pe(); Jn(); V(); F(); K(); Q(); zd = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestChecksumRequired: !1, requestValidationModeMember: "ChecksumMode", responseAlgorithms: ["CRC64NVME", "CRC32", "CRC32C", "SHA256", "SHA1"] }), ar(o), Vw(o)] }).s("AmazonS3", "GetObject", {}).n("S3Client", "GetObjectCommand").sc(zGe).build() { } }); var Lv, yj = s(() => { pe(); V(); F(); K(); Q(); Lv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetObjectLegalHold", {}).n("S3Client", "GetObjectLegalHoldCommand").sc(QGe).build() { } }); var Mv, Sj = s(() => { pe(); V(); F(); K(); Q(); Mv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetObjectLockConfiguration", {}).n("S3Client", "GetObjectLockConfigurationCommand").sc(YGe).build() { } }); var $v, _j = s(() => { pe(); V(); F(); K(); Q(); $v = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetObjectRetention", {}).n("S3Client", "GetObjectRetentionCommand").sc(XGe).build() { } }); var Fv, Cj = s(() => { pe(); V(); F(); K(); Q(); Fv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetObjectTagging", {}).n("S3Client", "GetObjectTaggingCommand").sc(JGe).build() { } }); var Uv, Rj = s(() => { V(); F(); K(); Q(); Uv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "GetObjectTorrent", {}).n("S3Client", "GetObjectTorrentCommand").sc(ZGe).build() { } }); var Hv, Aj = s(() => { pe(); V(); F(); K(); Q(); Hv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "GetPublicAccessBlock", {}).n("S3Client", "GetPublicAccessBlockCommand").sc(eje).build() { } }); var Gv, Tj = s(() => { pe(); V(); F(); K(); Q(); Gv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "HeadBucket", {}).n("S3Client", "HeadBucketCommand").sc(tje).build() { } }); var jv, wj = s(() => { pe(); Jn(); V(); F(); K(); Q(); jv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), ar(o), Vw(o)] }).s("AmazonS3", "HeadObject", {}).n("S3Client", "HeadObjectCommand").sc(rje).build() { } }); var qv, bj = s(() => { pe(); V(); F(); K(); Q(); qv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListBucketAnalyticsConfigurations", {}).n("S3Client", "ListBucketAnalyticsConfigurationsCommand").sc(oje).build() { } }); var Vv, Ij = s(() => { pe(); V(); F(); K(); Q(); Vv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListBucketIntelligentTieringConfigurations", {}).n("S3Client", "ListBucketIntelligentTieringConfigurationsCommand").sc(nje).build() { } }); var zv, vj = s(() => { pe(); V(); F(); K(); Q(); zv = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListBucketInventoryConfigurations", {}).n("S3Client", "ListBucketInventoryConfigurationsCommand").sc(sje).build() { } }); var Wv, Pj = s(() => { pe(); V(); F(); K(); Q(); Wv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListBucketMetricsConfigurations", {}).n("S3Client", "ListBucketMetricsConfigurationsCommand").sc(ije).build() { } }); var Wd, Kv = s(() => { pe(); V(); F(); K(); Q(); Wd = class extends R.classBuilder().ep(w).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListBuckets", {}).n("S3Client", "ListBucketsCommand").sc(aje).build() { } }); var Kd, Qv = s(() => { pe(); V(); F(); K(); Q(); Kd = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListDirectoryBuckets", {}).n("S3Client", "ListDirectoryBucketsCommand").sc(cje).build() { } }); var Yv, Oj = s(() => { pe(); V(); F(); K(); Q(); Yv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Prefix: { type: "contextParams", name: "Prefix" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListMultipartUploads", {}).n("S3Client", "ListMultipartUploadsCommand").sc(pje).build() { } }); var Xv, Dj = s(() => { pe(); V(); F(); K(); Q(); Xv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Prefix: { type: "contextParams", name: "Prefix" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListObjects", {}).n("S3Client", "ListObjectsCommand").sc(uje).build() { } }); var Qd, Jv = s(() => { pe(); V(); F(); K(); Q(); Qd = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Prefix: { type: "contextParams", name: "Prefix" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListObjectsV2", {}).n("S3Client", "ListObjectsV2Command").sc(mje).build() { } }); var Zv, kj = s(() => { pe(); V(); F(); K(); Q(); Zv = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Prefix: { type: "contextParams", name: "Prefix" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "ListObjectVersions", {}).n("S3Client", "ListObjectVersionsCommand").sc(lje).build() { } }); var Yd, eP = s(() => { pe(); Jn(); V(); F(); K(); Q(); Yd = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), ar(o)] }).s("AmazonS3", "ListParts", {}).n("S3Client", "ListPartsCommand").sc(dje).build() { } }); var tP, Nj = s(() => { lt(); V(); F(); K(); Q(); tP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !1 })] }).s("AmazonS3", "PutBucketAbac", {}).n("S3Client", "PutBucketAbacCommand").sc(fje).build() { } }); var rP, Bj = s(() => { lt(); V(); F(); K(); Q(); rP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !1 })] }).s("AmazonS3", "PutBucketAccelerateConfiguration", {}).n("S3Client", "PutBucketAccelerateConfigurationCommand").sc(hje).build() { } }); var oP, Lj = s(() => { lt(); V(); F(); K(); Q(); oP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketAcl", {}).n("S3Client", "PutBucketAclCommand").sc(gje).build() { } }); var nP, Mj = s(() => { V(); F(); K(); Q(); nP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "PutBucketAnalyticsConfiguration", {}).n("S3Client", "PutBucketAnalyticsConfigurationCommand").sc(xje).build() { } }); var sP, $j = s(() => { lt(); V(); F(); K(); Q(); sP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketCors", {}).n("S3Client", "PutBucketCorsCommand").sc(Eje).build() { } }); var iP, Fj = s(() => { lt(); V(); F(); K(); Q(); iP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketEncryption", {}).n("S3Client", "PutBucketEncryptionCommand").sc(yje).build() { } }); var aP, Uj = s(() => { V(); F(); K(); Q(); aP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "PutBucketIntelligentTieringConfiguration", {}).n("S3Client", "PutBucketIntelligentTieringConfigurationCommand").sc(Sje).build() { } }); var cP, Hj = s(() => { V(); F(); K(); Q(); cP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "PutBucketInventoryConfiguration", {}).n("S3Client", "PutBucketInventoryConfigurationCommand").sc(_je).build() { } }); var pP, Gj = s(() => { lt(); pe(); V(); F(); K(); Q(); pP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 }), M(o)] }).s("AmazonS3", "PutBucketLifecycleConfiguration", {}).n("S3Client", "PutBucketLifecycleConfigurationCommand").sc(Cje).build() { } }); var uP, jj = s(() => { lt(); V(); F(); K(); Q(); uP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketLogging", {}).n("S3Client", "PutBucketLoggingCommand").sc(Rje).build() { } }); var mP, qj = s(() => { V(); F(); K(); Q(); mP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "PutBucketMetricsConfiguration", {}).n("S3Client", "PutBucketMetricsConfigurationCommand").sc(Aje).build() { } }); var lP, Vj = s(() => { V(); F(); K(); Q(); lP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "PutBucketNotificationConfiguration", {}).n("S3Client", "PutBucketNotificationConfigurationCommand").sc(Tje).build() { } }); var dP, zj = s(() => { lt(); V(); F(); K(); Q(); dP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketOwnershipControls", {}).n("S3Client", "PutBucketOwnershipControlsCommand").sc(wje).build() { } }); var fP, Wj = s(() => { lt(); V(); F(); K(); Q(); fP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketPolicy", {}).n("S3Client", "PutBucketPolicyCommand").sc(bje).build() { } }); var hP, Kj = s(() => { lt(); V(); F(); K(); Q(); hP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketReplication", {}).n("S3Client", "PutBucketReplicationCommand").sc(Ije).build() { } }); var gP, Qj = s(() => { lt(); V(); F(); K(); Q(); gP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketRequestPayment", {}).n("S3Client", "PutBucketRequestPaymentCommand").sc(vje).build() { } }); var xP, Yj = s(() => { lt(); V(); F(); K(); Q(); xP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketTagging", {}).n("S3Client", "PutBucketTaggingCommand").sc(Pje).build() { } }); var EP, Xj = s(() => { lt(); V(); F(); K(); Q(); EP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketVersioning", {}).n("S3Client", "PutBucketVersioningCommand").sc(Oje).build() { } }); var yP, Jj = s(() => { lt(); V(); F(); K(); Q(); yP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutBucketWebsite", {}).n("S3Client", "PutBucketWebsiteCommand").sc(Dje).build() { } }); var SP, Zj = s(() => { lt(); pe(); V(); F(); K(); Q(); SP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 }), M(o)] }).s("AmazonS3", "PutObjectAcl", {}).n("S3Client", "PutObjectAclCommand").sc(Nje).build() { } }); var Xd, e4 = s(() => { lt(); pe(); Jn(); V(); F(); K(); Q(); Xd = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !1 }), WBe(o), M(o), ar(o)] }).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").sc(kje).build() { } }); var _P, t4 = s(() => { lt(); pe(); V(); F(); K(); Q(); _P = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 }), M(o)] }).s("AmazonS3", "PutObjectLegalHold", {}).n("S3Client", "PutObjectLegalHoldCommand").sc(Bje).build() { } }); var CP, r4 = s(() => { lt(); pe(); V(); F(); K(); Q(); CP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 }), M(o)] }).s("AmazonS3", "PutObjectLockConfiguration", {}).n("S3Client", "PutObjectLockConfigurationCommand").sc(Lje).build() { } }); var RP, o4 = s(() => { lt(); pe(); V(); F(); K(); Q(); RP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 }), M(o)] }).s("AmazonS3", "PutObjectRetention", {}).n("S3Client", "PutObjectRetentionCommand").sc(Mje).build() { } }); var AP, n4 = s(() => { lt(); pe(); V(); F(); K(); Q(); AP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 }), M(o)] }).s("AmazonS3", "PutObjectTagging", {}).n("S3Client", "PutObjectTaggingCommand").sc($je).build() { } }); var TP, s4 = s(() => { lt(); V(); F(); K(); Q(); TP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "PutPublicAccessBlock", {}).n("S3Client", "PutPublicAccessBlockCommand").sc(Fje).build() { } }); var wP, i4 = s(() => { pe(); V(); F(); K(); Q(); wP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o)] }).s("AmazonS3", "RenameObject", {}).n("S3Client", "RenameObjectCommand").sc(Uje).build() { } }); var bP, a4 = s(() => { lt(); pe(); V(); F(); K(); Q(); bP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !1 }), M(o)] }).s("AmazonS3", "RestoreObject", {}).n("S3Client", "RestoreObjectCommand").sc(Hje).build() { } }); var IP, c4 = s(() => { pe(); Jn(); V(); F(); K(); Q(); IP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), ar(o)] }).s("AmazonS3", "SelectObjectContent", { eventStream: { output: !0 } }).n("S3Client", "SelectObjectContentCommand").sc(Gje).build() { } }); var vP, p4 = s(() => { lt(); V(); F(); K(); Q(); vP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "UpdateBucketMetadataInventoryTableConfiguration", {}).n("S3Client", "UpdateBucketMetadataInventoryTableConfigurationCommand").sc(jje).build() { } }); var PP, u4 = s(() => { lt(); V(); F(); K(); Q(); PP = class extends R.classBuilder().ep({ ...w, UseS3ExpressControlEndpoint: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !0 })] }).s("AmazonS3", "UpdateBucketMetadataJournalTableConfiguration", {}).n("S3Client", "UpdateBucketMetadataJournalTableConfigurationCommand").sc(qje).build() { } }); var OP, m4 = s(() => { lt(); pe(); Jn(); V(); F(); K(); Q(); OP = class extends R.classBuilder().ep({ ...w, Bucket: { type: "contextParams", name: "Bucket" }, Key: { type: "contextParams", name: "Key" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), Ee(o, { requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" }, requestChecksumRequired: !1 }), M(o), ar(o)] }).s("AmazonS3", "UploadPart", {}).n("S3Client", "UploadPartCommand").sc(Vje).build() { } }); var DP, l4 = s(() => { pe(); Jn(); V(); F(); K(); Q(); DP = class extends R.classBuilder().ep({ ...w, DisableS3ExpressSessionAuth: { type: "staticContextParams", value: !0 }, Bucket: { type: "contextParams", name: "Bucket" } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions()), M(o), ar(o)] }).s("AmazonS3", "UploadPartCopy", {}).n("S3Client", "UploadPartCopyCommand").sc(zje).build() { } }); var kP, d4 = s(() => { V(); F(); K(); Q(); kP = class extends R.classBuilder().ep({ ...w, UseObjectLambdaEndpoint: { type: "staticContextParams", value: !0 } }).m(function (t, r, o, n) { return [T(o, t.getEndpointParameterInstructions())] }).s("AmazonS3", "WriteGetObjectResponse", {}).n("S3Client", "WriteGetObjectResponseCommand").sc(Wje).build() { } }); var h2t, f4, HWe = s(() => { F(); _G(); CG(); RG(); AG(); TG(); wG(); bG(); W0(); IG(); vG(); PG(); OG(); DG(); kG(); NG(); BG(); LG(); MG(); $G(); FG(); UG(); HG(); GG(); jG(); qG(); VG(); zG(); WG(); KG(); QG(); YG(); XG(); JG(); ZG(); ej(); tj(); rj(); oj(); nj(); sj(); ij(); aj(); cj(); pj(); uj(); mj(); lj(); dj(); fj(); hj(); gj(); xj(); Ej(); yj(); Sj(); _j(); Cj(); Rj(); Aj(); Tj(); wj(); bj(); Ij(); vj(); Pj(); Kv(); Qv(); Oj(); Dj(); Jv(); kj(); eP(); Nj(); Bj(); Lj(); Mj(); $j(); Fj(); Uj(); Hj(); Gj(); jj(); qj(); Vj(); zj(); Wj(); Kj(); Qj(); Yj(); Xj(); Jj(); Zj(); e4(); t4(); r4(); o4(); n4(); s4(); i4(); a4(); c4(); p4(); u4(); m4(); l4(); d4(); bp(); h2t = { AbortMultipartUploadCommand: UI, CompleteMultipartUploadCommand: HI, CopyObjectCommand: GI, CreateBucketCommand: jI, CreateBucketMetadataConfigurationCommand: qI, CreateBucketMetadataTableConfigurationCommand: VI, CreateMultipartUploadCommand: zI, CreateSessionCommand: Id, DeleteBucketCommand: KI, DeleteBucketAnalyticsConfigurationCommand: WI, DeleteBucketCorsCommand: QI, DeleteBucketEncryptionCommand: YI, DeleteBucketIntelligentTieringConfigurationCommand: XI, DeleteBucketInventoryConfigurationCommand: JI, DeleteBucketLifecycleCommand: ZI, DeleteBucketMetadataConfigurationCommand: ev, DeleteBucketMetadataTableConfigurationCommand: tv, DeleteBucketMetricsConfigurationCommand: rv, DeleteBucketOwnershipControlsCommand: ov, DeleteBucketPolicyCommand: nv, DeleteBucketReplicationCommand: sv, DeleteBucketTaggingCommand: iv, DeleteBucketWebsiteCommand: av, DeleteObjectCommand: Vd, DeleteObjectsCommand: cv, DeleteObjectTaggingCommand: pv, DeletePublicAccessBlockCommand: uv, GetBucketAbacCommand: mv, GetBucketAccelerateConfigurationCommand: lv, GetBucketAclCommand: dv, GetBucketAnalyticsConfigurationCommand: fv, GetBucketCorsCommand: hv, GetBucketEncryptionCommand: gv, GetBucketIntelligentTieringConfigurationCommand: xv, GetBucketInventoryConfigurationCommand: Ev, GetBucketLifecycleConfigurationCommand: yv, GetBucketLocationCommand: Sv, GetBucketLoggingCommand: _v, GetBucketMetadataConfigurationCommand: Cv, GetBucketMetadataTableConfigurationCommand: Rv, GetBucketMetricsConfigurationCommand: Av, GetBucketNotificationConfigurationCommand: Tv, GetBucketOwnershipControlsCommand: wv, GetBucketPolicyCommand: bv, GetBucketPolicyStatusCommand: Iv, GetBucketReplicationCommand: vv, GetBucketRequestPaymentCommand: Pv, GetBucketTaggingCommand: Ov, GetBucketVersioningCommand: Dv, GetBucketWebsiteCommand: kv, GetObjectCommand: zd, GetObjectAclCommand: Nv, GetObjectAttributesCommand: Bv, GetObjectLegalHoldCommand: Lv, GetObjectLockConfigurationCommand: Mv, GetObjectRetentionCommand: $v, GetObjectTaggingCommand: Fv, GetObjectTorrentCommand: Uv, GetPublicAccessBlockCommand: Hv, HeadBucketCommand: Gv, HeadObjectCommand: jv, ListBucketAnalyticsConfigurationsCommand: qv, ListBucketIntelligentTieringConfigurationsCommand: Vv, ListBucketInventoryConfigurationsCommand: zv, ListBucketMetricsConfigurationsCommand: Wv, ListBucketsCommand: Wd, ListDirectoryBucketsCommand: Kd, ListMultipartUploadsCommand: Yv, ListObjectsCommand: Xv, ListObjectsV2Command: Qd, ListObjectVersionsCommand: Zv, ListPartsCommand: Yd, PutBucketAbacCommand: tP, PutBucketAccelerateConfigurationCommand: rP, PutBucketAclCommand: oP, PutBucketAnalyticsConfigurationCommand: nP, PutBucketCorsCommand: sP, PutBucketEncryptionCommand: iP, PutBucketIntelligentTieringConfigurationCommand: aP, PutBucketInventoryConfigurationCommand: cP, PutBucketLifecycleConfigurationCommand: pP, PutBucketLoggingCommand: uP, PutBucketMetricsConfigurationCommand: mP, PutBucketNotificationConfigurationCommand: lP, PutBucketOwnershipControlsCommand: dP, PutBucketPolicyCommand: fP, PutBucketReplicationCommand: hP, PutBucketRequestPaymentCommand: gP, PutBucketTaggingCommand: xP, PutBucketVersioningCommand: EP, PutBucketWebsiteCommand: yP, PutObjectCommand: Xd, PutObjectAclCommand: SP, PutObjectLegalHoldCommand: _P, PutObjectLockConfigurationCommand: CP, PutObjectRetentionCommand: RP, PutObjectTaggingCommand: AP, PutPublicAccessBlockCommand: TP, RenameObjectCommand: wP, RestoreObjectCommand: bP, SelectObjectContentCommand: IP, UpdateBucketMetadataInventoryTableConfigurationCommand: vP, UpdateBucketMetadataJournalTableConfigurationCommand: PP, UploadPartCommand: OP, UploadPartCopyCommand: DP, WriteGetObjectResponseCommand: kP }, f4 = class extends Wo { }; Ob(h2t, f4) }); var GWe = s(() => { _G(); CG(); RG(); AG(); TG(); wG(); bG(); W0(); IG(); vG(); PG(); OG(); DG(); kG(); NG(); BG(); LG(); MG(); $G(); FG(); UG(); HG(); GG(); jG(); VG(); qG(); zG(); WG(); KG(); QG(); YG(); XG(); JG(); ZG(); ej(); tj(); rj(); oj(); nj(); sj(); ij(); aj(); cj(); pj(); uj(); mj(); lj(); dj(); fj(); hj(); gj(); xj(); Ej(); yj(); Sj(); _j(); Cj(); Rj(); Aj(); Tj(); wj(); bj(); Ij(); vj(); Pj(); Kv(); Qv(); Oj(); kj(); Dj(); Jv(); eP(); Nj(); Bj(); Lj(); Mj(); $j(); Fj(); Uj(); Hj(); Gj(); jj(); qj(); Vj(); zj(); Wj(); Kj(); Qj(); Yj(); Xj(); Jj(); Zj(); e4(); t4(); r4(); o4(); n4(); s4(); i4(); a4(); c4(); p4(); u4(); m4(); l4(); d4() }); var jWe = s(() => { }); var czo, qWe = s(() => { Ie(); Kv(); bp(); czo = qe(Wo, Wd, "ContinuationToken", "ContinuationToken", "MaxBuckets") }); var dzo, VWe = s(() => { Ie(); Qv(); bp(); dzo = qe(Wo, Kd, "ContinuationToken", "ContinuationToken", "MaxDirectoryBuckets") }); var Ezo, zWe = s(() => { Ie(); Jv(); bp(); Ezo = qe(Wo, Qd, "ContinuationToken", "NextContinuationToken", "MaxKeys") }); var Rzo, WWe = s(() => { Ie(); eP(); bp(); Rzo = qe(Wo, Yd, "PartNumberMarker", "NextPartNumberMarker", "MaxParts") }); var KWe = s(() => { jWe(); qWe(); VWe(); zWe(); WWe() }); var QWe = s(() => { }); var YWe = s(() => { }); var XWe = s(() => { }); var JWe = s(() => { }); var ZWe = s(() => { QWe(); YWe(); XWe(); JWe() }); var e6e = s(() => { }); var t6e = s(() => { }); var r6e = s(() => { }); var o6e = s(() => { bp(); HWe(); GWe(); Q(); KWe(); ZWe(); e6e(); oH(); t6e(); r6e() }); var n6e = {}; Qe(n6e, { default: () => C2t }); import g2t from "node:path"; function S2t() { return { region: x2t, logger: vp, maxAttempts: Lx(process.env.AWS_SDK_S3_MAX_ATTEMPTS) } } function x4(e, t) { return g2t.posix.join(E2t ?? "", t === "fetch" ? "__fetch" : "", y2t ?? "", t === "fetch" ? e : `${e}.${t}`) } var x2t, E2t, y2t, h4, g4, _2t, C2t, s6e = s(() => { o6e(); vr(); Zd(); ({ CACHE_BUCKET_REGION: x2t, CACHE_BUCKET_KEY_PREFIX: E2t, NEXT_BUILD_ID: y2t, CACHE_BUCKET_NAME: h4 } = process.env); g4 = new Wo(S2t()); _2t = { async get(e, t) { let r = await g4.send(new zd({ Bucket: h4, Key: x4(e, t ?? "cache") })); return { value: JSON.parse(await r.Body?.transformToString() ?? "{}"), lastModified: r.LastModified?.getTime() } }, async set(e, t, r) { await g4.send(new Xd({ Bucket: h4, Key: x4(e, r ?? "cache"), Body: JSON.stringify(t) })) }, async delete(e) { await g4.send(new Vd({ Bucket: h4, Key: x4(e, "cache") })) }, name: "s3" }, C2t = _2t }); var i6e = {}; Qe(i6e, { default: () => A2t }); var R2t, A2t, a6e = s(() => { R2t = { name: "dummy" }, A2t = R2t }); var p6e = {}; Qe(p6e, { default: () => I2t }); import { request as T2t } from "node:https"; import { Readable as w2t } from "node:stream"; function c6e(e) { let t = {}, r = ["host", "connection", "via", "x-cache", "transfer-encoding", "content-encoding", "content-length"]; return Object.entries(e).filter(([o, n]) => { let i = o.toLowerCase(); return !(r.includes(i) || i.startsWith("x-amz")) }).forEach(([o, n]) => { t[o] = n?.toString() ?? "" }), t } var b2t, I2t, u6e = s(() => { vr(); Gx(); b2t = { name: "node-proxy", proxy: e => { let { url: t, headers: r, method: o, body: n } = e; return be("proxyRequest", t), new Promise((i, a) => { let c = c6e(r); be("filteredHeaders", c); let p = T2t(t, { headers: c, method: o, rejectUnauthorized: !1 }, u => { let l = u.headers, m = l["content-encoding"] === "br" ? u.pipe(ai("node:zlib").createBrotliDecompress()) : l["content-encoding"] === "gzip" ? u.pipe(ai("node:zlib").createGunzip()) : u, f = Pp(l["content-type"]) || !!l["content-encoding"], h = { type: "core", headers: c6e(l), statusCode: u.statusCode ?? 200, isBase64Encoded: f, body: w2t.toWeb(m) }; i(h), u.on("error", E => { Qt("proxyRequest error", E), a(E) }) }); n && o !== "GET" && o !== "HEAD" && p.write(n), p.end() }) } }, I2t = b2t }); var m6e = {}; Qe(m6e, { default: () => v2t }); var v2t, l6e = s(() => { v2t = { name: "dummy", invalidatePaths: e => Promise.resolve() } }); vr(); Zd(); import { AsyncLocalStorage as k8e } from "node:async_hooks"; vr(); ef(); import { Transform as k6e } from "node:stream"; var uc = "set-cookie", mc = "This cannot be used in OpenNext", Ux = class extends k6e { fixHeadersFn; onEnd; streamCreator; initialHeaders; statusCode; statusMessage = ""; headers = {}; headersSent = !1; _chunks = []; headersAlreadyFixed = !1; _cookies = []; responseStream; bodyLength = 0; strictContentLength = !1; assignSocket(t) { throw new Error(mc) } detachSocket(t) { throw new Error(mc) } writeContinue(t) { throw new Error(mc) } writeEarlyHints(t, r) { throw new Error(mc) } writeProcessing() { throw new Error(mc) } req; chunkedEncoding = !1; shouldKeepAlive = !0; useChunkedEncodingByDefault = !0; sendDate = !1; connection = null; socket = null; setTimeout(t, r) { throw new Error(mc) } addTrailers(t) { throw new Error(mc) } constructor(t, r, o, n, i) { super(), this.fixHeadersFn = t, this.onEnd = r, this.streamCreator = o, this.initialHeaders = n, i && Number.isInteger(i) && i >= 100 && i <= 599 && (this.statusCode = i), o?.abortSignal?.addEventListener("abort", () => { this.destroy() }) } get originalResponse() { return this } get finished() { return this.responseStream ? this.responseStream?.writableFinished : this.writableFinished } setHeader(t, r) { let o = t.toLowerCase(); return o === uc && (Array.isArray(r) ? this._cookies = r : this._cookies = [r]), this.headers[o] = r, this } removeHeader(t) { let r = t.toLowerCase(); return r === uc ? this._cookies = [] : delete this.headers[r], this } hasHeader(t) { let r = t.toLowerCase(); return r === uc ? this._cookies.length > 0 : this.headers[r] !== void 0 } getHeaders() { return this.headers } getHeader(t) { return this.headers[t.toLowerCase()] } getHeaderNames() { return Object.keys(this.headers) } flushHeaders() { this.headersSent = !0; let t = globalThis.__openNextAls?.getStore()?.mergeHeadersPriority ?? "middleware"; if (this.initialHeaders) { this.headers = t === "middleware" ? { ...this.headers, ...this.initialHeaders } : { ...this.initialHeaders, ...this.headers }; let o = $x(this.initialHeaders[uc]?.toString()); this._cookies = t === "middleware" ? [...this._cookies, ...o] : [...o, ...this._cookies] } this.fixHeaders(this.headers), this.fixHeadersForError(), this.headers[uc] = this._cookies; let r = Mx(this.headers); delete r[uc], this.streamCreator && (this.responseStream = this.streamCreator?.writeHeaders({ statusCode: this.statusCode ?? 200, cookies: this._cookies, headers: r }), this.pipe(this.responseStream)) } appendHeader(t, r) { let o = t.toLowerCase(); if (!this.hasHeader(o)) return this.setHeader(o, r); let n = this.getHeader(o), i = Array.isArray(r) ? r : [r], a = Array.isArray(n) ? [...n, ...i] : [n, ...i]; return this.setHeader(o, a) } writeHead(t, r, o) { let n = o, i; typeof r == "string" ? i = r : n = r; let a = this.headers; if (n) if (Array.isArray(n)) for (let c = 0; c < n.length; c += 2)a[n[c]] = n[c + 1]; else for (let c of Object.keys(n)) a[c] = n[c]; return this.statusCode = t, o && (this.headers = a), this.flushHeaders(), this } fixHeaders(t) { this.headersAlreadyFixed || (this.fixHeadersFn(t), this.headersAlreadyFixed = !0) } getFixedHeaders() { return this.fixHeaders(this.headers), this.fixHeadersForError(), this.headers[uc] = this._cookies, this.headers } getBody() { return Buffer.concat(this._chunks) } _internalWrite(t, r) { let o = r === "buffer" ? t : Buffer.from(t, r); this.bodyLength += o.length, this.streamCreator?.retainChunks !== !1 && this._chunks.push(o), this.push(o), this.streamCreator?.onWrite?.() } _transform(t, r, o) { this.headersSent || this.flushHeaders(), this._internalWrite(t, r), o() } _flush(t) { this.headersSent || this.flushHeaders(), globalThis.__openNextAls?.getStore()?.pendingPromiseRunner.add(this.onEnd(this.headers)), this.streamCreator?.onFinish?.(this.bodyLength), this.bodyLength === 0 && process.env.OPEN_NEXT_FORCE_NON_EMPTY_RESPONSE === "true" && (be('Force writing "SOMETHING" to the response body'), this.push("SOMETHING")), t() } setHeaders(t) { return t.forEach((r, o) => { this.setHeader(o, Array.isArray(r) ? r : r.toString()) }), this } get sent() { return this.finished || this.headersSent } getHeaderValues(t) { let r = this.getHeader(t); if (r !== void 0) return (Array.isArray(r) ? r : [r]).map(o => o.toString()) } send() { for (let t of this._chunks) this.write(t); this.end() } body(t) { return this.write(t), this } onClose(t) { this.on("close", t) } redirect(t, r) { return this.setHeader("Location", t), this.statusCode = r, r === 308 && this.setHeader("Refresh", `0;url=${t}`), this } fixHeadersForError() { process.env.OPEN_NEXT_DANGEROUSLY_SET_ERROR_HEADERS !== "true" && (this.statusCode === 404 || this.statusCode === 500) && (this.headers["cache-control"] = "private, no-cache, no-store, max-age=0, must-revalidate") } }; import N6e from "node:http"; var tf = class extends N6e.IncomingMessage { constructor({ method: t, url: r, headers: o, body: n, remoteAddress: i }) { super({ encrypted: !0, readable: !1, remoteAddress: i, address: () => ({ port: 443 }), end: Function.prototype, destroy: Function.prototype }), n && (o["content-length"] ??= String(Buffer.byteLength(n))), Object.assign(this, { ip: i, complete: !0, httpVersion: "1.1", httpVersionMajor: "1", httpVersionMinor: "1", method: t, headers: o, body: n, url: r }), this._read = () => { this.push(n), this.push(null) } } }; vr(); var Hx = class { resolve; reject; promise; constructor() { let t, r; this.promise = new Promise((o, n) => { t = o, r = n }), this.resolve = t, this.reject = r } }, LP = class { promises = []; withResolvers() { let t = new Hx; return this.promises.push(t), t } add(t) { let r = new Hx; this.promises.push(r), t.then(r.resolve, r.reject) } async await() { be(`Awaiting ${this.promises.length} detached promises`), (await Promise.allSettled(this.promises.map(o => o.promise))).filter(o => o.status === "rejected").forEach(o => { Qt(o.reason) }) } }; async function B6e() { let e = globalThis.__openNextAls.getStore(), t = e?.pendingPromiseRunner.await() ?? Promise.resolve(); if (e?.waitUntil) { e.waitUntil(t); return } await t } function L6e() { let e = Symbol.for("@next/request-context"), t = Symbol.for("@vercel/request-context"), r = globalThis.__openNextAls.getStore(), o = r?.waitUntil ?? (i => r?.pendingPromiseRunner.add(i)), n = { get: () => ({ waitUntil: o }) }; globalThis[e] = n, process.env.EMULATE_VERCEL_REQUEST_CONTEXT && (globalThis[t] = n) } function C4({ isISRRevalidation: e, waitUntil: t, requestId: r = Math.random().toString(36) }, o) { return globalThis.__openNextAls.run({ requestId: r, pendingPromiseRunner: new LP, isISRRevalidation: e, waitUntil: t, writtenTags: new Set }, async () => { L6e(); let n; try { n = await o() } finally { await B6e() } return n }) } vr(); import D4 from "node:path"; import Zn from "node:fs"; import ci from "node:path"; function R4(e) { return requiredServerFiles.config; } function A4(e) { return buildId; } function MP(e) { return pagesManifest; } function T4(e) { return Object.entries(MP(e)).filter(([t, r]) => r.endsWith(".html")).map(([t]) => t) } function w4(e) { const o = routesManifest; const n = o.dataRoutes ?? []; const i = { static: n.filter(a => a.routeKeys === void 0), dynamic: n.filter(a => a.routeKeys !== void 0) }; return { basePath: o.basePath, rewrites: Array.isArray(o.rewrites) ? { beforeFiles: [], afterFiles: o.rewrites, fallback: [] } : { beforeFiles: o.rewrites.beforeFiles ?? [], afterFiles: o.rewrites.afterFiles ?? [], fallback: o.rewrites.fallback ?? [] }, redirects: o.redirects ?? [], routes: { static: o.staticRoutes ?? [], dynamic: o.dynamicRoutes ?? [], data: i }, locales: o.i18n?.locales ?? [] }; } function b4(e) { return routesManifest.headers; } function I4(e) { return prerenderManifest; } function v4(e) { return appPathRoutesManifest; } function P4(e) { return middlewareManifest; } function O4(e) { return functionsConfigManifest; } var es = D4.join(__dirname, ".next"), M6e = D4.join(__dirname, ".open-next"); be({ NEXT_DIR: es, OPEN_NEXT_DIR: M6e }); var Ue = R4(es), rf = A4(es), k4 = T4(es), Ko = w4(es), N4 = b4(es), ys = I4(es), B4 = MP(es); var L4 = P4(es); var $P = v4(es), M4 = O4(es); process.env.NEXT_BUILD_ID = rf; process.env.NEXT_PREVIEW_MODE_ID = ys?.preview?.previewModeId; vr(); var $6e = ai("node:module"), nGt = $6e._resolveFilename; import V6e from "node:crypto"; import { parse as z6e, stringify as W6e } from "node:querystring"; ef(); vr(); Gx(); import { ReadableStream as U4 } from "node:stream/web"; import { ReadableStream as FP } from "node:stream/web"; function of(e, t) { return new FP({ pull(r) { r.enqueue(Buffer.from(e, t ? "base64" : "utf8")), r.close() } }, { highWaterMark: 0 }) } var $4; function ts() { return process.env.OPEN_NEXT_FORCE_NON_EMPTY_RESPONSE === "true" ? new FP({ pull(e) { $4 ??= Buffer.from("SOMETHING"), e.enqueue($4), e.close() } }, { highWaterMark: 0 }) : new FP({ start(e) { e.close() } }) } vr(); function U6e(e, t, r) { let o = new Map, n = e.replace(/[ \t]/g, ""); if (t) { let l = 0; for (let m of t) { let f = m.toLowerCase(); if (o.set(f, { orig: m, pos: l++ }), r.prefixMatch) { let h = f.split("-"); for (; h.pop(), h.length > 0;) { let E = h.join("-"); o.has(E) || o.set(E, { orig: m, pos: l++ }) } } } } let i = n.split(","), a = [], c = new Set; for (let l = 0; l < i.length; ++l) { let m = i[l]; if (!m) continue; let f = m.split(";"); if (f.length > 2) throw new Error(`Invalid ${r.type} header`); let h = f[0].toLowerCase(); if (!h) throw new Error(`Invalid ${r.type} header`); let E = { token: h, pos: l, q: 1 }; if (t && o.has(h) && (E.pref = o.get(h).pos), c.add(E.token), f.length === 2) { let S = f[1], [y, C] = S.split("="); if (!C || y !== "q" && y !== "Q") throw new Error(`Invalid ${r.type} header`); let b = Number.parseFloat(C); if (b === 0) continue; Number.isFinite(b) && b <= 1 && b >= .001 && (E.q = b) } a.push(E) } a.sort((l, m) => m.q !== l.q ? m.q - l.q : m.pref !== l.pref ? l.pref === void 0 ? 1 : m.pref === void 0 ? -1 : l.pref - m.pref : l.pos - m.pos); let p = a.map(l => l.token); if (!t || !t.length) return p; let u = []; for (let l of p) if (l === "*") for (let [m, f] of o) c.has(m) || u.push(f.orig); else { let m = l.toLowerCase(); o.has(m) && u.push(o.get(m).orig) } return u } function UP(e = "", t) { return U6e(e, t, { type: "accept-language", prefixMatch: !0 })[0] || void 0 } function H6e(e) { return Ue.i18n?.locales.includes(e.split("/")[1].toLowerCase()) ?? !1 } function G6e(e) { let t = Ue.i18n, r = e.NEXT_LOCALE?.toLowerCase(); return r ? t?.locales.find(o => r === o.toLowerCase()) : void 0 } function HP({ hostname: e, detectedLocale: t }) { let o = Ue.i18n?.domains; if (!o) return; let n = t?.toLowerCase(); for (let i of o) { let a = i.domain.split(":", 1)[0].toLowerCase(); if (e === a || n === i.defaultLocale.toLowerCase() || i.locales?.some(c => n === c.toLowerCase())) return i } } function nf(e, t) { let r = HP({ hostname: e.headers.host }); if (t.localeDetection === !1) return r?.defaultLocale ?? t.defaultLocale; let o = G6e(e.cookies), n = UP(e.headers["accept-language"], t?.locales); return be({ cookiesLocale: o, preferredLocale: n, defaultLocale: t.defaultLocale, domainLocale: r }), r?.defaultLocale ?? o ?? n ?? t.defaultLocale } function pi(e) { let t = Ue.i18n; return !t || H6e(e.rawPath) ? e.rawPath : `/${nf(e, t)}${e.rawPath}` } function F4(e) { let t = Ue.i18n; if (!t || t.localeDetection === !1 || e.rawPath !== "/") return !1; let r = UP(e.headers["accept-language"], t?.locales), o = nf(e, t), n = HP({ hostname: e.headers.host }), i = HP({ detectedLocale: r }); if (n && i) { let c = i.domain === n.domain, p = i.defaultLocale === r; if (!c || !p) { let u = `http${i.http ? "" : "s"}`, l = p ? "" : r; return { type: "core", statusCode: 307, headers: { Location: `${u}://${i.domain}/${l}` }, body: ts(), isBase64Encoded: !1 } } } let a = n?.defaultLocale ?? t.defaultLocale; return o.toLowerCase() !== a.toLowerCase() ? { type: "core", statusCode: 307, headers: { Location: ui(e.url, `/${o}`) }, body: ts(), isBase64Encoded: !1 } : !1 } function j6e(e, t, r) { let o = q6e(e), n = o += 1831565813; n = Math.imul(n ^ n >>> 15, n | 1), n ^= n + Math.imul(n ^ n >>> 7, n | 61); let i = ((n ^ n >>> 14) >>> 0) / 4294967296, a = Math.floor(i * t); return `${r}-${a}` } function jx(e) { let t = Number.parseInt(process.env.MAX_REVALIDATE_CONCURRENCY ?? "10"); return j6e(e, t, "revalidate") } function q6e(e) { let t = 1779033703, r = 3144134277, o = 1013904242, n = 2773480762; for (let i = 0, a; i < e.length; i++)a = e.charCodeAt(i), t = r ^ Math.imul(t ^ a, 597399067), r = o ^ Math.imul(r ^ a, 2869860233), o = n ^ Math.imul(o ^ a, 951274213), n = t ^ Math.imul(n ^ a, 2716044179); return t = Math.imul(o ^ t >>> 18, 597399067), r = Math.imul(n ^ r >>> 22, 2869860233), o = Math.imul(t ^ o >>> 17, 951274213), n = Math.imul(r ^ n >>> 19, 2716044179), t ^= r ^ o ^ n, r ^= t, o ^= t, n ^= t, t >>> 0 } function qx(e, t) { if (!e || !/^https?:\/\//.test(e)) return !1; if (t) try { return new URL(e).host !== t } catch { return !e.includes(t) } return !0 } function H4(e) { if (e === "") return {}; let t = e.split("&"); return Fx(t.map(r => { let [o, n] = r.split("="); return [o, n] })) } function G4(e, t) { if (!t) { let n = /\/([^?]*)\??(.*)/, i = e.match(n); return { hostname: "", pathname: i?.[1] ? `/${i[1]}` : e, protocol: "", queryString: i?.[2] ?? "" } } let r = /^(https?:)\/\/?([^\/\s]+)(\/[^?]*)?(\?.*)?/, o = e.match(r); if (!o) throw new Error(`Invalid external URL: ${e}`); return { protocol: o[1] ?? "https:", hostname: o[2], pathname: o[3] ?? "", queryString: o[4]?.slice(1) ?? "" } } function ui(e, t) { let r = Ue.basePath ?? ""; return new URL(`${r}${t}`, e).href } function j4(e) { let t = e.statusCode || 200, r = Mx(e.getFixedHeaders()), o = Pp(r["content-type"]) || !!r["content-encoding"], n = new U4({ pull(i) { if (!e._chunks || e._chunks.length === 0) { i.close(); return } i.enqueue(e._chunks.shift()) } }); return { type: "core", statusCode: t, headers: r, body: n, isBase64Encoded: o } } function sf(e) { let t = []; return Object.entries(e).forEach(([r, o]) => { Array.isArray(o) ? o.forEach(n => t.push(`${r}=${n}`)) : t.push(`${r}=${o}`) }), t.length > 0 ? `?${t.join("&")}` : "" } function q4(e) { if (!e) return {}; let t = new URLSearchParams(e), r = {}; for (let o of t.keys()) { let n = t.getAll(o); r[o] = n.length > 1 ? n : n[0] } return r } function V4(e, t) { if (t?.functions?.["/_middleware"]) return t.functions["/_middleware"].matchers?.map(({ regexp: o }) => new RegExp(o)) ?? [/.*/]; let r = e.middleware["/"]; return r?.matchers ? r.matchers.map(({ regexp: o }) => new RegExp(o)) : [] } function af(e, { isPath: t } = {}) { let r = e.replaceAll("(.)", "_\xB51_").replaceAll("(..)", "_\xB52_").replaceAll("(...)", "_\xB53_"); return t ? r : r.replaceAll("+", "_\xB54_") } function Vx(e) { return e.replaceAll("_\xB51_", "(.)").replaceAll("_\xB52_", "(..)").replaceAll("_\xB53_", "(...)").replaceAll("_\xB54_", "+") } function z4(e, t) { if (!(e === "GET" || e === "HEAD") && t) return new U4({ start(r) { r.enqueue(t), r.close() } }) } var ao; (function (e) { e.CACHE_CONTROL = "cache-control", e.NEXT_CACHE = "x-nextjs-cache" })(ao || (ao = {})); function K6e(e, t) { if (e.rawPath === "/404" || e.rawPath === "/500") { if (process.env.OPEN_NEXT_DANGEROUSLY_SET_ERROR_HEADERS === "true") return; t[ao.CACHE_CONTROL] = "private, no-cache, no-store, max-age=0, must-revalidate"; return } let r = pi(e); k4.includes(r) && !e.headers["x-middleware-prefetch"] && (t[ao.CACHE_CONTROL] = "public, max-age=0, s-maxage=31536000, must-revalidate") } function Q6e(e) { let t = e[ao.CACHE_CONTROL]; t && (Array.isArray(t) && (t = t.join(",")), typeof t == "string" && (e[ao.CACHE_CONTROL] = t.replace(/\bstale-while-revalidate(?!=)/, "stale-while-revalidate=2592000"))) } function Y6e(e) { Ue.poweredByHeader && (e["X-OpenNext"] = "1"), globalThis.openNextDebug && (e["X-OpenNext-Version"] = globalThis.openNextVersion), (process.env.OPEN_NEXT_REQUEST_ID_HEADER || globalThis.openNextDebug) && (e["X-OpenNext-RequestId"] = globalThis.__openNextAls.getStore()?.requestId) } async function X6e(e, t, r, o) { if (r[ao.NEXT_CACHE] === "STALE") { let n = o?.[Symbol.for("NextInternalRequestMeta")], i = n?._nextDidRewrite ? t.startsWith("/_next/data/") ? `/_next/data/${rf}${n?._nextRewroteUrl}.json` : n?._nextRewroteUrl : t; try { let a = u => V6e.createHash("md5").update(u).digest("hex"), c = globalThis.__openNextAls.getStore()?.lastModified ?? 0, p = `${r.etag ?? r.ETag ?? ""}`; await globalThis.queue.send({ MessageBody: { host: e, url: i, eTag: p, lastModified: c }, MessageDeduplicationId: a(`${t}-${c}-${p}`), MessageGroupId: jx(t) }) } catch (a) { Qt(`Failed to revalidate stale page ${t}`, a) } } } function J6e(e) { let t = /s-maxage=(\d+)/, r = e[ao.CACHE_CONTROL]?.match(t), o = r ? Number.parseInt(r[1]) : void 0; if (!o) return; if (e[ao.NEXT_CACHE] === "REVALIDATED") { e[ao.CACHE_CONTROL] = "private, no-cache, no-store, max-age=0, must-revalidate"; return } let n = globalThis.__openNextAls.getStore()?.lastModified ?? 0; if (e[ao.NEXT_CACHE] === "HIT" && n > 0 && (be("cache-control", e[ao.CACHE_CONTROL], n, Date.now()), o && o !== 31536e3)) { let i = Math.round((Date.now() - n) / 1e3), a = Math.max(o - i, 1); e[ao.CACHE_CONTROL] = `s-maxage=${a}, stale-while-revalidate=2592000` } e[ao.NEXT_CACHE] === "STALE" && (e[ao.CACHE_CONTROL] = "s-maxage=2, stale-while-revalidate=2592000") } function GP(e, t, r) { let o = e.internalEvent; return new Ux(n => { K6e(o, n), Q6e(n), Y6e(n), J6e(n) }, async n => { await X6e(o.headers.host, o.rawPath, n), await Z6e(e, n) }, r, t, e.rewriteStatusCode) } async function Z6e(e, t) { let { internalEvent: r, resolvedRoutes: o, initialURL: n } = e, i = new URL(n).pathname; !(r.headers["x-isr"] === "1") && t[ao.NEXT_CACHE] === "REVALIDATED" && await globalThis.cdnInvalidationHandler.invalidatePaths([{ initialPath: i, rawPath: r.rawPath, resolvedRoutes: o }]) } function zx(e, t, r = !1) { if (!URL.canParse(e)) return e; let o = new URL(e), n = new URL(t).origin, i = o.search; r && i && (i = `?${W6e(z6e(i.slice(1)))}`); let a = `${o.origin}${o.pathname}${i}${o.hash}`; return o.origin === n ? a.slice(n.length) : a } vr(); import { createHash as e8e } from "node:crypto"; Gx(); vr(); async function W4(e, t, r) { if (globalThis.openNextConfig.dangerous?.disableTagCache) return !1; if (!r.value) return !0; if ("type" in r && r.type === "page") return !1; let n = r.lastModified ?? Date.now(); return globalThis.tagCache.mode === "nextMode" ? t.length === 0 ? !1 : await globalThis.tagCache.hasBeenRevalidated(t, n) : await globalThis.tagCache.getLastModified(e, n) === -1 } function K4(e) { if (!e) return []; try { let t = e.meta?.headers?.["x-next-cache-tags"]?.split(",") ?? []; return delete e.meta?.headers?.["x-next-cache-tags"], t } catch { return [] } } vr(); var cf = 60 * 60 * 24 * 365, Q4 = 60 * 60 * 24 * 30, Y4 = "RSC, Next-Router-State-Tree, Next-Router-Prefetch, Next-Router-Segment-Prefetch, Next-Url", t8e = "next-router-segment-prefetch", r8e = "x-nextjs-prerender", o8e = "x-nextjs-postponed"; async function jP(e, t, r, o, n) { let i = cf, a = Object.entries(ys?.routes ?? {}).find(l => l[0] === e)?.[1]; o === void 0 && a ? i = a.initialRevalidateSeconds === !1 ? cf : a.initialRevalidateSeconds : o !== void 0 && (i = o === !1 ? cf : o); let c = Math.round((Date.now() - (n ?? 0)) / 1e3), p = l => e8e("md5").update(l).digest("hex"), u = p(t); if (o === 0) return { "cache-control": "private, no-cache, no-store, max-age=0, must-revalidate", "x-opennext-cache": "ERROR", etag: u }; if (i !== cf) { let l = Math.max(i - c, 1); be("sMaxAge", { finalRevalidate: i, age: c, lastModified: n, revalidate: o }); let m = l === 1; if (m) { let f = Ue.trailingSlash ? `${e}/` : e; Ue.basePath && (f = `${Ue.basePath}${f}`), await globalThis.queue.send({ MessageBody: { host: r, url: f, eTag: u, lastModified: n ?? Date.now() }, MessageDeduplicationId: p(`${e}-${n}-${u}`), MessageGroupId: jx(e) }) } return { "cache-control": `s-maxage=${l}, stale-while-revalidate=${Q4}`, "x-opennext-cache": m ? "STALE" : "HIT", etag: u } } return { "cache-control": `s-maxage=${cf}, stale-while-revalidate=${Q4}`, "x-opennext-cache": "HIT", etag: u } } function n8e(e, t) { if (t.type !== "app") throw new Error("getBodyForAppRouter called with non-app cache value"); try { let r = `${e.headers[t8e]}`, o = !!r && r in (t.segmentData || {}); return { body: o ? t.segmentData[r] : t.rsc, additionalHeaders: o ? { [r8e]: "1", [o8e]: "2" } : {} } } catch (r) { return Qt("Error while getting body for app router from cache:", r), { body: t.rsc, additionalHeaders: {} } } } async function s8e(e, t, r, o) { be("Returning result from experimental cache"); let n = "", i = "application/octet-stream", a = !1, c = {}; if (r.type === "app") { if (a = !!e.headers.rsc, a) { let { body: u, additionalHeaders: l } = n8e(e, r); n = u, c = l } else n = r.html; i = a ? "text/x-component" : "text/html; charset=utf-8" } else if (r.type === "page") a = !!e.query.__nextDataReq, n = a ? JSON.stringify(r.json) : r.html, i = a ? "application/json" : "text/html; charset=utf-8"; else throw new Error("generateResult called with unsupported cache value type, only 'app' and 'page' are supported"); let p = await jP(t, n, e.headers.host, r.revalidate, o); return { type: "core", statusCode: e.rewriteStatusCode ?? r.meta?.status ?? 200, body: of(n, !1), isBase64Encoded: !1, headers: { ...p, "content-type": i, ...r.meta?.headers, vary: Y4, ...c } } } function i8e(e, t) { return e.replace(new RegExp(`([/#?]${t ? "|%(2f|23|3f|5c)" : ""})`, "gi"), r => encodeURIComponent(r)) } function a8e(e) { return e.split("/").map(t => { try { return i8e(decodeURIComponent(t), !0) } catch { return t } }).join("/") } async function X4(e) { if (e.headers["next-action"] || e.headers["x-prerender-revalidate"]) return e; let t = e.headers.cookie || ""; if (t.includes("__prerender_bypass") || t.includes("__next_preview_data")) return be("Preview mode detected, passing through to handler"), e; let o = pi(e); Ue.basePath && (o = o.replace(Ue.basePath, "")), o = o.replace(/\/$/, ""), o = a8e(o), be("Checking cache for", o, ys); let n = Object.keys(ys?.routes ?? {}).includes(o ?? "/") || Object.values(ys?.dynamicRoutes ?? {}).some(i => new RegExp(i.routeRegex).test(o)); if (be("isISR", n), n) try { let i = await globalThis.incrementalCache.get(o ?? "/index"); if (be("cached data in interceptor", i), !i?.value) return e; if (i.value?.type === "app" || i.value?.type === "route") { let c = K4(i.value); if (i.shouldBypassTagCache ? !1 : await W4(o, c, i)) return e } let a = e.headers.host; switch (i?.value?.type) { case "app": case "page": return s8e(e, o, i.value, i.lastModified); case "redirect": { let c = await jP(o, "", a, i.value.revalidate, i.lastModified); return { type: "core", statusCode: i.value.meta?.status ?? 307, body: ts(), headers: { ...i.value.meta?.headers ?? {}, ...c }, isBase64Encoded: !1 } } case "route": { let c = await jP(o, i.value.body, a, i.value.revalidate, i.lastModified), p = Pp(String(i.value.meta?.headers?.["content-type"])); return { type: "core", statusCode: e.rewriteStatusCode ?? i.value.meta?.status ?? 200, body: of(i.value.body, p), headers: { ...c, ...i.value.meta?.headers, vary: Y4 }, isBase64Encoded: p } } default: return e } } catch (i) { return be("Error while fetching cache", i), e } return e } function c8e(e) { for (var t = [], r = 0; r < e.length;) { var o = e[r]; if (o === "*" || o === "+" || o === "?") { t.push({ type: "MODIFIER", index: r, value: e[r++] }); continue } if (o === "\\") { t.push({ type: "ESCAPED_CHAR", index: r++, value: e[r++] }); continue } if (o === "{") { t.push({ type: "OPEN", index: r, value: e[r++] }); continue } if (o === "}") { t.push({ type: "CLOSE", index: r, value: e[r++] }); continue } if (o === ":") { for (var n = "", i = r + 1; i < e.length;) { var a = e.charCodeAt(i); if (a >= 48 && a <= 57 || a >= 65 && a <= 90 || a >= 97 && a <= 122 || a === 95) { n += e[i++]; continue } break } if (!n) throw new TypeError("Missing parameter name at ".concat(r)); t.push({ type: "NAME", index: r, value: n }), r = i; continue } if (o === "(") { var c = 1, p = "", i = r + 1; if (e[i] === "?") throw new TypeError('Pattern cannot start with "?" at '.concat(i)); for (; i < e.length;) { if (e[i] === "\\") { p += e[i++] + e[i++]; continue } if (e[i] === ")") { if (c--, c === 0) { i++; break } } else if (e[i] === "(" && (c++, e[i + 1] !== "?")) throw new TypeError("Capturing groups are not allowed at ".concat(i)); p += e[i++] } if (c) throw new TypeError("Unbalanced pattern at ".concat(r)); if (!p) throw new TypeError("Missing pattern at ".concat(r)); t.push({ type: "PATTERN", index: r, value: p }), r = i; continue } t.push({ type: "CHAR", index: r, value: e[r++] }) } return t.push({ type: "END", index: r, value: "" }), t } function J4(e, t) { t === void 0 && (t = {}); for (var r = c8e(e), o = t.prefixes, n = o === void 0 ? "./" : o, i = t.delimiter, a = i === void 0 ? "/#?" : i, c = [], p = 0, u = 0, l = "", m = function (ie) { if (u < r.length && r[u].type === ie) return r[u++].value }, f = function (ie) { var st = m(ie); if (st !== void 0) return st; var Ct = r[u], dt = Ct.type, C6e = Ct.index; throw new TypeError("Unexpected ".concat(dt, " at ").concat(C6e, ", expected ").concat(ie)) }, h = function () { for (var ie = "", st; st = m("CHAR") || m("ESCAPED_CHAR");)ie += st; return ie }, E = function (ie) { for (var st = 0, Ct = a; st < Ct.length; st++) { var dt = Ct[st]; if (ie.indexOf(dt) > -1) return !0 } return !1 }, S = function (ie) { var st = c[c.length - 1], Ct = ie || (st && typeof st == "string" ? st : ""); if (st && !Ct) throw new TypeError('Must have text between two parameters, missing text after "'.concat(st.name, '"')); return !Ct || E(Ct) ? "[^".concat(Yi(a), "]+?") : "(?:(?!".concat(Yi(Ct), ")[^").concat(Yi(a), "])+?") }; u < r.length;) { var y = m("CHAR"), C = m("NAME"), b = m("PATTERN"); if (C || b) { var L = y || ""; n.indexOf(L) === -1 && (l += L, L = ""), l && (c.push(l), l = ""), c.push({ name: C || p++, prefix: L, suffix: "", pattern: b || S(L), modifier: m("MODIFIER") || "" }); continue } var N = y || m("ESCAPED_CHAR"); if (N) { l += N; continue } l && (c.push(l), l = ""); var j = m("OPEN"); if (j) { var L = h(), re = m("NAME") || "", Ce = m("PATTERN") || "", O = h(); f("CLOSE"), c.push({ name: re || (Ce ? p++ : ""), pattern: re && !Ce ? S(L) : Ce, prefix: L, suffix: O, modifier: m("MODIFIER") || "" }); continue } f("END") } return c } function Op(e, t) { return p8e(J4(e, t), t) } function p8e(e, t) { t === void 0 && (t = {}); var r = VP(t), o = t.encode, n = o === void 0 ? function (p) { return p } : o, i = t.validate, a = i === void 0 ? !0 : i, c = e.map(function (p) { if (typeof p == "object") return new RegExp("^(?:".concat(p.pattern, ")$"), r) }); return function (p) { for (var u = "", l = 0; l < e.length; l++) { var m = e[l]; if (typeof m == "string") { u += m; continue } var f = p ? p[m.name] : void 0, h = m.modifier === "?" || m.modifier === "*", E = m.modifier === "*" || m.modifier === "+"; if (Array.isArray(f)) { if (!E) throw new TypeError('Expected "'.concat(m.name, '" to not repeat, but got an array')); if (f.length === 0) { if (h) continue; throw new TypeError('Expected "'.concat(m.name, '" to not be empty')) } for (var S = 0; S < f.length; S++) { var y = n(f[S], m); if (a && !c[l].test(y)) throw new TypeError('Expected all "'.concat(m.name, '" to match "').concat(m.pattern, '", but got "').concat(y, '"')); u += m.prefix + y + m.suffix } continue } if (typeof f == "string" || typeof f == "number") { var y = n(String(f), m); if (a && !c[l].test(y)) throw new TypeError('Expected "'.concat(m.name, '" to match "').concat(m.pattern, '", but got "').concat(y, '"')); u += m.prefix + y + m.suffix; continue } if (!h) { var C = E ? "an array" : "a string"; throw new TypeError('Expected "'.concat(m.name, '" to be ').concat(C)) } } return u } } function qP(e, t) { var r = [], o = Z4(e, r, t); return u8e(o, r, t) } function u8e(e, t, r) { r === void 0 && (r = {}); var o = r.decode, n = o === void 0 ? function (i) { return i } : o; return function (i) { var a = e.exec(i); if (!a) return !1; for (var c = a[0], p = a.index, u = Object.create(null), l = function (f) { if (a[f] === void 0) return "continue"; var h = t[f - 1]; h.modifier === "*" || h.modifier === "+" ? u[h.name] = a[f].split(h.prefix + h.suffix).map(function (E) { return n(E, h) }) : u[h.name] = n(a[f], h) }, m = 1; m < a.length; m++)l(m); return { path: c, index: p, params: u } } } function Yi(e) { return e.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1") } function VP(e) { return e && e.sensitive ? "" : "i" } function m8e(e, t) { if (!t) return e; for (var r = /\((?:\?<(.*?)>)?(?!\?)/g, o = 0, n = r.exec(e.source); n;)t.push({ name: n[1] || o++, prefix: "", suffix: "", modifier: "", pattern: "" }), n = r.exec(e.source); return e } function l8e(e, t, r) { var o = e.map(function (n) { return Z4(n, t, r).source }); return new RegExp("(?:".concat(o.join("|"), ")"), VP(r)) } function d8e(e, t, r) { return f8e(J4(e, r), t, r) } function f8e(e, t, r) { r === void 0 && (r = {}); for (var o = r.strict, n = o === void 0 ? !1 : o, i = r.start, a = i === void 0 ? !0 : i, c = r.end, p = c === void 0 ? !0 : c, u = r.encode, l = u === void 0 ? function (st) { return st } : u, m = r.delimiter, f = m === void 0 ? "/#?" : m, h = r.endsWith, E = h === void 0 ? "" : h, S = "[".concat(Yi(E), "]|$"), y = "[".concat(Yi(f), "]"), C = a ? "^" : "", b = 0, L = e; b < L.length; b++) { var N = L[b]; if (typeof N == "string") C += Yi(l(N)); else { var j = Yi(l(N.prefix)), re = Yi(l(N.suffix)); if (N.pattern) if (t && t.push(N), j || re) if (N.modifier === "+" || N.modifier === "*") { var Ce = N.modifier === "*" ? "?" : ""; C += "(?:".concat(j, "((?:").concat(N.pattern, ")(?:").concat(re).concat(j, "(?:").concat(N.pattern, "))*)").concat(re, ")").concat(Ce) } else C += "(?:".concat(j, "(").concat(N.pattern, ")").concat(re, ")").concat(N.modifier); else { if (N.modifier === "+" || N.modifier === "*") throw new TypeError('Can not repeat "'.concat(N.name, '" without a prefix and suffix')); C += "(".concat(N.pattern, ")").concat(N.modifier) } else C += "(?:".concat(j).concat(re, ")").concat(N.modifier) } } if (p) n || (C += "".concat(y, "?")), C += r.endsWith ? "(?=".concat(S, ")") : "$"; else { var O = e[e.length - 1], ie = typeof O == "string" ? y.indexOf(O[O.length - 1]) > -1 : O === void 0; n || (C += "(?:".concat(y, "(?=").concat(S, "))?")), ie || (C += "(?=".concat(y, "|").concat(S, ")")) } return new RegExp(C, VP(r)) } function Z4(e, t, r) { return e instanceof RegExp ? m8e(e, t) : Array.isArray(e) ? l8e(e, t, r) : d8e(e, t, r) } function eq(e) { let t = e.host + e.pathname; return `${e.protocol}//${t.replace(/\\/g, "/").replace(/\/\/+/g, "/")}${e.search}` } vr(); var h8e = `^/(?:${Ko.locales.map(e => `${e}/?`).join("|")})?`, g8e = Ko.basePath ? `^${Ko.basePath}/?` : "^/", x8e = h8e.replace("^/", g8e); function tq(e) { let t = e.map(n => ({ page: n.page, regexp: new RegExp(n.regex.replace("^/", x8e)) })), r = new Set, o = new Set; for (let [n, i] of Object.entries($P)) n.endsWith("page") ? r.add(i) : n.endsWith("route") && o.add(i); return function (i) { return t.filter(c => c.regexp.test(i)).map(c => { let p = "page"; return r.has(c.page) ? p = "app" : o.has(c.page) && (p = "route"), { route: c.page, type: p } }) } } var pf = tq([...Ko.routes.static, ...E8e()]), uf = tq(Ko.routes.dynamic); function E8e() { let e = n => ({ page: n, regex: `^${n}(?:/)?$` }), t = new Set(Ko.routes.dynamic.map(({ page: n }) => n)), r = Object.keys(B4).filter(n => n.startsWith("/api/") && !t.has(n)).map(e), o = Object.values($P).filter(n => (n.startsWith("/api/") || n === "/api") && !t.has(n)).map(e); return [...r, ...o] } var oq = (e, t, r) => o => { switch (o.type) { case "header": return !!e?.[o.key.toLowerCase()] && new RegExp(o.value ?? "").test(e[o.key.toLowerCase()] ?? ""); case "cookie": return !!t?.[o.key] && new RegExp(o.value ?? "").test(t[o.key] ?? ""); case "query": return r[o.key] && Array.isArray(o.value) ? o.value.reduce((n, i) => n || new RegExp(i).test(r[o.key]), !1) : new RegExp(o.value ?? "").test(r[o.key] ?? ""); case "host": return e?.host !== "" && new RegExp(o.value ?? "").test(e.host); default: return !1 } }; function Wx(e, t, r = !1) { return t ? t.reduce((o, n) => o === !1 ? !1 : r ? !e(n) : e(n), !0) : !0 } var y8e = e => t => { be("value", t); let r = e(t); return r ? r.params : {} }, S8e = (e, t, r) => o => { if (!o.value) return {}; let n = new RegExp(`^${o.value}$`), i = a => a.match(n)?.groups ?? {}; switch (o.type) { case "header": return i(e[o.key.toLowerCase()] ?? ""); case "cookie": return i(t[o.key] ?? ""); case "query": return Array.isArray(r[o.key]) ? i(r[o.key].join(",")) : i(r[o.key] ?? ""); case "host": return i(e.host ?? "") } }; function rq(e, t, r) { if (!e) return r; let { params: o } = e; return Object.keys(o).length > 0 ? t(o) : r } function nq(e, t) { if (!t) return {}; let r = oq(e.headers, e.cookies, e.query), o = {}, n = pi(e); for (let { headers: i, has: a, missing: c, regex: p, source: u, locale: l } of t) { let m = l === !1 ? e.rawPath : n; if (new RegExp(p).test(m) && Wx(r, a) && Wx(r, c, !0)) { let h = qP(u)(m); i.forEach(E => { try { let S = rq(h, Op(E.key), E.key), y = rq(h, Op(E.value), E.value); o[S] = y } catch { be(`Error matching header ${E.key} with value ${E.value}`), o[E.key] = E.value } }) } } return o } function mf(e, t) { let { rawPath: r, headers: o, query: n, cookies: i, url: a } = e, c = pi(e), p = oq(o, i, n), u = S8e(o, i, n), l = t.find(E => { let S = E.locale === !1 ? r : c; return new RegExp(E.regex).test(S) && Wx(p, E.has) && Wx(p, E.missing, !0) }), m = n, f = a, h = qx(l?.destination); if (be("isExternalRewrite", h), l) { let { pathname: E, protocol: S, hostname: y, queryString: C } = G4(l.destination, h), b = l.locale === !1 ? r : c; be("urlParts", { pathname: E, protocol: S, hostname: y, queryString: C }); let L = Op(af(E, { isPath: !0 })), N = Op(af(y)), j = Op(af(C)), re = { ...y8e(qP(af(l.source, { isPath: !0 })))(b), ...l.has?.reduce((Ct, dt) => Object.assign(Ct, u(dt)), {}), ...l.missing?.reduce((Ct, dt) => Object.assign(Ct, u(dt)), {}) }, Ce = Object.keys(re).length > 0, O = C, ie = y, st = E; if (Ce && (st = Vx(L(re)), ie = Vx(N(re)), O = Vx(j(re))), Ue.i18n && !h) { let Ct = st.replace(new RegExp(`^/(${Ue.i18n.locales.join("|")})`), ""); Ct.startsWith("/api/") && (st = Ct) } f = h ? `${S}//${ie}${st}` : new URL(st, e.url).href, m = { ...n, ...H4(O) }, f += sf(m), be("rewrittenUrl", { rewrittenUrl: f, finalQuery: m, isUsingParams: Ce }) } return { internalEvent: { ...e, query: m, rawPath: new URL(f).pathname, url: f }, __rewrite: l, isExternalRewrite: h } } function _8e(e) { return e.rawPath.match(/(\\|\/\/)/) ? { type: e.type, statusCode: 308, headers: { Location: eq(new URL(e.url)) }, body: ts(), isBase64Encoded: !1 } : !1 } function C8e(e) { if (new URL(e.rawPath, "http://localhost").host !== "localhost" || Ue.skipTrailingSlashRedirect || e.rawPath.startsWith("/api/")) return !1; let r = ts(); if (Ue.trailingSlash && !e.headers["x-nextjs-data"] && !e.rawPath.endsWith("/") && !e.rawPath.match(/[\w-]+\.[\w]+$/g)) { let o = e.url.split("?"); return { type: e.type, statusCode: 308, headers: { Location: `${o[0]}/${o[1] ? `?${o[1]}` : ""}` }, body: r, isBase64Encoded: !1 } } if (!Ue.trailingSlash && e.rawPath.endsWith("/") && e.rawPath !== "/") { let o = e.url.split("?"); return { type: e.type, statusCode: 308, headers: { Location: `${o[0].replace(/\/$/, "")}${o[1] ? `?${o[1]}` : ""}` }, body: r, isBase64Encoded: !1 } } return !1 } function sq(e, t) { let r = _8e(e); if (r) return r; let o = C8e(e); if (o) return o; let n = F4(e); if (n) return n; let { internalEvent: i, __rewrite: a } = mf(e, t.filter(c => !c.internal)); if (a && !a.internal) return { type: e.type, statusCode: a.statusCode ?? 308, headers: { Location: i.url }, body: ts(), isBase64Encoded: !1 } } function iq(e, t) { let { rawPath: r, query: o } = e, n = Ue.basePath ?? "", i = `${n}/_next/data/${t}`; if (r.startsWith("/_next/data") && !r.startsWith(i)) return { type: e.type, statusCode: 404, body: of("{}"), headers: { "Content-Type": "application/json" }, isBase64Encoded: !1 }; if (r.startsWith(i) && r.endsWith(".json")) { let a = `${n}${r.slice(i.length, -5).replace(/^\/index$/, "/")}`; return o.__nextDataReq = "1", { ...e, rawPath: a, query: o, url: new URL(`${a}${sf(o)}`, e.url).href } } return e } function aq(e, t) { let { rawPath: r } = e, { dynamicRoutes: o = {}, routes: n = {} } = t ?? {}, i = Object.entries(o).filter(([, { fallback: E }]) => E === !1), a = i.some(([, { routeRegex: E }]) => new RegExp(E).test(r)), c = Ue.i18n?.locales, u = c?.includes(r.split("/")[1]) || c === void 0 ? r : `/${Ue.i18n?.defaultLocale}${r}`; u !== "/" && Ue.trailingSlash && u.endsWith("/") && (u = u.slice(0, -1)); let l = pf(u), m = i.map(([E]) => E), f = uf(u).filter(({ route: E }) => !m.includes(E)), h = Object.keys(n).includes(u); return a && !h && l.length === 0 && f.length === 0 ? { event: { ...e, rawPath: "/404", url: ui(e.url, "/404"), headers: { ...e.headers, "x-invoke-status": "404" } }, isISR: !1 } : { event: e, isISR: a || h } } zP(); var R8e = L4, A8e = M4, T8e = V4(R8e, A8e), w8e = new Set([301, 302, 303, 307, 308]); function b8e() { return import("./middleware.mjs") } async function cq(e, t, r = b8e) { let o = e.headers; if (o["x-isr"] && o["x-prerender-revalidate"] === ys?.preview?.previewModeId) return e; let n = pi(e); if (!T8e.some(N => N.test(n))) return e; let a = new URL(n, e.url); a.search = t; let c = a.href, u = await (await r()).default({ geo: { city: decodeURIComponent(o["x-open-next-city"]), country: o["x-open-next-country"], region: o["x-open-next-region"], latitude: o["x-open-next-latitude"], longitude: o["x-open-next-longitude"] }, headers: o, method: e.method || "GET", nextConfig: { basePath: Ue.basePath, i18n: Ue.i18n, trailingSlash: Ue.trailingSlash }, url: c, body: z4(e.method, e.body) }), l = u.status, m = u.headers, f = {}, h = {}, E = ["x-middleware-override-headers", "x-middleware-next", "x-middleware-rewrite", "content-encoding"], S = "x-middleware-request-"; m.forEach((N, j) => { if (j.startsWith(S)) { let re = j.substring(S.length); f[re] = N } else { if (E.includes(j.toLowerCase())) return; j.toLowerCase() === "set-cookie" ? h[j] = h[j] ? [...h[j], N] : [N] : w8e.has(l) && j.toLowerCase() === "location" ? h[j] = zx(N, e.url) : h[j] = N } }); let y = m.get("x-middleware-rewrite"), C = !1, b = e.query, L = e.url; if (y) if (L = y, qx(L, e.headers.host)) C = !0; else { let N = new URL(y); b = Kx(N.searchParams), "__nextDataReq" in e.query && (b.__nextDataReq = e.query.__nextDataReq) } if (!y && !m.get("x-middleware-next")) { let N = u.body ?? ts(); return { type: e.type, statusCode: l, headers: h, body: N, isBase64Encoded: !1 } } return { responseHeaders: h, url: L, rawPath: new URL(L).pathname, type: e.type, headers: { ...e.headers, ...f }, body: e.body, method: e.method, query: b, cookies: e.cookies, remoteAddress: e.remoteAddress, isExternalRewrite: C, rewriteStatusCode: y && !C ? l : void 0 } } var df = "x-middleware-response-", pq = df.length, Dp = "x-opennext-", KP = `${Dp}initial-url`, hjt = `${Dp}locale`, QP = `${Dp}resolved-routes`, uq = `${Dp}rewrite-status-code`, mq = `${Dp}request-id`, I8e = { "x-open-next-city": "x-vercel-ip-city", "x-open-next-country": "x-vercel-ip-country", "x-open-next-region": "x-vercel-ip-country-region", "x-open-next-latitude": "x-vercel-ip-latitude", "x-open-next-longitude": "x-vercel-ip-longitude" }; function WP(e, t) { let r = lf(e), o = e.headers, n = r ? "" : df; Object.entries(t).forEach(([i, a]) => { a && (o[n + i] = Array.isArray(a) ? a.join(",") : a) }) } async function YP(e, { assetResolver: t }) { try { for (let [y, C] of Object.entries(I8e)) { let b = e.headers[y]; b && (e.headers[C] = b) } for (let y of Object.keys(e.headers)) (y.startsWith(Dp) || y.startsWith(df)) && delete e.headers[y]; let r = nq(e, N4), o = iq(e, rf); if (lf(o)) return o; let n = sq(o, Ko.redirects); if (n) return n.headers.Location = zx(n.headers.Location, e.url, !0), be("redirect", n), n; let i = await cq(o, new URL(e.url).search); if (lf(i)) return i; globalThis.openNextConfig.dangerous?.middlewareHeadersOverrideNextConfigHeaders ?? !1 ? r = { ...r, ...i.responseHeaders } : r = { ...i.responseHeaders, ...r }; let c = i.isExternalRewrite ?? !1; if (o = i, !c) { let y = mf(o, Ko.rewrites.beforeFiles); if (o = y.internalEvent, c = y.isExternalRewrite, !c) { let C = await t?.maybeGetAssetResult?.(o); if (C) return WP(C, r), C } } let p = pf(o.rawPath), u = !c && p.length > 0; if (!(u || c)) { let y = mf(o, Ko.rewrites.afterFiles); o = y.internalEvent, c = y.isExternalRewrite } let l = !1; if (!c) { let y = aq(o, ys); o = y.event, l = y.isISR } let m = uf(o.rawPath), f = !c && m.length > 0; if (!(f || u || c)) { let y = mf(o, Ko.rewrites.fallback); o = y.internalEvent, c = y.isExternalRewrite } let h = o.rawPath.startsWith("/_next/image"); if (u || f || c || h || pf(o.rawPath).length > 0 || uf(o.rawPath).length > 0 || (o = { ...o, rawPath: "/404", url: ui(o.url, "/404"), headers: { ...o.headers, "x-middleware-response-cache-control": "private, no-cache, no-store, max-age=0, must-revalidate" } }), globalThis.openNextConfig.dangerous?.enableCacheInterception && !lf(o) && (be("Cache interception enabled"), o = await X4(o), lf(o))) return WP(o, r), o; WP(o, r); let S = [...p, ...m]; return be("resolvedRoutes", S), { internalEvent: o, isExternalRewrite: c, origin: !1, isISR: l, resolvedRoutes: S, initialURL: e.url, locale: Ue.i18n ? nf(o, Ue.i18n) : void 0, rewriteStatusCode: i.rewriteStatusCode } } catch (r) { return Qt("Error in routingHandler", r), { internalEvent: { type: "core", method: "GET", rawPath: "/500", url: ui(e.url, "/500"), headers: { ...e.headers }, query: e.query, cookies: e.cookies, remoteAddress: e.remoteAddress }, isExternalRewrite: !1, origin: !1, isISR: !1, resolvedRoutes: [], initialURL: e.url, locale: Ue.i18n ? nf(e, Ue.i18n) : void 0 } } } function lf(e) { return e != null && "statusCode" in e } vr(); import P8e from "next/dist/server/next-server.js"; vr(); var v8e = ai("node:module"), Ejt = v8e._resolveFilename; var O8e = ai.resolve("./cache.cjs"), D8e = ai.resolve("./composable-cache.cjs"), Np = new P8e.default({ conf: { ...Ue, compress: !1, cacheHandler: O8e, cacheMaxMemorySize: 0, experimental: { ...Ue.experimental, trustHostHeader: !0, cacheHandlers: { default: D8e } } }, customServer: !1, dev: !1, dir: __dirname }), kp = !1; globalThis.__next_route_preloader = async e => { if (kp) return; let r = (globalThis.fnName ? globalThis.openNextConfig.functions[globalThis.fnName] : globalThis.openNextConfig.default)?.routePreloadingBehavior ?? "none"; if (r === "none") { kp = !0; return } if (!("unstable_preloadEntries" in Np)) { be("The current version of Next.js does not support route preloading. Skipping route preloading."), kp = !0; return } if (e === "waitUntil" && r === "withWaitUntil") { let o = globalThis.__openNextAls.getStore()?.waitUntil; if (!o) { Qt("You've tried to use the 'withWaitUntil' route preloading behavior, but the 'waitUntil' function is not available."), kp = !0; return } be("Preloading entries with waitUntil"), o?.(Np.unstable_preloadEntries()), kp = !0 } else if (e === "start" && r === "onStart" || e === "warmerEvent" && r === "onWarmerEvent" || e === "onDemand") { let o = Date.now(); be("Preloading entries"), await Np.unstable_preloadEntries(), be("Preloading entries took", Date.now() - o, "ms"), kp = !0 } }; var Qx = e => "getRequestHandlerWithMetadata" in Np ? Np.getRequestHandlerWithMetadata(e) : Np.getRequestHandler(); globalThis.__openNextAls = new k8e; async function lq(e, t) { let r = e.headers, o = globalThis.openNextConfig.middleware?.external ? e.headers[mq] : Math.random().toString(36); return C4({ isISRRevalidation: r["x-isr"] === "1", waitUntil: t?.waitUntil, requestId: o }, async () => { await globalThis.__next_route_preloader("waitUntil"), r["x-forwarded-host"] && (r.host = r["x-forwarded-host"]), be("internalEvent", e); let n = { initialPath: r[KP] ?? e.rawPath, resolvedRoutes: r[QP] ? JSON.parse(r[QP]) : [], rewriteStatusCode: Number.parseInt(r[uq]) }, i = { internalEvent: e, isExternalRewrite: !1, origin: !1, isISR: !1, initialURL: e.url, ...n }; i = await YP(e, { assetResolver: globalThis.assetResolver }); let a = "type" in i ? i.headers : i.internalEvent.headers, c = {}; for (let [re, Ce] of Object.entries(a)) { if (!re.startsWith(df)) continue; let O = re.slice(pq); O !== "x-middleware-set-cookie" && (c[O] = Ce), a[O] = Ce, delete a[re] } if ("isExternalRewrite" in i && i.isExternalRewrite === !0) try { i = await globalThis.proxyExternalRequest.proxy(i.internalEvent) } catch (re) { Qt("External request failed.", re), i = { internalEvent: { type: "core", rawPath: "/500", method: "GET", headers: {}, url: ui(e.url, "/500"), query: {}, cookies: {}, remoteAddress: "" }, isExternalRewrite: !1, isISR: !1, origin: !1, initialURL: e.url, resolvedRoutes: [{ route: "/500", type: "page" }] } } if ("type" in i) { if (t?.streamCreator) { let re = GP({ internalEvent: e, isExternalRewrite: !1, isISR: !1, resolvedRoutes: [], origin: !1, initialURL: e.url }, i.headers, t.streamCreator); re.statusCode = i.statusCode, re.flushHeaders(); let [Ce, O] = i.body.tee(); for await (let ie of Ce) re.write(ie); re.end(), i.body = O } return i } let p = i.internalEvent; be("preprocessedEvent", p); let { search: u, pathname: l, hash: m } = new URL(p.url), f = { method: p.method, url: `${l}${u}${m}`, headers: { ...a }, body: p.body, remoteAddress: p.remoteAddress }, h = globalThis.openNextConfig.dangerous?.headersAndCookiesPriority ? globalThis.openNextConfig.dangerous.headersAndCookiesPriority(p) : "middleware", E = globalThis.__openNextAls.getStore(); E && (E.mergeHeadersPriority = h); let S = new tf(f), y = GP(i, c, t?.streamCreator); await N8e(S, y, i); let { statusCode: C, headers: b, isBase64Encoded: L, body: N } = j4(y); return { type: e.type, statusCode: C, headers: b, body: N, isBase64Encoded: L } }) } async function N8e(e, t, r) { delete e.body; let o = new URL(r.internalEvent.headers[KP] ?? r.initialURL), n; r.internalEvent.rawPath === "/500" ? n = 500 : r.internalEvent.rawPath === "/404" && (n = 404); let i = { isNextDataReq: r.internalEvent.query.__nextDataReq === "1", initURL: r.initialURL, initQuery: q4(o.search), initProtocol: o.protocol, defaultLocale: Ue.i18n?.defaultLocale, locale: r.locale, middlewareInvoke: !1, invokePath: r.internalEvent.rawPath, invokeQuery: r.internalEvent.query, invokeStatus: n }; try { e.url = o.pathname + sf(r.internalEvent.query), await Qx(i)(e, t) } catch (a) { a.constructor.name === "NoFallbackError" ? await dq(e, t, r, i) : (Qt("NextJS request failed.", a), await Yx("500", t, r.internalEvent)) } } async function dq(e, t, r, o, n = 1) { if (n >= 5) { await Yx("500", t, r.internalEvent); return } if (n >= r.resolvedRoutes.length) { await Yx("404", t, r.internalEvent); return } try { await Qx({ ...r, invokeOutput: r.resolvedRoutes[n].route, ...o })(e, t) } catch (i) { i.constructor.name === "NoFallbackError" ? await dq(e, t, r, o, n + 1) : (Qt("NextJS request failed.", i), await Yx("500", t, r.internalEvent)) } } async function Yx(e, t, r) { try { let o = new tf({ method: "GET", url: `/${e}`, headers: r.headers, body: r.body, remoteAddress: r.remoteAddress }); await Qx({ invokePath: e === "404" ? "/404" : "/500", invokeStatus: e === "404" ? 404 : 500, middlewareInvoke: !1 })(o, t) } catch (o) { Qt("NextJS request failed.", o), t.statusCode = 500, t.setHeader("Content-Type", "application/json"), t.end(JSON.stringify({ message: "Server failed to respond.", details: o }, null, 2)) } } async function d6e(e) { return typeof e == "function" ? e() : (await Promise.resolve().then(() => (_q(), Sq))).default } async function f6e(e) { return typeof e == "function" ? e() : (await Promise.resolve().then(() => (Aq(), Rq))).default } async function h6e(e) { return typeof e == "function" ? e() : (await Promise.resolve().then(() => (BCe(), NCe))).default } async function g6e(e) { return typeof e == "function" ? e() : (await Promise.resolve().then(() => (KOe(), WOe))).default } async function x6e(e) { return typeof e == "function" ? e() : (await Promise.resolve().then(() => (s6e(), n6e))).default } async function E6e(e) { return typeof e == "function" ? e() : (await Promise.resolve().then(() => (a6e(), i6e))).default } async function y6e(e) { return typeof e == "function" ? e() : (await Promise.resolve().then(() => (u6e(), p6e))).default } async function S6e(e) { return typeof e == "function" ? e() : (await Promise.resolve().then(() => (l6e(), m6e))).default } async function _6e() { let e = await import("./open-next.config.mjs").then(i => i.default), t = globalThis.fnName ? e.functions[globalThis.fnName] : e.default; globalThis.serverId = _4(), globalThis.openNextConfig = e, await globalThis.__next_route_preloader("start"), globalThis.queue = await g6e(t.override?.queue), globalThis.incrementalCache = await x6e(t.override?.incrementalCache), globalThis.tagCache = await h6e(t.override?.tagCache), e.middleware?.external !== !0 && (globalThis.assetResolver = await E6e(globalThis.openNextConfig.middleware?.assetResolver)), globalThis.proxyExternalRequest = await y6e(t.override?.proxyExternalRequest), globalThis.cdnInvalidationHandler = await S6e(t.override?.cdnInvalidation); let r = await d6e(t.override?.converter), { wrapper: o, name: n } = await f6e(t.override?.wrapper); return be("Using wrapper", n), o(lq, r) } Zd(); S4(); P2t(); globalThis.internalFetch = fetch; var fWo = await _6e(); function P2t() { process.chdir(__dirname) } export { fWo as handler };
